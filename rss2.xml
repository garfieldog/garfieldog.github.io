<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Wed, 02 Sep 2015 03:38:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Regular Expression Matching]]></title>
      <link>http://garfieldog.github.io/2015/09/01/regular-expression-matching/</link>
      <guid>http://garfieldog.github.io/2015/09/01/regular-expression-matching/</guid>
      <pubDate>Tue, 01 Sep 2015 10:30:11 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement regular expression matching with support for ‘.’ and ‘*‘.</p>
<p>‘.’ Matches any single charact]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement regular expression matching with support for ‘.’ and ‘*‘.</p>
<p>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.</p>
<p>The matching should cover the entire input string (not partial).</p>
<p>The function prototype should be:<br>bool isMatch(const char *s, const char *p)</p>
<p>Some examples:<br>isMatch(“aa”,”a”) → false<br>isMatch(“aa”,”aa”) → true<br>isMatch(“aaa”,”aa”) → false<br>isMatch(“aa”, “a*“) → true<br>isMatch(“aa”, “.*“) → true<br>isMatch(“ab”, “.*“) → true<br>isMatch(“aab”, “c*a*b”) → true</p>
</blockquote>
<h2 id="分析">分析</h2><p>有一定难度，主要是判断<code>*</code>。可以采取<a href="http://articles.leetcode.com/2011/09/regular-expression-matching.html" target="_blank" rel="external">递归法</a>或<a href="http://www.cnblogs.com/flowerkzj/p/3726667.html" target="_blank" rel="external">动态规划</a>。当然，转换为DFA自动机然后做也是没问题的，但实现难度就要更大一些。</p>
<h3 id="TBD">TBD</h3><p>算法分析参考上面给的两篇文章链接。具体分析有点复杂，先留空，刷完题再补。</p>
<h2 id="代码">代码</h2><h3 id="递归法">递归法</h3><p>Leetcode上提交会超时<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">END = <span class="string">'\001'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatchR</span><span class="params">(self, s, i, p, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p[j] == END:</span><br><span class="line">            <span class="keyword">return</span> s[i] == END</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p[j + <span class="number">1</span>] != <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> (p[j] == s[i] <span class="keyword">or</span> (p[j] == <span class="string">'.'</span> <span class="keyword">and</span> s[i] != END)) \</span><br><span class="line">                <span class="keyword">and</span> self.isMatchR(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># p[j] == '*'</span></span><br><span class="line">        <span class="keyword">while</span>(p[j] == s[i] <span class="keyword">or</span> (p[j] == <span class="string">'.'</span> <span class="keyword">and</span> s[i] != END)):</span><br><span class="line">            <span class="keyword">if</span> self.isMatchR(s, i, p, j + <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.isMatchR(s, i, p, j + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type p: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        s += END</span><br><span class="line">        p += END</span><br><span class="line">        <span class="keyword">return</span> self.isMatchR(s, <span class="number">0</span>, p, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="动态规划">动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatchChar</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a == b <span class="keyword">or</span> b == <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type p: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        m = len(p)</span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># fisrt row, s == ''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[i - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">                    dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>]</span><br><span class="line">            <span class="comment"># otherwise leave dp[0][i] = False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># leave dp[i][0] = False for i &gt; 0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    <span class="comment"># j must &gt; 1</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] <span class="keyword">or</span> dp[i][j - <span class="number">2</span>] <span class="keyword">or</span> \</span><br><span class="line">                        (dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> self.isMatchChar(s[i - <span class="number">1</span>], p[j - <span class="number">2</span>]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> self.isMatchChar(s[i - <span class="number">1</span>], p[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/01/regular-expression-matching/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Longest Palindromic Substring]]></title>
      <link>http://garfieldog.github.io/2015/08/31/longest-palindromic-substring/</link>
      <guid>http://garfieldog.github.io/2015/08/31/longest-palindromic-substring/</guid>
      <pubDate>Mon, 31 Aug 2015 11:15:48 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>
</blockquote>
<h2 id="分析">分析</h2><p>如果暴力搜索，对每一个位置都进行两边扩张，时间复杂度为<code>O(n^2)</code>。进过观察发现判断从位置<code>i</code>到<code>j</code>之间的字符串是否为回文满足动态规划的最优子结构<code>f(i, j) = (s[j] == s[i]) and (j - i &lt; 2 or f(i + 1, j - 1))</code>。所以可以使用一个二维数组来缓存子问题结果，时间复杂度<code>O(n^2)</code>，空间<code>O(n^2)</code>。</p>
<p>目前最优的解法是<a href="http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html" target="_blank" rel="external">Manacher</a>算法，通过一个精妙的构造省去了大量冗余的搜索。对于长回文字符串时间可以降到<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="暴力搜索">暴力搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        idx = -<span class="number">1</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="comment"># search as center</span></span><br><span class="line">            l = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + j &lt; n <span class="keyword">and</span> s[i - j] == s[i + j]:</span><br><span class="line">                l += <span class="number">2</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> l &gt; max_len:</span><br><span class="line">                max_len = l</span><br><span class="line">                idx = i - (l - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># search as left center</span></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; n <span class="keyword">and</span> s[i] == s[i + <span class="number">1</span>]:</span><br><span class="line">                l = <span class="number">2</span></span><br><span class="line">                j = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> i - j &gt;= <span class="number">0</span> <span class="keyword">and</span> i + <span class="number">1</span> + j &lt; n <span class="keyword">and</span> s[i - j] == s[i + <span class="number">1</span> + j]:</span><br><span class="line">                    l += <span class="number">2</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> l &gt; max_len:</span><br><span class="line">                    max_len = l</span><br><span class="line">                    idx = i - l / <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[idx: idx + max_len]</span><br></pre></td></tr></table></figure>
<h3 id="动态规划">动态规划</h3><p>在Leetcode上提交会超时<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="comment"># matrix to store if s[i:j+1] is palindrome</span></span><br><span class="line">        f = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        idx = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">            f[j][j] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(j):</span><br><span class="line">                f[i][j] = (s[j] == s[i]) <span class="keyword">and</span> (j - i &lt; <span class="number">2</span> <span class="keyword">or</span> f[i + <span class="number">1</span>][j - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> f[i][j] <span class="keyword">and</span> (j - i + <span class="number">1</span>) &gt; max_len:</span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line">                    idx = i</span><br><span class="line">        <span class="keyword">return</span> s[idx: idx + max_len]</span><br></pre></td></tr></table></figure></p>
<h3 id="Manacher算法">Manacher算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preProcess</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'^$'</span></span><br><span class="line">        rs = [<span class="string">'^'</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            rs.append(<span class="string">'#'</span>)</span><br><span class="line">            rs.append(c)</span><br><span class="line">        rs.append(<span class="string">'#$'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(rs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        ns = self.preProcess(s)</span><br><span class="line">        n = len(ns)</span><br><span class="line">        p = [<span class="number">0</span>] * n</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        mx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            j = <span class="number">2</span> * idx - i</span><br><span class="line">            <span class="keyword">if</span> i &lt; mx:</span><br><span class="line">                p[i] = min(mx - i, p[j])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p[i] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ns[i + p[i]] == ns[i - p[i]]:</span><br><span class="line">                p[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i + p[i] &gt; mx:</span><br><span class="line">                mx = i + p[i]</span><br><span class="line">                idx = i</span><br><span class="line"></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        max_idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[i] &gt; max_len:</span><br><span class="line">                max_len = p[i]</span><br><span class="line">                max_idx = i</span><br><span class="line">        <span class="keyword">return</span> s[(max_idx - max_len) / <span class="number">2</span>: (max_idx + max_len - <span class="number">1</span>) / <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/31/longest-palindromic-substring/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Add Binary]]></title>
      <link>http://garfieldog.github.io/2015/08/31/add-binary/</link>
      <guid>http://garfieldog.github.io/2015/08/31/add-binary/</guid>
      <pubDate>Mon, 31 Aug 2015 10:47:58 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two binary strings, return their sum (also a binary string).</p>
<p>For example,<br>a = “11”<br>b =]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two binary strings, return their sum (also a binary string).</p>
<p>For example,<br>a = “11”<br>b = “1”<br>Return “100”.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBit</span><span class="params">(self, a, b, c)</span>:</span></span><br><span class="line">        s = int(a) + int(b) + int(c)</span><br><span class="line">        <span class="keyword">return</span> divmod(s, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n / <span class="number">2</span>):</span><br><span class="line">            arr[i], arr[n - <span class="number">1</span> - i] = arr[n - <span class="number">1</span> - i], arr[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type a: str</span><br><span class="line">        :type b: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        m, n = len(a), len(b)</span><br><span class="line">        <span class="keyword">if</span> m &gt; n:</span><br><span class="line">            <span class="keyword">return</span> self.addBinary(b, a)</span><br><span class="line"></span><br><span class="line">        rs = []</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            c, x = self.addBit(a[m - <span class="number">1</span> - i], b[n - <span class="number">1</span> - i], c)</span><br><span class="line">            rs.append(str(x))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m, n):</span><br><span class="line">            c, x = self.addBit(b[n - <span class="number">1</span> - i], <span class="number">0</span>, c)</span><br><span class="line">            rs.append(str(x))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">1</span>:</span><br><span class="line">            rs.append(<span class="string">'1'</span>)</span><br><span class="line">        self.reverse(rs)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(rs)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/31/add-binary/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-String to Integer]]></title>
      <link>http://garfieldog.github.io/2015/08/31/string-to-integer/</link>
      <guid>http://garfieldog.github.io/2015/08/31/string-to-integer/</guid>
      <pubDate>Mon, 31 Aug 2015 09:30:39 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement atoi to convert a string to an integer.</p>
<p>Hint: Carefully consider all possible input case]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement atoi to convert a string to an integer.</p>
<p>Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.</p>
<p>Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.</p>
<p>Requirements for atoi:<br>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，但要想全各种输入情况。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type str: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(str)</span><br><span class="line">        <span class="comment"># skip leading-whitespaces</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> str[i] == <span class="string">' '</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> str[i] == <span class="string">'+'</span>:</span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> str[i] == <span class="string">'-'</span>:</span><br><span class="line">            sign = -<span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        int_max, int_min = <span class="number">2147483647</span>, -<span class="number">2147483648</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> str[i].isdigit():</span><br><span class="line">            x = x * <span class="number">10</span> + int(str[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        x *= sign</span><br><span class="line">        x = min(int_max, x)</span><br><span class="line">        x = max(int_min, x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/31/string-to-integer/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Implement strStr()]]></title>
      <link>http://garfieldog.github.io/2015/08/31/implement-strstr/</link>
      <guid>http://garfieldog.github.io/2015/08/31/implement-strstr/</guid>
      <pubDate>Mon, 31 Aug 2015 03:50:48 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if need]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<h2 id="分析">分析</h2><p>查找子字符串，暴力搜索时间复杂度<code>O(mn)</code>，其中<code>m``n</code>分别是haystack和need的长度。还有很多经典算法，如<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">KMP</a>，<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" target="_blank" rel="external">Boyer-Moore</a>。KMP算法最坏是时间<code>O(m + n)</code>的，实现可以参考<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">Wiki</a>或<a href="http://www.matrix67.com/blog/archives/115" target="_blank" rel="external">KMP算法详解</a>。<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" target="_blank" rel="external">Boyer-Moore</a>算法实际情况下表现通常优于KMP，尽管它（needle在haystack中时的）最坏情况下时间是<code>O(mn)</code>的。可以参考<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="external">字符串匹配的Boyer-Moore算法</a>。</p>
<p>因为<code>BM</code>算法使用了两个启发式规则（<code>坏字符</code>和<code>好后缀</code>）来移动needle，而这两个规则是独立的，所以其实用一个也不影响正确性，实现起来方便，只是运行稍慢一些。</p>
<h2 id="代码">代码</h2><h3 id="暴力搜索">暴力搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, haystack, i, needle)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(len(needle)):</span><br><span class="line">            <span class="keyword">if</span> haystack[i + k] != needle[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type haystack: str</span><br><span class="line">        :type needle: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        m, n = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.match(haystack, i, needle):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="KMP">KMP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type haystack: str</span><br><span class="line">        :type needle: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(haystack), len(needle)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pre-calculate `p` array</span></span><br><span class="line">        p = [<span class="number">0</span>]</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:</span><br><span class="line">                j = p[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[j]:</span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">            p.append(j)</span><br><span class="line"></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">                j = p[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == n:</span><br><span class="line">                <span class="keyword">return</span> i - n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="简化版BM（只有坏字符，没有好前缀）">简化版BM（只有坏字符，没有好前缀）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type haystack: str</span><br><span class="line">        :type needle: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(haystack), len(needle)</span><br><span class="line">        p = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(needle)&#125;</span><br><span class="line">        i = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m:</span><br><span class="line">            found = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                <span class="keyword">if</span> haystack[i - j] != needle[n - <span class="number">1</span> - j]:</span><br><span class="line">                    c = p.get(haystack[i - j], -<span class="number">1</span>)</span><br><span class="line">                    new_i = i - j + n - <span class="number">1</span> - c</span><br><span class="line">                    <span class="keyword">if</span> new_i &lt;= i:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        i = new_i</span><br><span class="line">                    found = <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">return</span> i - n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="完整BM">完整BM</h3><p>TBD</p>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/31/implement-strstr/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Valid Palindrome]]></title>
      <link>http://garfieldog.github.io/2015/08/31/valid-palindrome/</link>
      <guid>http://garfieldog.github.io/2015/08/31/valid-palindrome/</guid>
      <pubDate>Mon, 31 Aug 2015 03:36:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring ca]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example,<br>“A man, a plan, a canal: Panama” is a palindrome.<br>“race a car” is not a palindrome.</p>
<p>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，判断是否回文。用两指针，分别从头和尾相向而行，时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><p>###Python<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s[i].isalnum():</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> s[j].isalnum():</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i].lower() == s[j].lower():</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/31/valid-palindrome/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-LRU Cache]]></title>
      <link>http://garfieldog.github.io/2015/08/29/lru-cache/</link>
      <guid>http://garfieldog.github.io/2015/08/29/lru-cache/</guid>
      <pubDate>Sat, 29 Aug 2015 09:50:57 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the followin]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要求实现一个LRU cache，有两个要点：</p>
<ol>
<li><code>get</code>, <code>set</code>操作都应该是<code>O(1)</code>的，否则就失去了cache的意义</li>
<li>要保持LRU的语义</li>
</ol>
<p>所以我们用一个哈希表外加一个双向链表完成（单项链表无法做到<code>O(1)</code>）。用hash表来迅速定位到节点，每次访问一个节点后，将这个节点移动到链表头部(<code>move_to_head</code>)，当cache到达capacity上限时，从链表尾部删除节点。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for doubly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type capacity: int</span><br><span class="line">        """</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.dummy_head = ListNode(<span class="keyword">None</span>, -<span class="number">1</span>)</span><br><span class="line">        self.dummy_tail = ListNode(<span class="keyword">None</span>, -<span class="number">1</span>)</span><br><span class="line">        self.dummy_head.next = self.dummy_tail</span><br><span class="line">        self.dummy_tail.prev = self.dummy_head</span><br><span class="line">        self.store = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        cur = self.dummy_head.next</span><br><span class="line">        <span class="keyword">while</span> cur != self.dummy_tail:</span><br><span class="line">            <span class="keyword">print</span> cur.val, <span class="string">'-&gt;'</span>,</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">print</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == self.dummy_head <span class="keyword">or</span> node == self.dummy_tail:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.prev:</span><br><span class="line">            node.prev.next = node.next</span><br><span class="line">        <span class="keyword">if</span> node.next:</span><br><span class="line">            node.next.prev = node.prev</span><br><span class="line">        node.prev = self.dummy_head</span><br><span class="line">        node.next = self.dummy_head.next</span><br><span class="line">        self.dummy_head.next.prev = node</span><br><span class="line">        self.dummy_head.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        node = self.store.get(key, self.dummy_head)</span><br><span class="line">        self.move_to_head(node)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type key: int</span><br><span class="line">        :type value: int</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.store:</span><br><span class="line">            node = self.store[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            self.move_to_head(node)</span><br><span class="line">        <span class="keyword">elif</span> self.size &lt; self.capacity:</span><br><span class="line">            node = ListNode(key, value)</span><br><span class="line">            self.move_to_head(node)</span><br><span class="line">            self.store[key] = node</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            last = self.dummy_tail.prev</span><br><span class="line">            <span class="keyword">del</span> self.store[last.key]</span><br><span class="line">            last.val = value</span><br><span class="line">            last.key = key</span><br><span class="line">            self.store[last.key] = last</span><br><span class="line">            self.move_to_head(last)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/29/lru-cache/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reorder List]]></title>
      <link>http://garfieldog.github.io/2015/08/27/reorder-list/</link>
      <guid>http://garfieldog.github.io/2015/08/27/reorder-list/</guid>
      <pubDate>Thu, 27 Aug 2015 15:35:15 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
</blockquote>
<h2 id="分析">分析</h2><p>分四步：</p>
<ol>
<li>遍历链表获得长度</li>
<li>找到链表中点，断开成两个链表</li>
<li>翻转第二个链表</li>
<li>将两个链表合并</li>
</ol>
<p>时间复杂度<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: void Do not return anything, modify head in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        m = (l - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        head2 = cur.next</span><br><span class="line">        cur.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># now we have two lists, reverse the second one</span></span><br><span class="line">        prev = head2</span><br><span class="line">        cur = head2.next</span><br><span class="line">        prev.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            next = cur.next</span><br><span class="line">            cur.next = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = next</span><br><span class="line">        head2 = prev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># then we merge the two lists</span></span><br><span class="line">        <span class="keyword">while</span> head2:</span><br><span class="line">            n1 = head.next</span><br><span class="line">            n2 = head2.next</span><br><span class="line">            head.next = head2</span><br><span class="line">            head2.next = n1</span><br><span class="line">            head = n1</span><br><span class="line">            head2 = n2</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/27/reorder-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Linked List Cycle II]]></title>
      <link>http://garfieldog.github.io/2015/08/27/linked-list-cycle-2/</link>
      <guid>http://garfieldog.github.io/2015/08/27/linked-list-cycle-2/</guid>
      <pubDate>Thu, 27 Aug 2015 14:39:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>No]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p><a href="/2015/08/27/linked-list-cycle/">Linked List Cycle</a>的升级版。要求不仅判断是否有环，而且要找出环开始的位置。</p>
<h2 id="分析">分析</h2><p>对于存在环的情况，设从链表头部到环第一个元素的距离为<code>x</code>，从环第一个元素到两指针相遇点距离为<code>y</code>，环长度为<code>r</code>。这里可以证明的一点是，当两指针相遇时，慢指针肯定没有跑完一圈。这样来证明：当慢指针到达环第一个元素时，快指针肯定在环中某个地方，设距离环第一个元素<code>z</code>，肯定有<code>z &lt; r</code>。而快指针只需要<code>z</code>步就可以追上慢指针，所以慢指针没有机会跑完一圈。</p>
<p>设相遇时已经走了<code>t</code>步，则<code>t = x + y</code>, <code>2t = x + y + nr</code>， 其中<code>n</code>为正整数。则可以推导出<code>t = nr</code>，<code>x = nr - y = (n - 1)r + (r - y)</code>。这样一来，如果我们在两指针相遇后，再用一个指针从链表头开始走，直到它和慢指针相遇，相遇点就是环开始的地方。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        p1 = head.next</span><br><span class="line">        p2 = head.next.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2 <span class="keyword">or</span> <span class="keyword">not</span> p2.next:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p1 == p2:</span><br><span class="line">            p2 = head</span><br><span class="line">            <span class="keyword">while</span> p1 != p2:</span><br><span class="line">                p1 = p1.next</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/27/linked-list-cycle-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Linked List Cycle]]></title>
      <link>http://garfieldog.github.io/2015/08/27/linked-list-cycle/</link>
      <guid>http://garfieldog.github.io/2015/08/27/linked-list-cycle/</guid>
      <pubDate>Thu, 27 Aug 2015 14:25:31 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without usi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<h2 id="分析">分析</h2><p>经典题，使用两指针，一个每次走一步，另一个走两步，如果两指针相遇，则说明有环。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        p1 = head.next</span><br><span class="line">        p2 = head.next.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2 <span class="keyword">or</span> <span class="keyword">not</span> p2.next:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/27/linked-list-cycle/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Copy List with Random Pointer]]></title>
      <link>http://garfieldog.github.io/2015/08/26/copy-list-with-random-pointer/</link>
      <guid>http://garfieldog.github.io/2015/08/26/copy-list-with-random-pointer/</guid>
      <pubDate>Wed, 26 Aug 2015 09:51:07 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题有点技巧，拢共分三步：</p>
<ol>
<li>第一步，给原链表每个节点复制一个拷贝，插入到原节点后面。</li>
<li>第二步，再次遍历链表，给复制出来的节点设置random指针。</li>
<li>第三步，再次遍历链表，把原链表的节点和复制出来的节点拆成两个链表。</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.random = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: RandomListNode</span><br><span class="line">        :rtype: RandomListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            node = RandomListNode(cur.label)</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            cur = node.next</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.random:</span><br><span class="line">                cur.next.random = cur.random.next</span><br><span class="line">            cur = cur.next.next</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        new_head = cur.next</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">            next = cur.next</span><br><span class="line">            cur.next = cur.next.next</span><br><span class="line">            cur = next</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/copy-list-with-random-pointer/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Nodes in k-Group]]></title>
      <link>http://garfieldog.github.io/2015/08/26/reverse-nodes-in-k-group/</link>
      <guid>http://garfieldog.github.io/2015/08/26/reverse-nodes-in-k-group/</guid>
      <pubDate>Wed, 26 Aug 2015 07:00:29 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,<br>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/08/26/swap-nodes-in-pairs/">Swap Nodes in Pairs</a>的升级版。一组一组地翻转，注意指针操作。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, prev, end, k)</span>:</span></span><br><span class="line">        end_next = end.next</span><br><span class="line">        head = prev.next</span><br><span class="line">        p1 = head</span><br><span class="line">        p2 = head.next</span><br><span class="line">        <span class="keyword">while</span> p2 != end_next:</span><br><span class="line">            next = p2.next</span><br><span class="line">            p2.next = p1</span><br><span class="line">            p1 = p2</span><br><span class="line">            p2 = next</span><br><span class="line">        head.next = end_next</span><br><span class="line">        prev.next = p1</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next <span class="keyword">or</span> k &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            end = head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> end:</span><br><span class="line">                    end = end.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> end:  <span class="comment"># not enough k nodes</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            prev = self.reverse(prev, end, k)</span><br><span class="line">            head = prev.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/reverse-nodes-in-k-group/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Swap Nodes In Pairs]]></title>
      <link>http://garfieldog.github.io/2015/08/26/swap-nodes-in-pairs/</link>
      <guid>http://garfieldog.github.io/2015/08/26/swap-nodes-in-pairs/</guid>
      <pubDate>Wed, 26 Aug 2015 06:34:09 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&g]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
</blockquote>
<h2 id="分析">分析</h2><p>遍历链表，隔一个数（分奇偶）把当前数插到它前一个数的前面。时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="实现">实现</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy1 = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy2 = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy1.next = dummy2</span><br><span class="line">        dummy2.next = head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        prev = dummy1</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                next = cur.next</span><br><span class="line">                prev.next.next = cur.next</span><br><span class="line">                cur.next = prev.next</span><br><span class="line">                prev.next = cur</span><br><span class="line">                cur = next</span><br><span class="line">                prev = prev.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                prev = prev.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dummy2.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/swap-nodes-in-pairs/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Nth node From End of List]]></title>
      <link>http://garfieldog.github.io/2015/08/26/remove-nth-node-from-end-of-list/</link>
      <guid>http://garfieldog.github.io/2015/08/26/remove-nth-node-from-end-of-list/</guid>
      <pubDate>Wed, 26 Aug 2015 06:10:04 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,</p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们在<a href="/2015/08/26/rotate-list/">Rotate List</a>中已经讨论过这个方法，用两指针，时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        p1 = p2 = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            p1 = p1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1.next:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line"></span><br><span class="line">        p2.next = p2.next.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/remove-nth-node-from-end-of-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Rotate Array]]></title>
      <link>http://garfieldog.github.io/2015/08/26/rotate-array/</link>
      <guid>http://garfieldog.github.io/2015/08/26/rotate-array/</guid>
      <pubDate>Wed, 26 Aug 2015 03:56:18 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the arra]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
</blockquote>
<h2 id="分析">分析</h2><p>如果允许开新数组，那就太简单了，当然我们要找空间<code>O(1)</code>的解法。把原数组分为两段，分别翻转，然后把数组整体翻转，就得到了结果。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: void Do not return anything, modify nums in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        k = (len(nums) - k) % len(nums)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">        self.reverse(nums, k, len(nums) - <span class="number">1</span>)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, x, y)</span>:</span></span><br><span class="line">        k = (y - x + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            nums[x + i], nums[y - i] = nums[y - i], nums[x + i]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/rotate-array/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Rotate List]]></title>
      <link>http://garfieldog.github.io/2015/08/26/rotate-list/</link>
      <guid>http://garfieldog.github.io/2015/08/26/rotate-list/</guid>
      <pubDate>Wed, 26 Aug 2015 02:20:17 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>G]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
</blockquote>
<h2 id="分析">分析</h2><p>同样看上去不难，但要写对还是不容易。首先要解决找到右手起第k个数，这个有一个精妙的找法，用两个指针，一个先走k步，然后两个一起走，第一个指针到尾部时，第二个指针恰好就在倒数第k个位置。但这道题k有可能比链表长度大，所以用这种方法就没意义了，还是老老实实遍历一遍列表数出个数吧。</p>
<ol>
<li>遍历列表获得总长度，将右手第k转化为左手第<code>(len - k) % len</code>个。</li>
<li>这时候有一个比较巧的做法，就是先把列表首尾连接起来（我们第一次遍历结束时指针恰好在尾部）。</li>
<li>然后让指针继续走<code>(len - k) % len</code>步，这时候就走到了新链表的尾部，断开环，返回新头部。</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        k = (length - k) % length</span><br><span class="line">        <span class="comment"># now cur is the last element</span></span><br><span class="line">        cur.next = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            cur = cur.next</span><br><span class="line">        new_head = cur.next</span><br><span class="line">        cur.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/rotate-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Duplicates From Sorted List]]></title>
      <link>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list/</link>
      <guid>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list/</guid>
      <pubDate>Tue, 25 Aug 2015 11:27:13 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For exa]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们之前做过一道<a href="/2015/08/18/remove-duplicates-from-sorted-array/">Remove Duplicates from Sorted Array</a>，跟这道题解法其实是一样的，只是数据结构换成了链表。注意指针的维护。时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == prev.val:</span><br><span class="line">                prev.next = cur.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                prev = prev.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Duplicates From Sorted List II]]></title>
      <link>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list-2/</link>
      <guid>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list-2/</guid>
      <pubDate>Tue, 25 Aug 2015 11:27:13 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers f]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
</blockquote>
<p>和<a href="/2015/08/25/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List</a>设定基本一样，要求返回值只包括唯一的元素。</p>
<h2 id="分析">分析</h2><p>需要额外判断删除了重复值后剩下的数是本来就唯一呢，还是曾经有重复值。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            dup = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.val == cur.next.val:</span><br><span class="line">                dup = <span class="keyword">True</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># now cur is the either an unique number or the last one the a sequence of duplicates</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dup:</span><br><span class="line">                prev.next = cur</span><br><span class="line">                prev = prev.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        prev.next = cur</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Partition List]]></title>
      <link>http://garfieldog.github.io/2015/08/25/partition-list/</link>
      <guid>http://garfieldog.github.io/2015/08/25/partition-list/</guid>
      <pubDate>Tue, 25 Aug 2015 09:24:18 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
</blockquote>
<h2 id="分析">分析</h2><p>就是快排中的parition，但使用链表数据结构，实现有一些不一样。维护两个链表，一个把小于x的值串起来，一个把大于等于x的值串起来，最后把这两个链表拼接起来就可以。时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        left_dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        right_dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        left_cur = left_dummy</span><br><span class="line">        right_cur = right_dummy</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                left_cur.next = head</span><br><span class="line">                left_cur = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_cur.next = head</span><br><span class="line">                right_cur = head</span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        left_cur.next = right_dummy.next</span><br><span class="line">        right_cur.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> left_dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/partition-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Linked List II]]></title>
      <link>http://garfieldog.github.io/2015/08/25/reverse-linked-list-2/</link>
      <guid>http://garfieldog.github.io/2015/08/25/reverse-linked-list-2/</guid>
      <pubDate>Tue, 25 Aug 2015 07:25:54 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要求部分翻转一个链表。看起来不是很难，但要写对真是非常费力。</p>
<ol>
<li>找到需要翻转的子链表头部的前一个元素<code>new_head</code>（为了防止第一个元素没有前一个元素，可以用一个dummy元素插在原链表头部）</li>
<li>从子链表的第二个元素开始遍历子链表，把当前元素插入到<code>new_head</code>之后，也就是子链表第一个元素之前，并维护好指针指向。</li>
<li>dummy元素之后的链表就是最终结果</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - <span class="number">1</span>):</span><br><span class="line">            prev = prev.next</span><br><span class="line"></span><br><span class="line">        new_head = prev</span><br><span class="line">        prev = new_head.next</span><br><span class="line"></span><br><span class="line">        cur = prev.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m, n):</span><br><span class="line">            prev.next = cur.next</span><br><span class="line">            cur.next = new_head.next</span><br><span class="line">            new_head.next = cur</span><br><span class="line">            cur = prev.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/reverse-linked-list-2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
