<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Wed, 09 Sep 2015 09:29:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Sum Root to Leaf Numbers]]></title>
      <link>http://garfieldog.github.io/2015/09/09/sum-root-to-leaf-numbers/</link>
      <guid>http://garfieldog.github.io/2015/09/09/sum-root-to-leaf-numbers/</guid>
      <pubDate>Wed, 09 Sep 2015 09:09:53 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>For example,</p>
<pre><code><span class="number">1</span>
</code></pre><p>   / \<br>  2   3<br>The root-to-leaf path 1-&gt;2 represents the number 12.<br>The root-to-leaf path 1-&gt;3 represents the number 13.</p>
<p>Return the sum = 12 + 13 = 25.</p>
</blockquote>
<h2 id="分析">分析</h2><p>深度优先遍历，自顶向下传递和值。时间<code>O(n)</code>，空间<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbersR</span><span class="params">(self, root, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s = s * <span class="number">10</span> + root.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.sumNumbersR(root.left, s) + self.sumNumbersR(root.right, s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.sumNumbersR(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/sum-root-to-leaf-numbers/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Maximum Path Sum]]></title>
      <link>http://garfieldog.github.io/2015/09/09/binary-tree-maximum-path-sum/</link>
      <guid>http://garfieldog.github.io/2015/09/09/binary-tree-maximum-path-sum/</guid>
      <pubDate>Wed, 09 Sep 2015 08:36:51 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find the maximum path sum.</p>
<p>The path may start and end at any node in the tree]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find the maximum path sum.</p>
<p>The path may start and end at any node in the tree.</p>
<p>For example:<br>Given the below binary tree,</p>
<pre><code>  <span class="number">1</span>
 / \
<span class="number">2</span>   <span class="number">3</span>
</code></pre><p>Return 6.</p>
</blockquote>
<h2 id="分析">分析</h2><p>题目难度标了<code>Hard</code>，其实并不难，关键是要理解最长路径的构成。用深度优先遍历，对于每一个节点，都去考察<code>以该节点为根，所能构成的最大半条路径</code>，所谓<code>半条路径</code>就是指这条路径上的节点要么都在该节点的左子树，要么都在右子树，没有跨越的情况。这样一来，当前以当前节点为根的最长路径就是把左子树中最长<code>半条路径</code>和右子树的最长<code>半条路径</code>拼起来。</p>
<p>注意节点的值有可能是负数，所以，如果<code>半条路径</code>长是负值，我们就不要它。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    max_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSumR</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        s1 = self.maxPathSumR(root.left)</span><br><span class="line">        s2 = self.maxPathSumR(root.right)</span><br><span class="line">        <span class="comment"># update max_sum</span></span><br><span class="line">        self.max_sum = max(s1 + s2 + root.val, s1 + root.val,</span><br><span class="line">                           s2 + root.val, root.val, self.max_sum)</span><br><span class="line">        <span class="keyword">return</span> max(s1, s2, <span class="number">0</span>) + root.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        self.maxPathSumR(root)</span><br><span class="line">        <span class="keyword">return</span> self.max_sum</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/binary-tree-maximum-path-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Path Sum II]]></title>
      <link>http://garfieldog.github.io/2015/09/09/path-sum-2/</link>
      <guid>http://garfieldog.github.io/2015/09/09/path-sum-2/</guid>
      <pubDate>Wed, 09 Sep 2015 08:00:01 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,<br>              5<br>             / \<br>            4   8<br>           /   / \<br>          11  13  4<br>         /  \    / \<br>        7    2  5   1<br>return<br>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>比<a href="/2015/09/09/path-sum/">Path Sum</a>更进一步，要求把符合要求的路径都记下来。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            ss.append((root, sum, []))</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            cur, n, l = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                <span class="keyword">if</span> n == cur.val:</span><br><span class="line">                    rs.append(l + [cur.val])</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                ss.append((cur.right, n - cur.val, l + [cur.val]))</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                ss.append((cur.left, n - cur.val, l + [cur.val]))</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/path-sum-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Path Sum]]></title>
      <link>http://garfieldog.github.io/2015/09/09/path-sum/</link>
      <guid>http://garfieldog.github.io/2015/09/09/path-sum/</guid>
      <pubDate>Wed, 09 Sep 2015 07:47:07 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,<br>              5<br>             / \<br>            4   8<br>           /   / \<br>          11  13  4<br>         /  \      \<br>        7    2      1<br>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
</blockquote>
<h2 id="分析">分析</h2><p>深度优先遍历可解，时间<code>O(n)</code>，空间<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> root.val == sum</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum - root.val) <span class="keyword">or</span> \</span><br><span class="line">            self.hasPathSum(root.right, sum - root.val)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/path-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Maximum Depth of Binary Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/09/maximum-depth-of-binary-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/09/maximum-depth-of-binary-tree/</guid>
      <pubDate>Wed, 09 Sep 2015 07:37:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the lo]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<h2 id="分析">分析</h2><p>深度优先遍历可解，时间<code>O(n)</code>，空间平均<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        d1 = self.maxDepth(root.left)</span><br><span class="line">        d2 = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(d1, d2) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/maximum-depth-of-binary-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Minimum Depth of Binary Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/09/minimum-depth-of-binary-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/09/minimum-depth-of-binary-tree/</guid>
      <pubDate>Wed, 09 Sep 2015 07:23:08 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the sh]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
</blockquote>
<h2 id="分析">分析</h2><p>广度优先遍历可解，找到第一个叶子节点停止搜索返回高度。时间<code>O(n)</code>，空间<code>O(n)</code>。</p>
<h2 id="解题">解题</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        q = deque()</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            q.append(root)</span><br><span class="line">            q.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    <span class="comment"># leaf node</span></span><br><span class="line">                    <span class="keyword">return</span> depth</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    depth += <span class="number">1</span></span><br><span class="line">                    q.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/minimum-depth-of-binary-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Convert Sorted List to Binary Search Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/09/convert-sorted-list-to-binary-search-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/09/convert-sorted-list-to-binary-search-tree/</guid>
      <pubDate>Wed, 09 Sep 2015 06:57:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/09/09/convert-sorted-array-to-binary-search-tree/">上一题</a>不同的是，这次是链表，不能随机访问，那么自顶向下的分治法就失效了。不过可以稍作改动，就可以实现自底向上的构建，需要维护一个全局变量。时间<code>O(n)</code>，空间平均<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    cur = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBSTR</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = (end - start) / <span class="number">2</span> + start</span><br><span class="line">        left = self.sortedListToBSTR(start, root - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># now `self.cur` is root</span></span><br><span class="line">        node = TreeNode(self.cur.val)</span><br><span class="line">        self.cur = self.cur.next</span><br><span class="line">        right = self.sortedListToBSTR(root + <span class="number">1</span>, end)</span><br><span class="line">        node.left = left</span><br><span class="line">        node.right = right</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        self.cur = head</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> self.sortedListToBSTR(<span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/convert-sorted-list-to-binary-search-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Convert Sorted Array to Binary Search Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/09/convert-sorted-array-to-binary-search-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/09/convert-sorted-array-to-binary-search-tree/</guid>
      <pubDate>Wed, 09 Sep 2015 06:37:40 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</b]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<h2 id="分析">分析</h2><p>递归分治法解很容易，时间<code>O(n)</code>，空间平均<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBSTR</span><span class="params">(self, nums, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = (end - start) / <span class="number">2</span> + start</span><br><span class="line">        node = TreeNode(nums[root])</span><br><span class="line">        node.left = self.sortedArrayToBSTR(nums, start, root - <span class="number">1</span>)</span><br><span class="line">        node.right = self.sortedArrayToBSTR(nums, root + <span class="number">1</span>, end)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.sortedArrayToBSTR(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/convert-sorted-array-to-binary-search-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Validate Binary Search Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/09/validate-binary-search-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/09/validate-binary-search-tree/</guid>
      <pubDate>Wed, 09 Sep 2015 06:20:14 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
</blockquote>
<h2 id="分析">分析</h2><p>检查一个二叉搜索树是不是合法，递归去做，向下传递一个允许的取值范围。时间<code>O(n)</code>，空间平均<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBSTR</span><span class="params">(self, root, low, high)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root.val &gt;= high <span class="keyword">or</span> root.val &lt;= low:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isValidBSTR(root.left, low, root.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isValidBSTR(root.right, root.val, high):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.isValidBSTR(root, float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>))</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/validate-binary-search-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Unique Binary Search Trees II]]></title>
      <link>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees-2/</link>
      <guid>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees-2/</guid>
      <pubDate>Wed, 09 Sep 2015 05:58:37 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For e]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      \<br>     3     2     1      1   3      2<br>    /     /       \                 \<br>   2     1         2                 3</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/09/unique-binary-search-trees/">上一题</a>只需要数数，这一题要求把所有的树都构建出来。思路一样，用递归更直观一些。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTreesR</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">None</span>]</span><br><span class="line"></span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start, end + <span class="number">1</span>):</span><br><span class="line">            lefts = self.generateTreesR(start, i - <span class="number">1</span>)</span><br><span class="line">            rights = self.generateTreesR(i + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> lefts:</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> rights:</span><br><span class="line">                    node = TreeNode(i)</span><br><span class="line">                    node.left = left</span><br><span class="line">                    node.right = right</span><br><span class="line">                    rs.append(node)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[TreeNode]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.generateTreesR(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Unique Binary Search Trees]]></title>
      <link>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees/</link>
      <guid>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees/</guid>
      <pubDate>Wed, 09 Sep 2015 05:35:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For examp]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      \<br>     3     2     1      1   3      2<br>    /     /       \                 \<br>   2     1         2                 3</p>
</blockquote>
<h2 id="分析">分析</h2><p>因为是搜索二叉树，所以一旦选定根节点，那么左子树和右子树含有哪些元素就确定了，那么显然可以变成一个递归的问题。以选定节点为根的搜索二叉树有<code>左子树可能的个数 * 右子树可能的个数</code>。所以给定总元素数<code>n</code>，不同的搜索二叉树个数<code>f(n)</code>就有：</p>
<p>$$ f(n) = \sum_{i=0}^{n - 1} f(i)*f(n - 1 - i) $$</p>
<p>用动态规划解，时间<code>O(n^2)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        arr = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        arr[<span class="number">0</span>] = arr[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">                arr[i] += arr[j] * arr[i - <span class="number">1</span> - j]</span><br><span class="line">        <span class="keyword">return</span> arr[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Construct Binary Tree from Inorder and Postorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <pubDate>Wed, 09 Sep 2015 03:26:42 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assum]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/09/construct-binary-tree-from-preorder-and-inorder/">上一题</a>的姐妹版。如法炮制即可。</p>
<p>PS: 从preorder和postorder是无法重建二叉树的。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTreeR</span><span class="params">(self, inorder, x1, y1, postorder, x2, y2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x1 &gt; y1:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> x2 &gt; y2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        node = TreeNode(postorder[y2])</span><br><span class="line">        root_idx = inorder.index(postorder[y2], x1, y1 + <span class="number">1</span>)</span><br><span class="line">        left_size = root_idx - x1</span><br><span class="line">        node.left = self.buildTreeR(inorder, x1, root_idx - <span class="number">1</span>,</span><br><span class="line">                                    postorder, x2, x2 + left_size - <span class="number">1</span>)</span><br><span class="line">        node.right = self.buildTreeR(inorder, root_idx + <span class="number">1</span>, y1,</span><br><span class="line">                                     postorder, x2 + left_size, y2 - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :type postorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTreeR(inorder, <span class="number">0</span>, len(inorder) - <span class="number">1</span>,</span><br><span class="line">                               postorder, <span class="number">0</span>, len(postorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-inorder-and-postorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Construct Binary Tree from Preorder and Inorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <pubDate>Wed, 09 Sep 2015 02:57:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<h2 id="分析">分析</h2><p>经典题，从前序遍历和中序遍历重建二叉树。前序遍历的第一个节点肯定是root，在中序遍历中查找root，可以把中序遍历分为两部分，root前面的是左子树的中序遍历，后面的是右子树的中序遍历。对应地，也可以确定前序遍历左子树和右子树的分界（通过中序遍历左子树的大小），这样递归可解。</p>
<p>时间<code>O(n)</code>，空间平均<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTreeR</span><span class="params">(self, preorder, x1, y1, inorder, x2, y2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x1 &gt; y1:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> x2 &gt; y2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        node = TreeNode(preorder[x1])</span><br><span class="line">        root_idx = inorder.index(preorder[x1])</span><br><span class="line">        left_size = root_idx - x2</span><br><span class="line">        node.left = self.buildTreeR(preorder, x1 + <span class="number">1</span>, x1 + left_size,</span><br><span class="line">                                    inorder, x2, root_idx - <span class="number">1</span>)</span><br><span class="line">        node.right = self.buildTreeR(preorder, x1 + left_size + <span class="number">1</span>, y1,</span><br><span class="line">                                     inorder, root_idx + <span class="number">1</span>, y2)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type preorder: List[int]</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTreeR(preorder, <span class="number">0</span>, len(preorder) - <span class="number">1</span>,</span><br><span class="line">                               inorder, <span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-preorder-and-inorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Populating Next Right Pointers in Each Node II]]></title>
      <link>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node-2/</link>
      <guid>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node-2/</guid>
      <pubDate>Wed, 09 Sep 2015 02:20:45 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>For example,<br>Given the following binary tree,<br>         1<br>       /  \<br>      2    3<br>     / \    \<br>    4   5    7<br>After calling your function, the tree should look like:<br>         1 -&gt; NULL<br>       /  \<br>      2 -&gt; 3 -&gt; NULL<br>     / \    \<br>    4-&gt; 5 -&gt; 7 -&gt; NULL</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们<a href="/2015/09/09/populating-next-right-pointers-in-each-node/">上一题</a>的解法直接可以用在这一题上。</p>
<h2 id="代码">代码</h2><p>直接看<a href="/2015/09/09/populating-next-right-pointers-in-each-node/">上一题</a>。</p>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Populating Next Right Pointers in Each Node]]></title>
      <link>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node/</link>
      <guid>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node/</guid>
      <pubDate>Wed, 09 Sep 2015 01:46:14 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree</p>
<pre><code><span class="title">struct</span> TreeLinkNode {
  <span class="title"]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree</p>
<pre><code><span class="title">struct</span> TreeLinkNode {
  <span class="title">TreeLinkNode</span> *left;
  <span class="title">TreeLinkNode</span> *right;
  <span class="title">TreeLinkNode</span> *next;
}
</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>For example,<br>Given the following perfect binary tree,<br>         1<br>       /  \<br>      2    3<br>     / \  / \<br>    4  5  6  7<br>After calling your function, the tree should look like:<br>         1 -&gt; NULL<br>       /  \<br>      2 -&gt; 3 -&gt; NULL<br>     / \  / \<br>    4-&gt;5-&gt;6-&gt;7 -&gt; NULL</p>
</blockquote>
<h2 id="分析">分析</h2><p>可以用广度优先遍历，用队列实现。其中用了<a href="/2015/09/07/binary-tree-zigzag-level-order-traversal/">Zigzag Level Traversal</a>中的一个技巧，在队列里加入None来分隔各个level。</p>
<p>但这样空间复杂度是<code>O(n)</code>的，题目里要求<code>O(1)</code>。由于我们的节点多了一个指针，其实可以用这个指针来完成广度优先遍历，不再需要队列。方法是用一层一层遍历，当前层时把下一层节点的<code>next</code>指针设置好。</p>
<h2 id="代码">代码</h2><h3 id="广度优先遍历,_空间O(n)">广度优先遍历, 空间<code>O(n)</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeLinkNode</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        q = deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        q.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    cur.next = q[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    q.append(<span class="keyword">None</span>)  <span class="comment"># level end</span></span><br></pre></td></tr></table></figure>
<h3 id="空间O(1)算法">空间O(1)算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeLinkNode</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># a new level begins</span></span><br><span class="line">            prev = <span class="keyword">None</span>  <span class="comment"># prev node in the same level</span></span><br><span class="line">            next = <span class="keyword">None</span>  <span class="comment"># the first node of next level</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="comment"># once `next` is set, it will not change until next level</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> next:</span><br><span class="line">                    next = cur.left <span class="keyword">if</span> cur.left <span class="keyword">else</span> cur.right</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        prev.next = cur.left</span><br><span class="line">                    prev = cur.left</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        prev.next = cur.right</span><br><span class="line">                    prev = cur.right</span><br><span class="line">                cur = cur.next  <span class="comment"># it is level order traversal!</span></span><br><span class="line">            <span class="comment"># level ends</span></span><br><span class="line">            cur = next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Flatten Binary Tree to Linked List]]></title>
      <link>http://garfieldog.github.io/2015/09/08/flatten-binary-tree-to-linked-list/</link>
      <guid>http://garfieldog.github.io/2015/09/08/flatten-binary-tree-to-linked-list/</guid>
      <pubDate>Tue, 08 Sep 2015 08:13:19 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>  ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>    <span class="number">1</span>
   / \
  <span class="number">2</span>   <span class="number">5</span>
 / \   \
<span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span>
</code></pre><p>The flattened tree should look like:<br>   1<br>    \<br>     2<br>      \<br>       3<br>        \<br>         4<br>          \<br>           5<br>            \<br>             6<br>Hints:<br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题有点莫名其妙，不知道初衷是什么。按照提示，先序遍历，把每个被访问的节点右儿子设为下一个要访问的节点。迭代法用栈实现，时间<code>O(n)</code>，空间<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># preorder traversal</span></span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            ss.append(root)</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            cur = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                ss.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                ss.append(cur.left)</span><br><span class="line">            <span class="comment"># visit cur</span></span><br><span class="line">            cur.left = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> ss:</span><br><span class="line">                cur.right = ss[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/flatten-binary-tree-to-linked-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Balanced Binary Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/08/balanced-binary-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/08/balanced-binary-tree/</guid>
      <pubDate>Tue, 08 Sep 2015 07:08:23 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binar]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
</blockquote>
<h2 id="分析">分析</h2><p>检查二叉树是否平衡，递归法很简单。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalancedR</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">True</span>, <span class="number">0</span>)</span><br><span class="line">        f1, h1 = self.isBalancedR(root.left)</span><br><span class="line">        f2, h2 = self.isBalancedR(root.right)</span><br><span class="line">        f = f1 <span class="keyword">and</span> f2 <span class="keyword">and</span> abs(h1 - h2) &lt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> f, max(h1, h2) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        f, h = self.isBalancedR(root)</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/balanced-binary-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Symmetric Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/08/symmetric-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/08/symmetric-tree/</guid>
      <pubDate>Tue, 08 Sep 2015 02:09:11 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<pre><code><span class="number">1</span>
</code></pre><p>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>But the following is not:<br>    1<br>   / \<br>  2   2<br>   \   \<br>   3    3<br>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
</blockquote>
<h2 id="分析">分析</h2><p>左右对称地遍历二叉树，递归版比较容易。时间<code>O(n)</code>，空间平均<code>O(logn)</code>，最坏<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> root <span class="keyword">or</span> self.isSymmetric2(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric2</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left == right</span><br><span class="line">        <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSymmetric2(left.left, right.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSymmetric2(left.right, right.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        ss = []</span><br><span class="line">        ss.append((root.left, root.right))</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            x, y = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">or</span> <span class="keyword">not</span> y:</span><br><span class="line">                <span class="keyword">if</span> x == y:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> x.val != y.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            ss.append((x.right, y.left))</span><br><span class="line">            ss.append((x.left, y.right))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/symmetric-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Same Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/08/same-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/08/same-tree/</guid>
      <pubDate>Tue, 08 Sep 2015 01:49:41 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are c]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
</blockquote>
<h2 id="分析">分析</h2><p>本质上就是遍历二叉树，递归法很简单，迭代也不难写。时间<code>O(n)</code>，空间平均<code>O(logn)</code>，最坏<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> p == q</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSameTree(p.left, q.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSameTree(p.right, q.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># preorder traversal</span></span><br><span class="line">        ss = []</span><br><span class="line">        ss.append((p, q))</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            x, y = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> x <span class="keyword">or</span> <span class="keyword">not</span> y):</span><br><span class="line">                <span class="keyword">if</span> x == y:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> x.val != y.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            ss.append((x.right, y.right))</span><br><span class="line">            ss.append((x.left, y.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/same-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Recover Binary Search Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/07/recover-binary-search-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/07/recover-binary-search-tree/</guid>
      <pubDate>Mon, 07 Sep 2015 14:17:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:<br>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
</blockquote>
<h2 id="分析">分析</h2><p>可以用中序遍历来做，记录上一个访问的元素，如果发现违反了正序则记录位置，遍历完之后把两个位置元素调换。时间<code>O(n)</code>，空间平均<code>O(logn)</code>，最坏<code>O(n)</code>。</p>
<p>追求空间<code>O(1)</code>的解法可以使用Morris遍历。</p>
<h2 id="代码">代码</h2><h3 id="普通中序遍历">普通中序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># inorder traversal</span></span><br><span class="line">        cur = root</span><br><span class="line">        ss = []</span><br><span class="line">        prev = TreeNode(float(<span class="string">'-inf'</span>))</span><br><span class="line">        first = second = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> ss <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                ss.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = ss.pop()</span><br><span class="line">                <span class="comment"># visit cur</span></span><br><span class="line">                <span class="keyword">if</span> cur.val &lt; prev.val:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                        first = prev</span><br><span class="line">                    second = cur</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.right</span><br><span class="line">        first.val, second.val = second.val, first.val</span><br></pre></td></tr></table></figure>
<h3 id="Morris遍历">Morris遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># inorder traversal</span></span><br><span class="line">        cur = root</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        first = second = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                <span class="comment"># visit cur</span></span><br><span class="line">                <span class="keyword">if</span> prev <span class="keyword">and</span> cur.val &lt; prev.val:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                        first = prev</span><br><span class="line">                    second = cur</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># not threaded yet</span></span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    <span class="comment"># visit cur</span></span><br><span class="line">                    <span class="keyword">if</span> prev <span class="keyword">and</span> cur.val &lt; prev.val:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                            first = prev</span><br><span class="line">                        second = cur</span><br><span class="line">                    prev = cur</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        first.val, second.val = second.val, first.val</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/recover-binary-search-tree/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
