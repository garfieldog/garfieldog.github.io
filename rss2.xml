<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Thu, 27 Aug 2015 16:16:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Reorder List]]></title>
      <link>http://garfieldog.github.io/2015/08/27/reorder-list/</link>
      <guid>http://garfieldog.github.io/2015/08/27/reorder-list/</guid>
      <pubDate>Thu, 27 Aug 2015 15:35:15 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
</blockquote>
<h2 id="分析">分析</h2><p>分四步：</p>
<ol>
<li>遍历链表获得长度</li>
<li>找到链表中点，断开成两个链表</li>
<li>翻转第二个链表</li>
<li>将两个链表合并</li>
</ol>
<p>时间复杂度<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: void Do not return anything, modify head in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        m = (l - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        head2 = cur.next</span><br><span class="line">        cur.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># now we have two lists, reverse the second one</span></span><br><span class="line">        prev = head2</span><br><span class="line">        cur = head2.next</span><br><span class="line">        prev.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            next = cur.next</span><br><span class="line">            cur.next = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = next</span><br><span class="line">        head2 = prev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># then we merge the two lists</span></span><br><span class="line">        <span class="keyword">while</span> head2:</span><br><span class="line">            n1 = head.next</span><br><span class="line">            n2 = head2.next</span><br><span class="line">            head.next = head2</span><br><span class="line">            head2.next = n1</span><br><span class="line">            head = n1</span><br><span class="line">            head2 = n2</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/27/reorder-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Linked List Cycle II]]></title>
      <link>http://garfieldog.github.io/2015/08/27/linked-list-cycle-2/</link>
      <guid>http://garfieldog.github.io/2015/08/27/linked-list-cycle-2/</guid>
      <pubDate>Thu, 27 Aug 2015 14:39:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>No]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p><a href="/2015/08/27/linked-list-cycle/">Linked List Cycle</a>的升级版。要求不仅判断是否有环，而且要找出环开始的位置。</p>
<h2 id="分析">分析</h2><p>对于存在环的情况，设从链表头部到环第一个元素的距离为<code>x</code>，从环第一个元素到两指针相遇点距离为<code>y</code>，环长度为<code>r</code>。这里可以证明的一点是，当两指针相遇时，慢指针肯定没有跑完一圈。这样来证明：当慢指针到达环第一个元素时，快指针肯定在环中某个地方，设距离环第一个元素<code>z</code>，肯定有<code>z &lt; r</code>。而快指针只需要<code>z</code>步就可以追上慢指针，所以慢指针没有机会跑完一圈。</p>
<p>设相遇时已经走了<code>t</code>步，则<code>t = x + y</code>, <code>2t = x + y + nr</code>， 其中<code>n</code>为正整数。则可以推导出<code>t = nr</code>，<code>x = nr - y = (n - 1)r + (r - y)</code>。这样一来，如果我们在两指针相遇后，再用一个指针从链表头开始走，直到它和慢指针相遇，相遇点就是环开始的地方。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        p1 = head.next</span><br><span class="line">        p2 = head.next.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2 <span class="keyword">or</span> <span class="keyword">not</span> p2.next:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p1 == p2:</span><br><span class="line">            p2 = head</span><br><span class="line">            <span class="keyword">while</span> p1 != p2:</span><br><span class="line">                p1 = p1.next</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/27/linked-list-cycle-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Linked List Cycle]]></title>
      <link>http://garfieldog.github.io/2015/08/27/linked-list-cycle/</link>
      <guid>http://garfieldog.github.io/2015/08/27/linked-list-cycle/</guid>
      <pubDate>Thu, 27 Aug 2015 14:25:31 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without usi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<h2 id="分析">分析</h2><p>经典题，使用两指针，一个每次走一步，另一个走两步，如果两指针相遇，则说明有环。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        p1 = head.next</span><br><span class="line">        p2 = head.next.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2 <span class="keyword">or</span> <span class="keyword">not</span> p2.next:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/27/linked-list-cycle/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Copy List with Random Pointer]]></title>
      <link>http://garfieldog.github.io/2015/08/26/copy-list-with-random-pointer/</link>
      <guid>http://garfieldog.github.io/2015/08/26/copy-list-with-random-pointer/</guid>
      <pubDate>Wed, 26 Aug 2015 09:51:07 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题有点技巧，拢共分三步：</p>
<ol>
<li>第一步，给原链表每个节点复制一个拷贝，插入到原节点后面。</li>
<li>第二步，再次遍历链表，给复制出来的节点设置random指针。</li>
<li>第三步，再次遍历链表，把原链表的节点和复制出来的节点拆成两个链表。</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.random = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: RandomListNode</span><br><span class="line">        :rtype: RandomListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            node = RandomListNode(cur.label)</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            cur = node.next</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.random:</span><br><span class="line">                cur.next.random = cur.random.next</span><br><span class="line">            cur = cur.next.next</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        new_head = cur.next</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">            next = cur.next</span><br><span class="line">            cur.next = cur.next.next</span><br><span class="line">            cur = next</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/copy-list-with-random-pointer/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Nodes in k-Group]]></title>
      <link>http://garfieldog.github.io/2015/08/26/reverse-nodes-in-k-group/</link>
      <guid>http://garfieldog.github.io/2015/08/26/reverse-nodes-in-k-group/</guid>
      <pubDate>Wed, 26 Aug 2015 07:00:29 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,<br>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/08/26/swap-nodes-in-pairs/">Swap Nodes in Pairs</a>的升级版。一组一组地翻转，注意指针操作。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, prev, end, k)</span>:</span></span><br><span class="line">        end_next = end.next</span><br><span class="line">        head = prev.next</span><br><span class="line">        p1 = head</span><br><span class="line">        p2 = head.next</span><br><span class="line">        <span class="keyword">while</span> p2 != end_next:</span><br><span class="line">            next = p2.next</span><br><span class="line">            p2.next = p1</span><br><span class="line">            p1 = p2</span><br><span class="line">            p2 = next</span><br><span class="line">        head.next = end_next</span><br><span class="line">        prev.next = p1</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next <span class="keyword">or</span> k &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            end = head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> end:</span><br><span class="line">                    end = end.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> end:  <span class="comment"># not enough k nodes</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            prev = self.reverse(prev, end, k)</span><br><span class="line">            head = prev.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/reverse-nodes-in-k-group/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Swap Nodes In Pairs]]></title>
      <link>http://garfieldog.github.io/2015/08/26/swap-nodes-in-pairs/</link>
      <guid>http://garfieldog.github.io/2015/08/26/swap-nodes-in-pairs/</guid>
      <pubDate>Wed, 26 Aug 2015 06:34:09 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&g]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
</blockquote>
<h2 id="分析">分析</h2><p>遍历链表，隔一个数（分奇偶）把当前数插到它前一个数的前面。时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="实现">实现</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy1 = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy2 = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy1.next = dummy2</span><br><span class="line">        dummy2.next = head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        prev = dummy1</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                next = cur.next</span><br><span class="line">                prev.next.next = cur.next</span><br><span class="line">                cur.next = prev.next</span><br><span class="line">                prev.next = cur</span><br><span class="line">                cur = next</span><br><span class="line">                prev = prev.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                prev = prev.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dummy2.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/swap-nodes-in-pairs/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Nth node From End of List]]></title>
      <link>http://garfieldog.github.io/2015/08/26/remove-nth-node-from-end-of-list/</link>
      <guid>http://garfieldog.github.io/2015/08/26/remove-nth-node-from-end-of-list/</guid>
      <pubDate>Wed, 26 Aug 2015 06:10:04 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,</p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们在<a href="/2015/08/26/rotate-list/">Rotate List</a>中已经讨论过这个方法，用两指针，时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        p1 = p2 = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            p1 = p1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1.next:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line"></span><br><span class="line">        p2.next = p2.next.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/remove-nth-node-from-end-of-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Rotate Array]]></title>
      <link>http://garfieldog.github.io/2015/08/26/rotate-array/</link>
      <guid>http://garfieldog.github.io/2015/08/26/rotate-array/</guid>
      <pubDate>Wed, 26 Aug 2015 03:56:18 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the arra]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
</blockquote>
<h2 id="分析">分析</h2><p>如果允许开新数组，那就太简单了，当然我们要找空间<code>O(1)</code>的解法。把原数组分为两段，分别翻转，然后把数组整体翻转，就得到了结果。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: void Do not return anything, modify nums in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        k = (len(nums) - k) % len(nums)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">        self.reverse(nums, k, len(nums) - <span class="number">1</span>)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, x, y)</span>:</span></span><br><span class="line">        k = (y - x + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            nums[x + i], nums[y - i] = nums[y - i], nums[x + i]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/rotate-array/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Rotate List]]></title>
      <link>http://garfieldog.github.io/2015/08/26/rotate-list/</link>
      <guid>http://garfieldog.github.io/2015/08/26/rotate-list/</guid>
      <pubDate>Wed, 26 Aug 2015 02:20:17 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>G]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
</blockquote>
<h2 id="分析">分析</h2><p>同样看上去不难，但要写对还是不容易。首先要解决找到右手起第k个数，这个有一个精妙的找法，用两个指针，一个先走k步，然后两个一起走，第一个指针到尾部时，第二个指针恰好就在倒数第k个位置。但这道题k有可能比链表长度大，所以用这种方法就没意义了，还是老老实实遍历一遍列表数出个数吧。</p>
<ol>
<li>遍历列表获得总长度，将右手第k转化为左手第<code>(len - k) % len</code>个。</li>
<li>这时候有一个比较巧的做法，就是先把列表首尾连接起来（我们第一次遍历结束时指针恰好在尾部）。</li>
<li>然后让指针继续走<code>(len - k) % len</code>步，这时候就走到了新链表的尾部，断开环，返回新头部。</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        k = (length - k) % length</span><br><span class="line">        <span class="comment"># now cur is the last element</span></span><br><span class="line">        cur.next = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            cur = cur.next</span><br><span class="line">        new_head = cur.next</span><br><span class="line">        cur.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/rotate-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Duplicates From Sorted List II]]></title>
      <link>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list-2/</link>
      <guid>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list-2/</guid>
      <pubDate>Tue, 25 Aug 2015 11:27:13 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers f]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
</blockquote>
<p>和<a href="/2015/08/25/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List</a>设定基本一样，要求返回值只包括唯一的元素。</p>
<h2 id="分析">分析</h2><p>需要额外判断删除了重复值后剩下的数是本来就唯一呢，还是曾经有重复值。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            dup = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.val == cur.next.val:</span><br><span class="line">                dup = <span class="keyword">True</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># now cur is the either an unique number or the last one the a sequence of duplicates</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dup:</span><br><span class="line">                prev.next = cur</span><br><span class="line">                prev = prev.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        prev.next = cur</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Duplicates From Sorted List]]></title>
      <link>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list/</link>
      <guid>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list/</guid>
      <pubDate>Tue, 25 Aug 2015 11:27:13 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For exa]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们之前做过一道<a href="/2015/08/18/remove-duplicates-from-sorted-array/">Remove Duplicates from Sorted Array</a>，跟这道题解法其实是一样的，只是数据结构换成了链表。注意指针的维护。时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == prev.val:</span><br><span class="line">                prev.next = cur.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                prev = prev.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Partition List]]></title>
      <link>http://garfieldog.github.io/2015/08/25/partition-list/</link>
      <guid>http://garfieldog.github.io/2015/08/25/partition-list/</guid>
      <pubDate>Tue, 25 Aug 2015 09:24:18 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
</blockquote>
<h2 id="分析">分析</h2><p>就是快排中的parition，但使用链表数据结构，实现有一些不一样。维护两个链表，一个把小于x的值串起来，一个把大于等于x的值串起来，最后把这两个链表拼接起来就可以。时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        left_dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        right_dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        left_cur = left_dummy</span><br><span class="line">        right_cur = right_dummy</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                left_cur.next = head</span><br><span class="line">                left_cur = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_cur.next = head</span><br><span class="line">                right_cur = head</span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        left_cur.next = right_dummy.next</span><br><span class="line">        right_cur.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> left_dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/partition-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Linked List II]]></title>
      <link>http://garfieldog.github.io/2015/08/25/reverse-linked-list-2/</link>
      <guid>http://garfieldog.github.io/2015/08/25/reverse-linked-list-2/</guid>
      <pubDate>Tue, 25 Aug 2015 07:25:54 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要求部分翻转一个链表。看起来不是很难，但要写对真是非常费力。</p>
<ol>
<li>找到需要翻转的子链表头部的前一个元素<code>new_head</code>（为了防止第一个元素没有前一个元素，可以用一个dummy元素插在原链表头部）</li>
<li>从子链表的第二个元素开始遍历子链表，把当前元素插入到<code>new_head</code>之后，也就是子链表第一个元素之前，并维护好指针指向。</li>
<li>dummy元素之后的链表就是最终结果</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - <span class="number">1</span>):</span><br><span class="line">            prev = prev.next</span><br><span class="line"></span><br><span class="line">        new_head = prev</span><br><span class="line">        prev = new_head.next</span><br><span class="line"></span><br><span class="line">        cur = prev.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m, n):</span><br><span class="line">            prev.next = cur.next</span><br><span class="line">            cur.next = new_head.next</span><br><span class="line">            new_head.next = cur</span><br><span class="line">            cur = prev.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/reverse-linked-list-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Linked List]]></title>
      <link>http://garfieldog.github.io/2015/08/25/reverse-linked-list/</link>
      <guid>http://garfieldog.github.io/2015/08/25/reverse-linked-list/</guid>
      <pubDate>Tue, 25 Aug 2015 07:17:23 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a singly linked list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，翻转单链表。时间<code>O(n)</code>，空间<co]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a singly linked list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，翻转单链表。时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        last = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            next = head.next</span><br><span class="line">            head.next = last</span><br><span class="line">            last = head</span><br><span class="line">            head = next</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/reverse-linked-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Add Two Numbers]]></title>
      <link>http://garfieldog.github.io/2015/08/25/add-two-numbers/</link>
      <guid>http://garfieldog.github.io/2015/08/25/add-two-numbers/</guid>
      <pubDate>Tue, 25 Aug 2015 06:08:06 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse or]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单的链表题，复用已有链表本身的节点，可以实现时间<code>O(n)</code>，空间<code>O(1)</code>的算法。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type l1: ListNode</span><br><span class="line">        :type l2: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        head = l1</span><br><span class="line">        tail = l1</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            tail = l1</span><br><span class="line">            carry, l1.val = divmod(l1.val + l2.val + carry, <span class="number">10</span>)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            tail = l1</span><br><span class="line">            carry, l1.val = divmod(l1.val + carry, <span class="number">10</span>)</span><br><span class="line">            l1 = l1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            tail.next = l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            tail = l2</span><br><span class="line">            carry, l2.val = divmod(l2.val + carry, <span class="number">10</span>)</span><br><span class="line">            l2 = l2.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">            tail.next = ListNode(carry)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/add-two-numbers/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Single Number III]]></title>
      <link>http://garfieldog.github.io/2015/08/25/single-number-3/</link>
      <guid>http://garfieldog.github.io/2015/08/25/single-number-3/</guid>
      <pubDate>Tue, 25 Aug 2015 05:46:34 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/08/25/single-number/">Single Number</a>基本设定一致，区别在于这次有两个出现一次的数，设为<code>x</code>和<code>y</code>。这给我们了一点启发，那我们是不是可以套用[Single Number]的解法呢？是可以的，不过我们给所有数取异或后，剩下的值是 $ z = x \oplus y<br>$，这时候我们要怎么把x和y给分别求出来呢？我们只需要用一个bit位就能够区分出来，任取z的为1的某一位（说明x和y在这一位上不一致），把原数组中这一位是1的数放到一拨，为0的放到一拨，分别取异或，就解出了x和y。</p>
<p>取z的某一位为1的bit位，可以就用<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D" target="_blank" rel="external">LSB</a>，它有一个漂亮的求法<code>n &amp; -n</code>，更多位运算的奇技淫巧看这里：<a href="https://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="external">Bit Twiddling Hacks</a>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        z = reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br><span class="line">        lsb = z &amp; -z</span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &amp; lsb:</span><br><span class="line">                x ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y ^= n</span><br><span class="line">        <span class="keyword">return</span> [x, y]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/single-number-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Single Number II]]></title>
      <link>http://garfieldog.github.io/2015/08/25/single-number-2/</link>
      <guid>http://garfieldog.github.io/2015/08/25/single-number-2/</guid>
      <pubDate>Tue, 25 Aug 2015 03:50:49 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h2 id="分析">分析</h2><p>这次变成了其他数字出现3次，不是偶数次，所以直接使用异或是行不通的，我们可以用一个长度为32（int的位数）的数组来记录每一个位上出现的次数，如果不是3的倍数则提取出来，组成结果的数。这个算法是空间<code>O(1)</code>的，因为数组大小固定是32，有点基排序的意思，但显得不那么优雅。可以用三个变量来代替这32个变量，模拟三进制运算：用<code>ones</code>记录二进制1出现1次（mod 3余1）的位数，<code>twos</code>记录二进制1出现2次（mod 3余2）的位数，出现3次时该位清零。</p>
<h2 id="代码">代码</h2><h3 id="固定大小数组">固定大小数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        s = <span class="number">32</span></span><br><span class="line">        b = [<span class="number">0</span>] * s</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(s):</span><br><span class="line">                f = (<span class="number">1</span> &lt;&lt; i) &amp; x</span><br><span class="line">                <span class="keyword">if</span> f:</span><br><span class="line">                    b[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(s):</span><br><span class="line">            <span class="keyword">if</span> b[i] % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">                ret |= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="keyword">return</span> ret <span class="keyword">if</span> b[-<span class="number">1</span>] % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">else</span> ret - (<span class="number">1</span> &lt;&lt; s)</span><br></pre></td></tr></table></figure>
<h3 id="模拟三进制">模拟三进制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ones, twos, xthrees = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            twos |= (ones &amp; x)  <span class="comment"># 这时候twos里包括了2次或3次的</span></span><br><span class="line">            ones ^= x  <span class="comment"># 这时候ones中包括了出现1次或者3次的</span></span><br><span class="line">            xthrees = ~(ones &amp; twos)  <span class="comment"># xthrees里包括了出现1次或2次的</span></span><br><span class="line">            ones &amp;= xthrees</span><br><span class="line">            twos &amp;= xthrees</span><br><span class="line">        <span class="keyword">return</span> ones</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/single-number-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Single Number]]></title>
      <link>http://garfieldog.github.io/2015/08/25/single-number/</link>
      <guid>http://garfieldog.github.io/2015/08/25/single-number/</guid>
      <pubDate>Tue, 25 Aug 2015 03:32:03 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h2 id="分析">分析</h2><p>空间<code>O(n)</code>的算法很容易想，但是题目要求空间<code>O(1)</code>，这个就有一些奇技淫巧了，想到了就很容易，没想到还真是抓瞎。用<code>xor</code>操作的性质，给一个序列的数使用<code>xor</code>进行reduce，如果一个数出现偶数次，那么就跟没有出现过是一样的，也就是$ x \oplus y \oplus x = y $。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/single-number/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Candy]]></title>
      <link>http://garfieldog.github.io/2015/08/25/candy/</link>
      <guid>http://garfieldog.github.io/2015/08/25/candy/</guid>
      <pubDate>Tue, 25 Aug 2015 02:36:28 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving can]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<p>Each child must have at least one candy.<br>Children with a higher rating get more candies than their neighbors.<br>What is the minimum candies you must give?</p>
</blockquote>
<h2 id="分析">分析</h2><p>有一定难度。对于某个位置<code>i</code>上的小孩，它的糖果数取决于他自己和左右邻居的关系。设<code>ratings</code>数组为<code>R</code>，分配给小孩的糖果数为数组<code>C</code>。我们可以这样来考虑这个问题，拆分为两个步骤：</p>
<ol>
<li>首先，如果只要求<code>C[i] &gt; C[i-1]</code> iff <code>R[i] &gt; R[i-1]</code>，也就是说只考虑每个小孩左手边的小孩，那么如果<code>R[i] &gt; R[i-1]</code>则<code>C[i] = C[i-1] + 1</code>，否则<code>C[i] = 1</code>。</li>
<li>然后我们再考虑加上右手边小孩的限制，如果<code>R[i] &gt; R[i+1]</code>，则<code>C[i] = max(C[i+1] + 1, C[i])</code>。</li>
</ol>
<p>这样一来，考虑到上面被分解的两个问题内部的互相依赖情况，我们就可以用两个循环分别从左到右、从右到左遍历数组，得到时间<code>O(n)</code>，空间<code>O(n)</code>的算法。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span><span class="params">(self, R)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type R: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(R)</span><br><span class="line">        C = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> R[i] &gt; R[i - <span class="number">1</span>]:</span><br><span class="line">                C[i] = C[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> R[i] &gt; R[i + <span class="number">1</span>]:</span><br><span class="line">                C[i] = max(C[i + <span class="number">1</span>] + <span class="number">1</span>, C[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(C)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/candy/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Gas Station]]></title>
      <link>http://garfieldog.github.io/2015/08/24/gas-station/</link>
      <guid>http://garfieldog.github.io/2015/08/24/gas-station/</guid>
      <pubDate>Mon, 24 Aug 2015 10:18:32 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>Y]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p>Note:<br>The solution is guaranteed to be unique.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题等价于，对每个加油站，油的存量和到下一个加油站的消耗之差<code>diff[i] = gas[i] -cost[i]</code>这样一个循环数组，找到一个下标<code>x</code>，使得从<code>x</code>开始<code>diff[i]</code>的累加和永远非负。想到一个<code>O(n^2)</code>时间的算法很容易，但我们应该找到更好的。</p>
<p>首先，有一个很重要的结论，如果 $\sum_{i=0}^{N-1} gas[i] - cost[i] &gt;= 0 $，则肯定有解。如果小于0，则一定无解。这个结论如何证明需要仔细想一想。然后，如何找到这个下标呢？这个问题其实满足贪心法的最优子结构：</p>
<ol>
<li>从第0个加油站开始，寻找第一个使得<code>sum(diff[i]) &lt; 0</code>的下标，如果找不到，则说明，第一个加油站就满足条件。</li>
<li>找到这样的下标<code>i</code>，则说明<code>0..i</code>之间的加油站肯定不满足条件。可能的解只会在<code>i+1 ... N-1</code>之间。</li>
<li>将<code>sum</code>清零，从<code>i+1</code>开始继续搜索diff累加和为负的下标<code>j</code>，找到则说明<code>i+1 ... j</code>之间的加油站都不符合条件。以此类推。</li>
<li>最后判断全体的diff和是否非负，如果是，则按照之前的结论，肯定有解，这个解就是我们上面搜索过程中最后一个累加起始位置。</li>
</ol>
<p>时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type gas: List[int]</span><br><span class="line">        :type cost: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        cur_sum, total_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            diff = gas[i] - cost[i]</span><br><span class="line">            cur_sum += diff</span><br><span class="line">            total_sum += diff</span><br><span class="line">            <span class="keyword">if</span> cur_sum &lt; <span class="number">0</span>:</span><br><span class="line">                cur_sum = <span class="number">0</span></span><br><span class="line">                x = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> total_sum &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/24/gas-station/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
