<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Tue, 08 Sep 2015 09:39:18 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Flatten Binary Tree to Linked List]]></title>
      <link>http://garfieldog.github.io/2015/09/08/flatten-binary-tree-to-linked-list/</link>
      <guid>http://garfieldog.github.io/2015/09/08/flatten-binary-tree-to-linked-list/</guid>
      <pubDate>Tue, 08 Sep 2015 08:13:19 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>  ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>    <span class="number">1</span>
   / \
  <span class="number">2</span>   <span class="number">5</span>
 / \   \
<span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span>
</code></pre><p>The flattened tree should look like:<br>   1<br>    \<br>     2<br>      \<br>       3<br>        \<br>         4<br>          \<br>           5<br>            \<br>             6<br>Hints:<br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题有点莫名其妙，不知道初衷是什么。按照提示，先序遍历，把每个被访问的节点右儿子设为下一个要访问的节点。迭代法用栈实现，时间<code>O(n)</code>，空间<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># preorder traversal</span></span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            ss.append(root)</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            cur = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                ss.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                ss.append(cur.left)</span><br><span class="line">            <span class="comment"># visit cur</span></span><br><span class="line">            cur.left = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> ss:</span><br><span class="line">                cur.right = ss[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/flatten-binary-tree-to-linked-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Balanced Binary Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/08/balanced-binary-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/08/balanced-binary-tree/</guid>
      <pubDate>Tue, 08 Sep 2015 07:08:23 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binar]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
</blockquote>
<h2 id="分析">分析</h2><p>检查二叉树是否平衡，递归法很简单。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalancedR</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">True</span>, <span class="number">0</span>)</span><br><span class="line">        f1, h1 = self.isBalancedR(root.left)</span><br><span class="line">        f2, h2 = self.isBalancedR(root.right)</span><br><span class="line">        f = f1 <span class="keyword">and</span> f2 <span class="keyword">and</span> abs(h1 - h2) &lt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> f, max(h1, h2) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        f, h = self.isBalancedR(root)</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/balanced-binary-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Symmetric Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/08/symmetric-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/08/symmetric-tree/</guid>
      <pubDate>Tue, 08 Sep 2015 02:09:11 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<pre><code><span class="number">1</span>
</code></pre><p>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>But the following is not:<br>    1<br>   / \<br>  2   2<br>   \   \<br>   3    3<br>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
</blockquote>
<h2 id="分析">分析</h2><p>左右对称地遍历二叉树，递归版比较容易。时间<code>O(n)</code>，空间平均<code>O(logn)</code>，最坏<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> root <span class="keyword">or</span> self.isSymmetric2(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric2</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left == right</span><br><span class="line">        <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSymmetric2(left.left, right.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSymmetric2(left.right, right.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        ss = []</span><br><span class="line">        ss.append((root.left, root.right))</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            x, y = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">or</span> <span class="keyword">not</span> y:</span><br><span class="line">                <span class="keyword">if</span> x == y:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> x.val != y.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            ss.append((x.right, y.left))</span><br><span class="line">            ss.append((x.left, y.right))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/symmetric-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Same Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/08/same-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/08/same-tree/</guid>
      <pubDate>Tue, 08 Sep 2015 01:49:41 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are c]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
</blockquote>
<h2 id="分析">分析</h2><p>本质上就是遍历二叉树，递归法很简单，迭代也不难写。时间<code>O(n)</code>，空间平均<code>O(logn)</code>，最坏<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> p == q</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSameTree(p.left, q.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSameTree(p.right, q.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># preorder traversal</span></span><br><span class="line">        ss = []</span><br><span class="line">        ss.append((p, q))</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            x, y = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> x <span class="keyword">or</span> <span class="keyword">not</span> y):</span><br><span class="line">                <span class="keyword">if</span> x == y:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> x.val != y.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            ss.append((x.right, y.right))</span><br><span class="line">            ss.append((x.left, y.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/same-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Recover Binary Search Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/07/recover-binary-search-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/07/recover-binary-search-tree/</guid>
      <pubDate>Mon, 07 Sep 2015 14:17:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:<br>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
</blockquote>
<h2 id="分析">分析</h2><p>可以用中序遍历来做，记录上一个访问的元素，如果发现违反了正序则记录位置，遍历完之后把两个位置元素调换。时间<code>O(n)</code>，空间平均<code>O(logn)</code>，最坏<code>O(n)</code>。</p>
<p>追求空间<code>O(1)</code>的解法可以使用Morris遍历。</p>
<h2 id="代码">代码</h2><h3 id="普通中序遍历">普通中序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># inorder traversal</span></span><br><span class="line">        cur = root</span><br><span class="line">        ss = []</span><br><span class="line">        prev = TreeNode(float(<span class="string">'-inf'</span>))</span><br><span class="line">        first = second = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> ss <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                ss.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = ss.pop()</span><br><span class="line">                <span class="comment"># visit cur</span></span><br><span class="line">                <span class="keyword">if</span> cur.val &lt; prev.val:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                        first = prev</span><br><span class="line">                    second = cur</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.right</span><br><span class="line">        first.val, second.val = second.val, first.val</span><br></pre></td></tr></table></figure>
<h3 id="Morris遍历">Morris遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># inorder traversal</span></span><br><span class="line">        cur = root</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        first = second = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                <span class="comment"># visit cur</span></span><br><span class="line">                <span class="keyword">if</span> prev <span class="keyword">and</span> cur.val &lt; prev.val:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                        first = prev</span><br><span class="line">                    second = cur</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># not threaded yet</span></span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    <span class="comment"># visit cur</span></span><br><span class="line">                    <span class="keyword">if</span> prev <span class="keyword">and</span> cur.val &lt; prev.val:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                            first = prev</span><br><span class="line">                        second = cur</span><br><span class="line">                    prev = cur</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        first.val, second.val = second.val, first.val</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/recover-binary-search-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Zigzag Level Order Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-zigzag-level-order-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-zigzag-level-order-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 11:59:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to righ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its zigzag level order traversal as:<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/07/binary-tree-level-order-traversal/">Level Order Traveral</a>的姐妹版，要求每一层从左到右、从右到左花插着来。</p>
<p>用一个flag来标识当前level是从左到右还是从右到左，另外在queue中插入行间标示符（这里用<code>None</code>）来分割各行。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        level = []</span><br><span class="line">        rs = []</span><br><span class="line">        zig = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        queue.append(<span class="keyword">None</span>)  <span class="comment"># None as level seperator</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># level end</span></span><br><span class="line">                <span class="keyword">if</span> zig:</span><br><span class="line">                    rs.append(level)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rs.append(level[::-<span class="number">1</span>])</span><br><span class="line">                level = []</span><br><span class="line">                zig = <span class="keyword">not</span> zig</span><br><span class="line">                <span class="keyword">if</span> queue:</span><br><span class="line">                    queue.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-zigzag-level-order-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Level Order Traversal II]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal-2/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal-2/</guid>
      <pubDate>Mon, 07 Sep 2015 11:49:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to r]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its bottom-up level order traversal as:<br>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/07/binary-tree-level-order-traversal/">Level Order Traveral</a>的姐妹版，要求最底层的先输出。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue.append((root, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur, idx = queue.popleft()</span><br><span class="line">            d.setdefault(idx, []).append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append((cur.left, idx + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append((cur.right, idx + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> [v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(d.items(), key=<span class="keyword">lambda</span> x: -x[<span class="number">0</span>])]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Level Order Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 11:34:45 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, leve]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>广度优先遍历，用队列实现。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, OrderedDict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        d = OrderedDict()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue.append((root, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur, idx = queue.popleft()</span><br><span class="line">            d.setdefault(idx, []).append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append((cur.left, idx + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append((cur.right, idx + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Postorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-postorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-postorder-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 08:07:48 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given bi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [3,2,1].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<h2 id="分析">分析</h2><p>后序遍历是三种遍历中最难的一种，迭代版需要一个额外的指针记录上一个访问过的节点，只有当一个节点左子树和右子树都遍历过后才能访问当前节点，左子树依靠栈来保证（跟中序遍历一样），右子树需要靠prev节点来判断是否访问过。</p>
<p>Morris遍历也要更复杂一些，看<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversalR</span><span class="params">(self, root, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorderTraversalR(root.left, rs)</span><br><span class="line">        self.postorderTraversalR(root.right, rs)</span><br><span class="line">        rs.append(root.val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        self.postorderTraversalR(root, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        cur = root</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                ss.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            prev = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">while</span> ss:</span><br><span class="line">                cur = ss.pop()</span><br><span class="line">                <span class="keyword">if</span> cur.right == prev:</span><br><span class="line">                    rs.append(cur.val)</span><br><span class="line">                    prev = cur</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ss.append(cur)</span><br><span class="line">                    cur = cur.right</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="Morris">Morris</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        dummy = TreeNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.left = root</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># look up predecessor in left sub-tree</span></span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># make threaded</span></span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    <span class="comment"># visit left node to predecessor</span></span><br><span class="line">                    tmp = node</span><br><span class="line">                    self.reverse(cur.left, node)</span><br><span class="line">                    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                        rs.append(tmp.val)</span><br><span class="line">                        <span class="keyword">if</span> tmp == cur.left:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        tmp = tmp.right</span><br><span class="line">                    self.reverse(node, cur.left)</span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> a == b:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = a</span><br><span class="line">        y = a.right</span><br><span class="line">        <span class="keyword">while</span> x != b:</span><br><span class="line">            z = y.right</span><br><span class="line">            y.right = x</span><br><span class="line">            x = y</span><br><span class="line">            y = z</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-postorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Inorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-inorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-inorder-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 07:32:04 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given bina]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [1,3,2].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<h2 id="分析">分析</h2><p>中序遍历，基本上沿用<a href="/2015/09/07/binary-tree-preorder-traversal/">上一题</a>的框架。</p>
<p>Morris遍历继续参考<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversalR</span><span class="params">(self, root, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorderTraversalR(root.left, rs)</span><br><span class="line">        rs.append(root.val)</span><br><span class="line">        self.inorderTraversalR(root.right, rs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        self.inorderTraversalR(root, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> ss:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                ss.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = ss.pop()</span><br><span class="line">                rs.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="Morris">Morris</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                rs.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># look up predecessor in left sub-tree</span></span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># make threaded</span></span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    rs.append(cur.val)</span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-inorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Preorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-preorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-preorder-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 07:00:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given bin]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [1,2,3].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，二叉树的先序遍历。当使用迭代方法时，注意入栈的顺序，需要先push右节点，再push左节点。</p>
<p>还有一种不常用的方法<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">Morris遍历</a>，可以做到空间<code>O(1)</code>，时间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversalR</span><span class="params">(self, root, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        rs.append(root.val)</span><br><span class="line">        self.preorderTraversalR(root.left, rs)</span><br><span class="line">        self.preorderTraversalR(root.right, rs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        self.preorderTraversalR(root, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            ss.append(root)</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            cur = ss.pop()</span><br><span class="line">            rs.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                ss.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                ss.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="Morris">Morris</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                rs.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># look up predecessor in left sub-tree</span></span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># make threaded</span></span><br><span class="line">                    rs.append(cur.val)</span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-preorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Evaluate Reverse Polish Notation]]></title>
      <link>http://garfieldog.github.io/2015/09/07/evaluate-reverse-polish-notation/</link>
      <guid>http://garfieldog.github.io/2015/09/07/evaluate-reverse-polish-notation/</guid>
      <pubDate>Mon, 07 Sep 2015 06:37:01 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:<br>  [“2”, “1”, “+”, “3”, “*“] -&gt; ((2 + 1) * 3) -&gt; 9<br>  [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6</p>
</blockquote>
<h2 id="分析">分析</h2><p>逆波兰式求值，比较简单，注意代码里除法<code>int(float(a) / b))</code>是因为Python 2有一个奇葩的设置就是除法结果是负数的时候是向下取整的（我们需要向0取整）。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self, op, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">return</span> a + b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> a - b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> a * b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> int(float(a) / b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type tokens: List[str]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">                b = ss.pop()</span><br><span class="line">                a = ss.pop()</span><br><span class="line">                ss.append(self.eval(t, a, b))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss.append(int(t))</span><br><span class="line">        <span class="keyword">return</span> ss[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/evaluate-reverse-polish-notation/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Largest Rectangle in Histogram]]></title>
      <link>http://garfieldog.github.io/2015/09/07/largest-rectangle-in-histogram/</link>
      <guid>http://garfieldog.github.io/2015/09/07/largest-rectangle-in-histogram/</guid>
      <pubDate>Mon, 07 Sep 2015 05:15:40 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, f]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="/images/histogram.png" alt="histogram"><br>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p><img src="/images/histogram_area.png" alt="histogram-area"><br>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>For example,<br>Given height = [2,1,5,6,2,3],<br>return 10.</p>
</blockquote>
<h2 id="分析">分析</h2><p>时间<code>O(n^2)</code>的算法很容易想，每个位置上向两边扩散就可以。不过还可以更好：利用一个栈，栈内维护递增的序列，遇到破坏递增的元素就持续出栈（这时栈顶元素能围成多大的矩形已经可以计算），直到当前元素大于栈顶，继续入栈。详细分析可参考<a href="http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html" target="_blank" rel="external">这篇文章</a>。</p>
<p>注意<code>if not ss or height[i] &gt; height[ss[-1]]:</code> 中的判断<code>&gt;</code>还是<code>&gt;=</code>不影响正确性，想想为什么。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ss = []</span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        height.append(<span class="number">0</span>)</span><br><span class="line">        n = len(height)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss <span class="keyword">or</span> height[i] &gt; height[ss[-<span class="number">1</span>]]:</span><br><span class="line">                ss.append(i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx = ss.pop()</span><br><span class="line">                w = i <span class="keyword">if</span> <span class="keyword">not</span> ss <span class="keyword">else</span> i - <span class="number">1</span> - ss[-<span class="number">1</span>]</span><br><span class="line">                max_area = max(max_area, height[idx] * w)</span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/largest-rectangle-in-histogram/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Longest Valid Parentheses]]></title>
      <link>http://garfieldog.github.io/2015/09/06/longest-valid-parentheses/</link>
      <guid>http://garfieldog.github.io/2015/09/06/longest-valid-parentheses/</guid>
      <pubDate>Sun, 06 Sep 2015 11:33:29 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-for]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<h2 id="分析">分析</h2><p>稍有难度，使用栈，时间<code>O(n)</code>，空间<code>O(n)</code>。</p>
</blockquote>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ss = []</span><br><span class="line">        n = len(s)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        last = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                ss.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                last = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                    max_len = max(max_len, i - last)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    max_len = max(max_len, i - ss[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/longest-valid-parentheses/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Valid Parentheses]]></title>
      <link>http://garfieldog.github.io/2015/09/06/valid-parentheses/</link>
      <guid>http://garfieldog.github.io/2015/09/06/valid-parentheses/</guid>
      <pubDate>Sun, 06 Sep 2015 11:23:59 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input str]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单的Stack题，时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        d = &#123;</span><br><span class="line">            <span class="string">')'</span>: <span class="string">'('</span>,</span><br><span class="line">            <span class="string">'&#125;'</span>: <span class="string">'&#123;'</span>,</span><br><span class="line">            <span class="string">']'</span>: <span class="string">'['</span></span><br><span class="line">        &#125;</span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'(&#123;['</span>:</span><br><span class="line">                ss.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">')&#125;]'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ss <span class="keyword">or</span> d[c] != ss[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                ss.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> ss</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/valid-parentheses/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Length of Last Word]]></title>
      <link>http://garfieldog.github.io/2015/09/06/length-of-last-word/</link>
      <guid>http://garfieldog.github.io/2015/09/06/length-of-last-word/</guid>
      <pubDate>Sun, 06 Sep 2015 09:42:05 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br>Given s = “Hello World”,<br>return 5.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，时间<code>O(n)</code>, 空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="One_Line_Solver">One Line Solver</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(s.rstrip().split(<span class="string">' '</span>)[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        last_space = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">' '</span>:</span><br><span class="line">                last_space = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            n = <span class="number">1</span> <span class="keyword">if</span> last_space <span class="keyword">else</span> n + <span class="number">1</span></span><br><span class="line">            last_space = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/length-of-last-word/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Simplify Path]]></title>
      <link>http://garfieldog.github.io/2015/09/06/simplify-path/</link>
      <guid>http://garfieldog.github.io/2015/09/06/simplify-path/</guid>
      <pubDate>Sun, 06 Sep 2015 09:25:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”</p>
<p>Corner Cases:<br>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.<br>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.<br>In this case, you should ignore redundant slashes and return “/home/foo”.</p>
</blockquote>
<h2 id="分析">分析</h2><p>比较简单，用stack，注意corner cases。时间<code>O(n)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type path: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        ps = path.split(<span class="string">'/'</span>)</span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">            <span class="keyword">if</span> p == <span class="string">'.'</span> <span class="keyword">or</span> p == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> p == <span class="string">'..'</span>:</span><br><span class="line">                <span class="keyword">if</span> len(ss) &gt; <span class="number">0</span>:</span><br><span class="line">                    ss.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss.append(p)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(ss)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/simplify-path/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Group Anagrams]]></title>
      <link>http://garfieldog.github.io/2015/09/06/group-anagrams/</link>
      <guid>http://garfieldog.github.io/2015/09/06/group-anagrams/</guid>
      <pubDate>Sun, 06 Sep 2015 08:30:58 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>
<p>[<br>  [“ate”, “eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note:<br>For the return value, each inner list’s elements must follow the lexicographic order.<br>All inputs will be in lower-case.</p>
</blockquote>
<h2 id="分析">分析</h2><p>用哈希表，理论上可以时间<code>O(nlogn)</code>，空间<code>O(n)</code>。我们下面的实现由于用了数组而不是链表，所以要慢一些，最坏情况<code>O(n^2)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            key = <span class="string">''</span>.join(sorted(s))</span><br><span class="line">            d.setdefault(key, [])</span><br><span class="line">            rs = d[key]</span><br><span class="line">            idx = bisect(rs, s)</span><br><span class="line">            rs.insert(idx, s)</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/group-anagrams/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Count and Say]]></title>
      <link>http://garfieldog.github.io/2015/09/06/count-and-say/</link>
      <guid>http://garfieldog.github.io/2015/09/06/count-and-say/</guid>
      <pubDate>Sun, 06 Sep 2015 08:08:10 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The count-and-say sequence is the sequence of integers beginning as follows:<br>1, 11, 21, 1211, 111221, ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The count-and-say sequence is the sequence of integers beginning as follows:<br>1, 11, 21, 1211, 111221, …</p>
<p>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.<br>Given an integer n, generate the nth sequence.</p>
<p>Note: The sequence of integers will be represented as a string.</p>
</blockquote>
<h2 id="分析">分析</h2><p>暴力法模拟可解，时间复杂度<code>O(n^2)</code>，空间<code>O(n)</code>，实现不难。更好的方法没有想到。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        s = [<span class="string">'1'</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>):</span><br><span class="line">            rs = []</span><br><span class="line">            last = <span class="keyword">None</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> last <span class="keyword">or</span> c == last:</span><br><span class="line">                    last = c</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rs.append(str(count))</span><br><span class="line">                    rs.append(last)</span><br><span class="line">                    last = c</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">            rs.append(str(count))</span><br><span class="line">            rs.append(c)</span><br><span class="line">            s = rs</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/count-and-say/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Roman to Integer]]></title>
      <link>http://garfieldog.github.io/2015/09/06/roman-to-integer/</link>
      <guid>http://garfieldog.github.io/2015/09/06/roman-to-integer/</guid>
      <pubDate>Sun, 06 Sep 2015 07:45:37 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999</p>
</blockquote>
<h2 id="分析">分析</h2><p>比<a href="/2015/09/06/integer-to-roman/">Integer to Roman</a>简单多了，是加法规则还是减法规则很好判断。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        d = &#123;</span><br><span class="line">            <span class="string">'M'</span>: <span class="number">1000</span>,</span><br><span class="line">            <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">'I'</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = len(s)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            a = d[s[i]]</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> a &lt; d[s[i + <span class="number">1</span>]]:</span><br><span class="line">                a = -a</span><br><span class="line">            r += a</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/roman-to-integer/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
