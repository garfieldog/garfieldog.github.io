<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Wed, 09 Sep 2015 06:17:04 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Unique Binary Search Trees II]]></title>
      <link>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees-2/</link>
      <guid>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees-2/</guid>
      <pubDate>Wed, 09 Sep 2015 05:58:37 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For e]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p>
<p>For example,<br>Given n = 3, your program should return all 5 unique BST’s shown below.</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      \<br>     3     2     1      1   3      2<br>    /     /       \                 \<br>   2     1         2                 3</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/09/unique-binary-search-trees/">上一题</a>只需要数数，这一题要求把所有的树都构建出来。思路一样，用递归更直观一些。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTreesR</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">None</span>]</span><br><span class="line"></span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start, end + <span class="number">1</span>):</span><br><span class="line">            lefts = self.generateTreesR(start, i - <span class="number">1</span>)</span><br><span class="line">            rights = self.generateTreesR(i + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> lefts:</span><br><span class="line">                <span class="keyword">for</span> right <span class="keyword">in</span> rights:</span><br><span class="line">                    node = TreeNode(i)</span><br><span class="line">                    node.left = left</span><br><span class="line">                    node.right = right</span><br><span class="line">                    rs.append(node)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[TreeNode]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.generateTreesR(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Unique Binary Search Trees]]></title>
      <link>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees/</link>
      <guid>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees/</guid>
      <pubDate>Wed, 09 Sep 2015 05:35:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For examp]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p>
<p>For example,<br>Given n = 3, there are a total of 5 unique BST’s.</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      \<br>     3     2     1      1   3      2<br>    /     /       \                 \<br>   2     1         2                 3</p>
</blockquote>
<h2 id="分析">分析</h2><p>因为是搜索二叉树，所以一旦选定根节点，那么左子树和右子树含有哪些元素就确定了，那么显然可以变成一个递归的问题。以选定节点为根的搜索二叉树有<code>左子树可能的个数 * 右子树可能的个数</code>。所以给定总元素数<code>n</code>，不同的搜索二叉树个数<code>f(n)</code>就有：</p>
<p>$$ f(n) = \sum_{i=0}^{n - 1} f(i)*f(n - 1 - i) $$</p>
<p>用动态规划解，时间<code>O(n^2)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        arr = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        arr[<span class="number">0</span>] = arr[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">                arr[i] += arr[j] * arr[i - <span class="number">1</span> - j]</span><br><span class="line">        <span class="keyword">return</span> arr[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/unique-binary-search-trees/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Construct Binary Tree from Inorder and Postorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <pubDate>Wed, 09 Sep 2015 03:26:42 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assum]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/09/construct-binary-tree-from-preorder-and-inorder/">上一题</a>的姐妹版。如法炮制即可。</p>
<p>PS: 从preorder和postorder是无法重建二叉树的。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTreeR</span><span class="params">(self, inorder, x1, y1, postorder, x2, y2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x1 &gt; y1:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> x2 &gt; y2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        node = TreeNode(postorder[y2])</span><br><span class="line">        root_idx = inorder.index(postorder[y2], x1, y1 + <span class="number">1</span>)</span><br><span class="line">        left_size = root_idx - x1</span><br><span class="line">        node.left = self.buildTreeR(inorder, x1, root_idx - <span class="number">1</span>,</span><br><span class="line">                                    postorder, x2, x2 + left_size - <span class="number">1</span>)</span><br><span class="line">        node.right = self.buildTreeR(inorder, root_idx + <span class="number">1</span>, y1,</span><br><span class="line">                                     postorder, x2 + left_size, y2 - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :type postorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTreeR(inorder, <span class="number">0</span>, len(inorder) - <span class="number">1</span>,</span><br><span class="line">                               postorder, <span class="number">0</span>, len(postorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-inorder-and-postorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Construct Binary Tree from Preorder and Inorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <pubDate>Wed, 09 Sep 2015 02:57:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p>Note:<br>You may assume that duplicates do not exist in the tree.</p>
</blockquote>
<h2 id="分析">分析</h2><p>经典题，从前序遍历和中序遍历重建二叉树。前序遍历的第一个节点肯定是root，在中序遍历中查找root，可以把中序遍历分为两部分，root前面的是左子树的中序遍历，后面的是右子树的中序遍历。对应地，也可以确定前序遍历左子树和右子树的分界（通过中序遍历左子树的大小），这样递归可解。</p>
<p>时间<code>O(n)</code>，空间平均<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTreeR</span><span class="params">(self, preorder, x1, y1, inorder, x2, y2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x1 &gt; y1:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> x2 &gt; y2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        node = TreeNode(preorder[x1])</span><br><span class="line">        root_idx = inorder.index(preorder[x1])</span><br><span class="line">        left_size = root_idx - x2</span><br><span class="line">        node.left = self.buildTreeR(preorder, x1 + <span class="number">1</span>, x1 + left_size,</span><br><span class="line">                                    inorder, x2, root_idx - <span class="number">1</span>)</span><br><span class="line">        node.right = self.buildTreeR(preorder, x1 + left_size + <span class="number">1</span>, y1,</span><br><span class="line">                                     inorder, root_idx + <span class="number">1</span>, y2)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type preorder: List[int]</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTreeR(preorder, <span class="number">0</span>, len(preorder) - <span class="number">1</span>,</span><br><span class="line">                               inorder, <span class="number">0</span>, len(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/construct-binary-tree-from-preorder-and-inorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Populating Next Right Pointers in Each Node II]]></title>
      <link>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node-2/</link>
      <guid>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node-2/</guid>
      <pubDate>Wed, 09 Sep 2015 02:20:45 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for problem “Populating Next Right Pointers in Each Node”.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>For example,<br>Given the following binary tree,<br>         1<br>       /  \<br>      2    3<br>     / \    \<br>    4   5    7<br>After calling your function, the tree should look like:<br>         1 -&gt; NULL<br>       /  \<br>      2 -&gt; 3 -&gt; NULL<br>     / \    \<br>    4-&gt; 5 -&gt; 7 -&gt; NULL</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们<a href="/2015/09/09/populating-next-right-pointers-in-each-node/">上一题</a>的解法直接可以用在这一题上。</p>
<h2 id="代码">代码</h2><p>直接看<a href="/2015/09/09/populating-next-right-pointers-in-each-node/">上一题</a>。</p>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Populating Next Right Pointers in Each Node]]></title>
      <link>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node/</link>
      <guid>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node/</guid>
      <pubDate>Wed, 09 Sep 2015 01:46:14 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree</p>
<pre><code><span class="title">struct</span> TreeLinkNode {
  <span class="title"]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree</p>
<pre><code><span class="title">struct</span> TreeLinkNode {
  <span class="title">TreeLinkNode</span> *left;
  <span class="title">TreeLinkNode</span> *right;
  <span class="title">TreeLinkNode</span> *next;
}
</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Note:</p>
<p>You may only use constant extra space.<br>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).<br>For example,<br>Given the following perfect binary tree,<br>         1<br>       /  \<br>      2    3<br>     / \  / \<br>    4  5  6  7<br>After calling your function, the tree should look like:<br>         1 -&gt; NULL<br>       /  \<br>      2 -&gt; 3 -&gt; NULL<br>     / \  / \<br>    4-&gt;5-&gt;6-&gt;7 -&gt; NULL</p>
</blockquote>
<h2 id="分析">分析</h2><p>可以用广度优先遍历，用队列实现。其中用了<a href="/2015/09/07/binary-tree-zigzag-level-order-traversal/">Zigzag Level Traversal</a>中的一个技巧，在队列里加入None来分隔各个level。</p>
<p>但这样空间复杂度是<code>O(n)</code>的，题目里要求<code>O(1)</code>。由于我们的节点多了一个指针，其实可以用这个指针来完成广度优先遍历，不再需要队列。方法是用一层一层遍历，当前层时把下一层节点的<code>next</code>指针设置好。</p>
<h2 id="代码">代码</h2><h3 id="广度优先遍历,_空间O(n)">广度优先遍历, 空间<code>O(n)</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeLinkNode</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        q = deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        q.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    cur.next = q[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    q.append(<span class="keyword">None</span>)  <span class="comment"># level end</span></span><br></pre></td></tr></table></figure>
<h3 id="空间O(1)算法">空间O(1)算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeLinkNode</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># a new level begins</span></span><br><span class="line">            prev = <span class="keyword">None</span>  <span class="comment"># prev node in the same level</span></span><br><span class="line">            next = <span class="keyword">None</span>  <span class="comment"># the first node of next level</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="comment"># once `next` is set, it will not change until next level</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> next:</span><br><span class="line">                    next = cur.left <span class="keyword">if</span> cur.left <span class="keyword">else</span> cur.right</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        prev.next = cur.left</span><br><span class="line">                    prev = cur.left</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        prev.next = cur.right</span><br><span class="line">                    prev = cur.right</span><br><span class="line">                cur = cur.next  <span class="comment"># it is level order traversal!</span></span><br><span class="line">            <span class="comment"># level ends</span></span><br><span class="line">            cur = next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/populating-next-right-pointers-in-each-node/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Flatten Binary Tree to Linked List]]></title>
      <link>http://garfieldog.github.io/2015/09/08/flatten-binary-tree-to-linked-list/</link>
      <guid>http://garfieldog.github.io/2015/09/08/flatten-binary-tree-to-linked-list/</guid>
      <pubDate>Tue, 08 Sep 2015 08:13:19 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>  ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, flatten it to a linked list in-place.</p>
<p>For example,<br>Given</p>
<pre><code>    <span class="number">1</span>
   / \
  <span class="number">2</span>   <span class="number">5</span>
 / \   \
<span class="number">3</span>   <span class="number">4</span>   <span class="number">6</span>
</code></pre><p>The flattened tree should look like:<br>   1<br>    \<br>     2<br>      \<br>       3<br>        \<br>         4<br>          \<br>           5<br>            \<br>             6<br>Hints:<br>If you notice carefully in the flattened tree, each node’s right child points to the next node of a pre-order traversal.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题有点莫名其妙，不知道初衷是什么。按照提示，先序遍历，把每个被访问的节点右儿子设为下一个要访问的节点。迭代法用栈实现，时间<code>O(n)</code>，空间<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># preorder traversal</span></span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            ss.append(root)</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            cur = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                ss.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                ss.append(cur.left)</span><br><span class="line">            <span class="comment"># visit cur</span></span><br><span class="line">            cur.left = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> ss:</span><br><span class="line">                cur.right = ss[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/flatten-binary-tree-to-linked-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Balanced Binary Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/08/balanced-binary-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/08/balanced-binary-tree/</guid>
      <pubDate>Tue, 08 Sep 2015 07:08:23 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binar]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
</blockquote>
<h2 id="分析">分析</h2><p>检查二叉树是否平衡，递归法很简单。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalancedR</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">True</span>, <span class="number">0</span>)</span><br><span class="line">        f1, h1 = self.isBalancedR(root.left)</span><br><span class="line">        f2, h2 = self.isBalancedR(root.right)</span><br><span class="line">        f = f1 <span class="keyword">and</span> f2 <span class="keyword">and</span> abs(h1 - h2) &lt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> f, max(h1, h2) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        f, h = self.isBalancedR(root)</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/balanced-binary-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Symmetric Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/08/symmetric-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/08/symmetric-tree/</guid>
      <pubDate>Tue, 08 Sep 2015 02:09:11 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree is symmetric:</p>
<pre><code><span class="number">1</span>
</code></pre><p>   / \<br>  2   2<br> / \ / \<br>3  4 4  3<br>But the following is not:<br>    1<br>   / \<br>  2   2<br>   \   \<br>   3    3<br>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
</blockquote>
<h2 id="分析">分析</h2><p>左右对称地遍历二叉树，递归版比较容易。时间<code>O(n)</code>，空间平均<code>O(logn)</code>，最坏<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> root <span class="keyword">or</span> self.isSymmetric2(root.left, root.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric2</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> left == right</span><br><span class="line">        <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSymmetric2(left.left, right.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSymmetric2(left.right, right.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        ss = []</span><br><span class="line">        ss.append((root.left, root.right))</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            x, y = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">or</span> <span class="keyword">not</span> y:</span><br><span class="line">                <span class="keyword">if</span> x == y:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> x.val != y.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            ss.append((x.right, y.left))</span><br><span class="line">            ss.append((x.left, y.right))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/symmetric-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Same Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/08/same-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/08/same-tree/</guid>
      <pubDate>Tue, 08 Sep 2015 01:49:41 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are c]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two binary trees, write a function to check if they are equal or not.</p>
<p>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.</p>
</blockquote>
<h2 id="分析">分析</h2><p>本质上就是遍历二叉树，递归法很简单，迭代也不难写。时间<code>O(n)</code>，空间平均<code>O(logn)</code>，最坏<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> p == q</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSameTree(p.left, q.left):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isSameTree(p.right, q.right):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># preorder traversal</span></span><br><span class="line">        ss = []</span><br><span class="line">        ss.append((p, q))</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            x, y = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> x <span class="keyword">or</span> <span class="keyword">not</span> y):</span><br><span class="line">                <span class="keyword">if</span> x == y:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> x.val != y.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            ss.append((x.right, y.right))</span><br><span class="line">            ss.append((x.left, y.left))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/08/same-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Recover Binary Search Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/07/recover-binary-search-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/07/recover-binary-search-tree/</guid>
      <pubDate>Mon, 07 Sep 2015 14:17:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p>Note:<br>A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p>
</blockquote>
<h2 id="分析">分析</h2><p>可以用中序遍历来做，记录上一个访问的元素，如果发现违反了正序则记录位置，遍历完之后把两个位置元素调换。时间<code>O(n)</code>，空间平均<code>O(logn)</code>，最坏<code>O(n)</code>。</p>
<p>追求空间<code>O(1)</code>的解法可以使用Morris遍历。</p>
<h2 id="代码">代码</h2><h3 id="普通中序遍历">普通中序遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># inorder traversal</span></span><br><span class="line">        cur = root</span><br><span class="line">        ss = []</span><br><span class="line">        prev = TreeNode(float(<span class="string">'-inf'</span>))</span><br><span class="line">        first = second = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> ss <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                ss.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = ss.pop()</span><br><span class="line">                <span class="comment"># visit cur</span></span><br><span class="line">                <span class="keyword">if</span> cur.val &lt; prev.val:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                        first = prev</span><br><span class="line">                    second = cur</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.right</span><br><span class="line">        first.val, second.val = second.val, first.val</span><br></pre></td></tr></table></figure>
<h3 id="Morris遍历">Morris遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: void Do not return anything, modify root in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># inorder traversal</span></span><br><span class="line">        cur = root</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        first = second = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                <span class="comment"># visit cur</span></span><br><span class="line">                <span class="keyword">if</span> prev <span class="keyword">and</span> cur.val &lt; prev.val:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                        first = prev</span><br><span class="line">                    second = cur</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># not threaded yet</span></span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    <span class="comment"># visit cur</span></span><br><span class="line">                    <span class="keyword">if</span> prev <span class="keyword">and</span> cur.val &lt; prev.val:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> first:</span><br><span class="line">                            first = prev</span><br><span class="line">                        second = cur</span><br><span class="line">                    prev = cur</span><br><span class="line">                    cur = cur.right</span><br><span class="line"></span><br><span class="line">        first.val, second.val = second.val, first.val</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/recover-binary-search-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Zigzag Level Order Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-zigzag-level-order-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-zigzag-level-order-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 11:59:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to righ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its zigzag level order traversal as:<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/07/binary-tree-level-order-traversal/">Level Order Traveral</a>的姐妹版，要求每一层从左到右、从右到左花插着来。</p>
<p>用一个flag来标识当前level是从左到右还是从右到左，另外在queue中插入行间标示符（这里用<code>None</code>）来分割各行。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        level = []</span><br><span class="line">        rs = []</span><br><span class="line">        zig = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        queue.append(<span class="keyword">None</span>)  <span class="comment"># None as level seperator</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># level end</span></span><br><span class="line">                <span class="keyword">if</span> zig:</span><br><span class="line">                    rs.append(level)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rs.append(level[::-<span class="number">1</span>])</span><br><span class="line">                level = []</span><br><span class="line">                zig = <span class="keyword">not</span> zig</span><br><span class="line">                <span class="keyword">if</span> queue:</span><br><span class="line">                    queue.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-zigzag-level-order-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Level Order Traversal II]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal-2/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal-2/</guid>
      <pubDate>Mon, 07 Sep 2015 11:49:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to r]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its bottom-up level order traversal as:<br>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/07/binary-tree-level-order-traversal/">Level Order Traveral</a>的姐妹版，要求最底层的先输出。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue.append((root, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur, idx = queue.popleft()</span><br><span class="line">            d.setdefault(idx, []).append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append((cur.left, idx + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append((cur.right, idx + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> [v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(d.items(), key=<span class="keyword">lambda</span> x: -x[<span class="number">0</span>])]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Level Order Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 11:34:45 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, leve]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>广度优先遍历，用队列实现。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, OrderedDict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        d = OrderedDict()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue.append((root, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur, idx = queue.popleft()</span><br><span class="line">            d.setdefault(idx, []).append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append((cur.left, idx + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append((cur.right, idx + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Postorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-postorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-postorder-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 08:07:48 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given bi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [3,2,1].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<h2 id="分析">分析</h2><p>后序遍历是三种遍历中最难的一种，迭代版需要一个额外的指针记录上一个访问过的节点，只有当一个节点左子树和右子树都遍历过后才能访问当前节点，左子树依靠栈来保证（跟中序遍历一样），右子树需要靠prev节点来判断是否访问过。</p>
<p>Morris遍历也要更复杂一些，看<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversalR</span><span class="params">(self, root, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorderTraversalR(root.left, rs)</span><br><span class="line">        self.postorderTraversalR(root.right, rs)</span><br><span class="line">        rs.append(root.val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        self.postorderTraversalR(root, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        cur = root</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                ss.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            prev = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">while</span> ss:</span><br><span class="line">                cur = ss.pop()</span><br><span class="line">                <span class="keyword">if</span> cur.right == prev:</span><br><span class="line">                    rs.append(cur.val)</span><br><span class="line">                    prev = cur</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ss.append(cur)</span><br><span class="line">                    cur = cur.right</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="Morris">Morris</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        dummy = TreeNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.left = root</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># look up predecessor in left sub-tree</span></span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># make threaded</span></span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    <span class="comment"># visit left node to predecessor</span></span><br><span class="line">                    tmp = node</span><br><span class="line">                    self.reverse(cur.left, node)</span><br><span class="line">                    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                        rs.append(tmp.val)</span><br><span class="line">                        <span class="keyword">if</span> tmp == cur.left:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        tmp = tmp.right</span><br><span class="line">                    self.reverse(node, cur.left)</span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> a == b:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = a</span><br><span class="line">        y = a.right</span><br><span class="line">        <span class="keyword">while</span> x != b:</span><br><span class="line">            z = y.right</span><br><span class="line">            y.right = x</span><br><span class="line">            x = y</span><br><span class="line">            y = z</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-postorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Inorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-inorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-inorder-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 07:32:04 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given bina]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [1,3,2].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<h2 id="分析">分析</h2><p>中序遍历，基本上沿用<a href="/2015/09/07/binary-tree-preorder-traversal/">上一题</a>的框架。</p>
<p>Morris遍历继续参考<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversalR</span><span class="params">(self, root, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorderTraversalR(root.left, rs)</span><br><span class="line">        rs.append(root.val)</span><br><span class="line">        self.inorderTraversalR(root.right, rs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        self.inorderTraversalR(root, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> ss:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                ss.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = ss.pop()</span><br><span class="line">                rs.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="Morris">Morris</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                rs.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># look up predecessor in left sub-tree</span></span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># make threaded</span></span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    rs.append(cur.val)</span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-inorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Preorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-preorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-preorder-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 07:00:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given bin]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [1,2,3].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，二叉树的先序遍历。当使用迭代方法时，注意入栈的顺序，需要先push右节点，再push左节点。</p>
<p>还有一种不常用的方法<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">Morris遍历</a>，可以做到空间<code>O(1)</code>，时间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversalR</span><span class="params">(self, root, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        rs.append(root.val)</span><br><span class="line">        self.preorderTraversalR(root.left, rs)</span><br><span class="line">        self.preorderTraversalR(root.right, rs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        self.preorderTraversalR(root, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            ss.append(root)</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            cur = ss.pop()</span><br><span class="line">            rs.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                ss.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                ss.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="Morris">Morris</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                rs.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># look up predecessor in left sub-tree</span></span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># make threaded</span></span><br><span class="line">                    rs.append(cur.val)</span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-preorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Evaluate Reverse Polish Notation]]></title>
      <link>http://garfieldog.github.io/2015/09/07/evaluate-reverse-polish-notation/</link>
      <guid>http://garfieldog.github.io/2015/09/07/evaluate-reverse-polish-notation/</guid>
      <pubDate>Mon, 07 Sep 2015 06:37:01 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:<br>  [“2”, “1”, “+”, “3”, “*“] -&gt; ((2 + 1) * 3) -&gt; 9<br>  [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6</p>
</blockquote>
<h2 id="分析">分析</h2><p>逆波兰式求值，比较简单，注意代码里除法<code>int(float(a) / b))</code>是因为Python 2有一个奇葩的设置就是除法结果是负数的时候是向下取整的（我们需要向0取整）。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self, op, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">return</span> a + b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> a - b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> a * b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> int(float(a) / b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type tokens: List[str]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">                b = ss.pop()</span><br><span class="line">                a = ss.pop()</span><br><span class="line">                ss.append(self.eval(t, a, b))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss.append(int(t))</span><br><span class="line">        <span class="keyword">return</span> ss[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/evaluate-reverse-polish-notation/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Largest Rectangle in Histogram]]></title>
      <link>http://garfieldog.github.io/2015/09/07/largest-rectangle-in-histogram/</link>
      <guid>http://garfieldog.github.io/2015/09/07/largest-rectangle-in-histogram/</guid>
      <pubDate>Mon, 07 Sep 2015 05:15:40 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, f]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="/images/histogram.png" alt="histogram"><br>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p><img src="/images/histogram_area.png" alt="histogram-area"><br>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>For example,<br>Given height = [2,1,5,6,2,3],<br>return 10.</p>
</blockquote>
<h2 id="分析">分析</h2><p>时间<code>O(n^2)</code>的算法很容易想，每个位置上向两边扩散就可以。不过还可以更好：利用一个栈，栈内维护递增的序列，遇到破坏递增的元素就持续出栈（这时栈顶元素能围成多大的矩形已经可以计算），直到当前元素大于栈顶，继续入栈。详细分析可参考<a href="http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html" target="_blank" rel="external">这篇文章</a>。</p>
<p>注意<code>if not ss or height[i] &gt; height[ss[-1]]:</code> 中的判断<code>&gt;</code>还是<code>&gt;=</code>不影响正确性，想想为什么。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ss = []</span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        height.append(<span class="number">0</span>)</span><br><span class="line">        n = len(height)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss <span class="keyword">or</span> height[i] &gt; height[ss[-<span class="number">1</span>]]:</span><br><span class="line">                ss.append(i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx = ss.pop()</span><br><span class="line">                w = i <span class="keyword">if</span> <span class="keyword">not</span> ss <span class="keyword">else</span> i - <span class="number">1</span> - ss[-<span class="number">1</span>]</span><br><span class="line">                max_area = max(max_area, height[idx] * w)</span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/largest-rectangle-in-histogram/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Longest Valid Parentheses]]></title>
      <link>http://garfieldog.github.io/2015/09/06/longest-valid-parentheses/</link>
      <guid>http://garfieldog.github.io/2015/09/06/longest-valid-parentheses/</guid>
      <pubDate>Sun, 06 Sep 2015 11:33:29 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-for]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<h2 id="分析">分析</h2><p>稍有难度，使用栈，时间<code>O(n)</code>，空间<code>O(n)</code>。</p>
</blockquote>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ss = []</span><br><span class="line">        n = len(s)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        last = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                ss.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                last = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                    max_len = max(max_len, i - last)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    max_len = max(max_len, i - ss[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/longest-valid-parentheses/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
