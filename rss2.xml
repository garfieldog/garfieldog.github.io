<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Mon, 31 Aug 2015 09:20:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Implement strStr()]]></title>
      <link>http://garfieldog.github.io/2015/08/31/implement-strstr/</link>
      <guid>http://garfieldog.github.io/2015/08/31/implement-strstr/</guid>
      <pubDate>Mon, 31 Aug 2015 03:50:48 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if need]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement strStr().</p>
<p>Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>
</blockquote>
<h2 id="分析">分析</h2><p>查找子字符串，暴力搜索时间复杂度<code>O(mn)</code>，其中<code>m``n</code>分别是haystack和need的长度。还有很多经典算法，如<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">KMP</a>，<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" target="_blank" rel="external">Boyer-Moore</a>。KMP算法最坏是时间<code>O(m + n)</code>的，实现可以参考<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">Wiki</a>或<a href="http://www.matrix67.com/blog/archives/115" target="_blank" rel="external">KMP算法详解</a>。<a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" target="_blank" rel="external">Boyer-Moore</a>算法实际情况下表现通常优于KMP，尽管它（needle在haystack中时的）最坏情况下时间是<code>O(mn)</code>的。可以参考<a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="external">字符串匹配的Boyer-Moore算法</a>。</p>
<p>因为<code>BM</code>算法使用了两个启发式规则（<code>坏字符</code>和<code>好后缀</code>）来移动needle，而这两个规则是独立的，所以其实用一个也不影响正确性，实现起来方便，只是运行稍慢一些。</p>
<h2 id="代码">代码</h2><h3 id="暴力搜索">暴力搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(self, haystack, i, needle)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(len(needle)):</span><br><span class="line">            <span class="keyword">if</span> haystack[i + k] != needle[k]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type haystack: str</span><br><span class="line">        :type needle: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        m, n = len(haystack), len(needle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self.match(haystack, i, needle):</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="KMP">KMP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type haystack: str</span><br><span class="line">        :type needle: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(haystack), len(needle)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pre-calculate `p` array</span></span><br><span class="line">        p = [<span class="number">0</span>]</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> needle[i] != needle[j]:</span><br><span class="line">                j = p[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> needle[i] == needle[j]:</span><br><span class="line">                j = j + <span class="number">1</span></span><br><span class="line">            p.append(j)</span><br><span class="line"></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> haystack[i] != needle[j]:</span><br><span class="line">                j = p[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == n:</span><br><span class="line">                <span class="keyword">return</span> i - n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="简化版BM（只有坏字符，没有好前缀）">简化版BM（只有坏字符，没有好前缀）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type haystack: str</span><br><span class="line">        :type needle: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> needle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(haystack), len(needle)</span><br><span class="line">        p = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(needle)&#125;</span><br><span class="line">        i = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m:</span><br><span class="line">            found = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                <span class="keyword">if</span> haystack[i - j] != needle[n - <span class="number">1</span> - j]:</span><br><span class="line">                    c = p.get(haystack[i - j], -<span class="number">1</span>)</span><br><span class="line">                    new_i = i - j + n - <span class="number">1</span> - c</span><br><span class="line">                    <span class="keyword">if</span> new_i &lt;= i:</span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        i = new_i</span><br><span class="line">                    found = <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">return</span> i - n + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="完整BM">完整BM</h3><p>TBD</p>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/31/implement-strstr/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Valid Palindrome]]></title>
      <link>http://garfieldog.github.io/2015/08/31/valid-palindrome/</link>
      <guid>http://garfieldog.github.io/2015/08/31/valid-palindrome/</guid>
      <pubDate>Mon, 31 Aug 2015 03:36:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring ca]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>For example,<br>“A man, a plan, a canal: Panama” is a palindrome.<br>“race a car” is not a palindrome.</p>
<p>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.</p>
<p>For the purpose of this problem, we define empty string as valid palindrome.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，判断是否回文。用两指针，分别从头和尾相向而行，时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><p>###Python<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s[i].isalnum():</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> s[j].isalnum():</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> s[i].lower() == s[j].lower():</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/31/valid-palindrome/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-LRU Cache]]></title>
      <link>http://garfieldog.github.io/2015/08/29/lru-cache/</link>
      <guid>http://garfieldog.github.io/2015/08/29/lru-cache/</guid>
      <pubDate>Sat, 29 Aug 2015 09:50:57 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the followin]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要求实现一个LRU cache，有两个要点：</p>
<ol>
<li><code>get</code>, <code>set</code>操作都应该是<code>O(1)</code>的，否则就失去了cache的意义</li>
<li>要保持LRU的语义</li>
</ol>
<p>所以我们用一个哈希表外加一个双向链表完成（单项链表无法做到<code>O(1)</code>）。用hash表来迅速定位到节点，每次访问一个节点后，将这个节点移动到链表头部(<code>move_to_head</code>)，当cache到达capacity上限时，从链表尾部删除节点。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for doubly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">        self.key = key</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(self.val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type capacity: int</span><br><span class="line">        """</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        self.dummy_head = ListNode(<span class="keyword">None</span>, -<span class="number">1</span>)</span><br><span class="line">        self.dummy_tail = ListNode(<span class="keyword">None</span>, -<span class="number">1</span>)</span><br><span class="line">        self.dummy_head.next = self.dummy_tail</span><br><span class="line">        self.dummy_tail.prev = self.dummy_head</span><br><span class="line">        self.store = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_list</span><span class="params">(self)</span>:</span></span><br><span class="line">        cur = self.dummy_head.next</span><br><span class="line">        <span class="keyword">while</span> cur != self.dummy_tail:</span><br><span class="line">            <span class="keyword">print</span> cur.val, <span class="string">'-&gt;'</span>,</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">print</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to_head</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == self.dummy_head <span class="keyword">or</span> node == self.dummy_tail:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.prev:</span><br><span class="line">            node.prev.next = node.next</span><br><span class="line">        <span class="keyword">if</span> node.next:</span><br><span class="line">            node.next.prev = node.prev</span><br><span class="line">        node.prev = self.dummy_head</span><br><span class="line">        node.next = self.dummy_head.next</span><br><span class="line">        self.dummy_head.next.prev = node</span><br><span class="line">        self.dummy_head.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        node = self.store.get(key, self.dummy_head)</span><br><span class="line">        self.move_to_head(node)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type key: int</span><br><span class="line">        :type value: int</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.store:</span><br><span class="line">            node = self.store[key]</span><br><span class="line">            node.val = value</span><br><span class="line">            self.move_to_head(node)</span><br><span class="line">        <span class="keyword">elif</span> self.size &lt; self.capacity:</span><br><span class="line">            node = ListNode(key, value)</span><br><span class="line">            self.move_to_head(node)</span><br><span class="line">            self.store[key] = node</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            last = self.dummy_tail.prev</span><br><span class="line">            <span class="keyword">del</span> self.store[last.key]</span><br><span class="line">            last.val = value</span><br><span class="line">            last.key = key</span><br><span class="line">            self.store[last.key] = last</span><br><span class="line">            self.move_to_head(last)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/29/lru-cache/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reorder List]]></title>
      <link>http://garfieldog.github.io/2015/08/27/reorder-list/</link>
      <guid>http://garfieldog.github.io/2015/08/27/reorder-list/</guid>
      <pubDate>Thu, 27 Aug 2015 15:35:15 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You must do this in-place without altering the nodes’ values.</p>
<p>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
</blockquote>
<h2 id="分析">分析</h2><p>分四步：</p>
<ol>
<li>遍历链表获得长度</li>
<li>找到链表中点，断开成两个链表</li>
<li>翻转第二个链表</li>
<li>将两个链表合并</li>
</ol>
<p>时间复杂度<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: void Do not return anything, modify head in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        m = (l - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">        head2 = cur.next</span><br><span class="line">        cur.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># now we have two lists, reverse the second one</span></span><br><span class="line">        prev = head2</span><br><span class="line">        cur = head2.next</span><br><span class="line">        prev.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            next = cur.next</span><br><span class="line">            cur.next = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = next</span><br><span class="line">        head2 = prev</span><br><span class="line"></span><br><span class="line">        <span class="comment"># then we merge the two lists</span></span><br><span class="line">        <span class="keyword">while</span> head2:</span><br><span class="line">            n1 = head.next</span><br><span class="line">            n2 = head2.next</span><br><span class="line">            head.next = head2</span><br><span class="line">            head2.next = n1</span><br><span class="line">            head = n1</span><br><span class="line">            head2 = n2</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/27/reorder-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Linked List Cycle II]]></title>
      <link>http://garfieldog.github.io/2015/08/27/linked-list-cycle-2/</link>
      <guid>http://garfieldog.github.io/2015/08/27/linked-list-cycle-2/</guid>
      <pubDate>Thu, 27 Aug 2015 14:39:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>No]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>Note: Do not modify the linked list.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p><a href="/2015/08/27/linked-list-cycle/">Linked List Cycle</a>的升级版。要求不仅判断是否有环，而且要找出环开始的位置。</p>
<h2 id="分析">分析</h2><p>对于存在环的情况，设从链表头部到环第一个元素的距离为<code>x</code>，从环第一个元素到两指针相遇点距离为<code>y</code>，环长度为<code>r</code>。这里可以证明的一点是，当两指针相遇时，慢指针肯定没有跑完一圈。这样来证明：当慢指针到达环第一个元素时，快指针肯定在环中某个地方，设距离环第一个元素<code>z</code>，肯定有<code>z &lt; r</code>。而快指针只需要<code>z</code>步就可以追上慢指针，所以慢指针没有机会跑完一圈。</p>
<p>设相遇时已经走了<code>t</code>步，则<code>t = x + y</code>, <code>2t = x + y + nr</code>， 其中<code>n</code>为正整数。则可以推导出<code>t = nr</code>，<code>x = nr - y = (n - 1)r + (r - y)</code>。这样一来，如果我们在两指针相遇后，再用一个指针从链表头开始走，直到它和慢指针相遇，相遇点就是环开始的地方。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        p1 = head.next</span><br><span class="line">        p2 = head.next.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2 <span class="keyword">or</span> <span class="keyword">not</span> p2.next:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p1 == p2:</span><br><span class="line">            p2 = head</span><br><span class="line">            <span class="keyword">while</span> p1 != p2:</span><br><span class="line">                p1 = p1.next</span><br><span class="line">                p2 = p2.next</span><br><span class="line">            <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/27/linked-list-cycle-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Linked List Cycle]]></title>
      <link>http://garfieldog.github.io/2015/08/27/linked-list-cycle/</link>
      <guid>http://garfieldog.github.io/2015/08/27/linked-list-cycle/</guid>
      <pubDate>Thu, 27 Aug 2015 14:25:31 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without usi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, determine if it has a cycle in it.</p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<h2 id="分析">分析</h2><p>经典题，使用两指针，一个每次走一步，另一个走两步，如果两指针相遇，则说明有环。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        p1 = head.next</span><br><span class="line">        p2 = head.next.next</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> p2 <span class="keyword">or</span> <span class="keyword">not</span> p2.next:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            p2 = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/27/linked-list-cycle/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Copy List with Random Pointer]]></title>
      <link>http://garfieldog.github.io/2015/08/26/copy-list-with-random-pointer/</link>
      <guid>http://garfieldog.github.io/2015/08/26/copy-list-with-random-pointer/</guid>
      <pubDate>Wed, 26 Aug 2015 09:51:07 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题有点技巧，拢共分三步：</p>
<ol>
<li>第一步，给原链表每个节点复制一个拷贝，插入到原节点后面。</li>
<li>第二步，再次遍历链表，给复制出来的节点设置random指针。</li>
<li>第三步，再次遍历链表，把原链表的节点和复制出来的节点拆成两个链表。</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.random = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: RandomListNode</span><br><span class="line">        :rtype: RandomListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            node = RandomListNode(cur.label)</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            cur = node.next</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.random:</span><br><span class="line">                cur.next.random = cur.random.next</span><br><span class="line">            cur = cur.next.next</span><br><span class="line"></span><br><span class="line">        cur = head</span><br><span class="line">        new_head = cur.next</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.next:</span><br><span class="line">            next = cur.next</span><br><span class="line">            cur.next = cur.next.next</span><br><span class="line">            cur = next</span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/copy-list-with-random-pointer/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Nodes in k-Group]]></title>
      <link>http://garfieldog.github.io/2015/08/26/reverse-nodes-in-k-group/</link>
      <guid>http://garfieldog.github.io/2015/08/26/reverse-nodes-in-k-group/</guid>
      <pubDate>Wed, 26 Aug 2015 07:00:29 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>You may not alter the values in the nodes, only nodes itself may be changed.</p>
<p>Only constant memory is allowed.</p>
<p>For example,<br>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5</p>
<p>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/08/26/swap-nodes-in-pairs/">Swap Nodes in Pairs</a>的升级版。一组一组地翻转，注意指针操作。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, prev, end, k)</span>:</span></span><br><span class="line">        end_next = end.next</span><br><span class="line">        head = prev.next</span><br><span class="line">        p1 = head</span><br><span class="line">        p2 = head.next</span><br><span class="line">        <span class="keyword">while</span> p2 != end_next:</span><br><span class="line">            next = p2.next</span><br><span class="line">            p2.next = p1</span><br><span class="line">            p1 = p2</span><br><span class="line">            p2 = next</span><br><span class="line">        head.next = end_next</span><br><span class="line">        prev.next = p1</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next <span class="keyword">or</span> k &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            end = head</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> end:</span><br><span class="line">                    end = end.next</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> end:  <span class="comment"># not enough k nodes</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            prev = self.reverse(prev, end, k)</span><br><span class="line">            head = prev.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/reverse-nodes-in-k-group/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Swap Nodes In Pairs]]></title>
      <link>http://garfieldog.github.io/2015/08/26/swap-nodes-in-pairs/</link>
      <guid>http://garfieldog.github.io/2015/08/26/swap-nodes-in-pairs/</guid>
      <pubDate>Wed, 26 Aug 2015 06:34:09 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&g]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, swap every two adjacent nodes and return its head.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.</p>
</blockquote>
<h2 id="分析">分析</h2><p>遍历链表，隔一个数（分奇偶）把当前数插到它前一个数的前面。时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="实现">实现</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy1 = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy2 = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy1.next = dummy2</span><br><span class="line">        dummy2.next = head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        prev = dummy1</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span>:</span><br><span class="line">                next = cur.next</span><br><span class="line">                prev.next.next = cur.next</span><br><span class="line">                cur.next = prev.next</span><br><span class="line">                prev.next = cur</span><br><span class="line">                cur = next</span><br><span class="line">                prev = prev.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                prev = prev.next</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dummy2.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/swap-nodes-in-pairs/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Nth node From End of List]]></title>
      <link>http://garfieldog.github.io/2015/08/26/remove-nth-node-from-end-of-list/</link>
      <guid>http://garfieldog.github.io/2015/08/26/remove-nth-node-from-end-of-list/</guid>
      <pubDate>Wed, 26 Aug 2015 06:10:04 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,</p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list, remove the nth node from the end of list and return its head.</p>
<p>For example,</p>
<p>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</p>
<p>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.<br>Note:<br>Given n will always be valid.<br>Try to do this in one pass.</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们在<a href="/2015/08/26/rotate-list/">Rotate List</a>中已经讨论过这个方法，用两指针，时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        p1 = p2 = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            p1 = p1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p1.next:</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line"></span><br><span class="line">        p2.next = p2.next.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/remove-nth-node-from-end-of-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Rotate Array]]></title>
      <link>http://garfieldog.github.io/2015/08/26/rotate-array/</link>
      <guid>http://garfieldog.github.io/2015/08/26/rotate-array/</guid>
      <pubDate>Wed, 26 Aug 2015 03:56:18 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the arra]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Rotate an array of n elements to the right by k steps.</p>
<p>For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].</p>
<p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.</p>
</blockquote>
<h2 id="分析">分析</h2><p>如果允许开新数组，那就太简单了，当然我们要找空间<code>O(1)</code>的解法。把原数组分为两段，分别翻转，然后把数组整体翻转，就得到了结果。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: void Do not return anything, modify nums in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        k = (len(nums) - k) % len(nums)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>)</span><br><span class="line">        self.reverse(nums, k, len(nums) - <span class="number">1</span>)</span><br><span class="line">        self.reverse(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, x, y)</span>:</span></span><br><span class="line">        k = (y - x + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            nums[x + i], nums[y - i] = nums[y - i], nums[x + i]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/rotate-array/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Rotate List]]></title>
      <link>http://garfieldog.github.io/2015/08/26/rotate-list/</link>
      <guid>http://garfieldog.github.io/2015/08/26/rotate-list/</guid>
      <pubDate>Wed, 26 Aug 2015 02:20:17 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>G]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a list, rotate the list to the right by k places, where k is non-negative.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL and k = 2,<br>return 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL.</p>
</blockquote>
<h2 id="分析">分析</h2><p>同样看上去不难，但要写对还是不容易。首先要解决找到右手起第k个数，这个有一个精妙的找法，用两个指针，一个先走k步，然后两个一起走，第一个指针到尾部时，第二个指针恰好就在倒数第k个位置。但这道题k有可能比链表长度大，所以用这种方法就没意义了，还是老老实实遍历一遍列表数出个数吧。</p>
<ol>
<li>遍历列表获得总长度，将右手第k转化为左手第<code>(len - k) % len</code>个。</li>
<li>这时候有一个比较巧的做法，就是先把列表首尾连接起来（我们第一次遍历结束时指针恰好在尾部）。</li>
<li>然后让指针继续走<code>(len - k) % len</code>步，这时候就走到了新链表的尾部，断开环，返回新头部。</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        cur = head</span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        k = (length - k) % length</span><br><span class="line">        <span class="comment"># now cur is the last element</span></span><br><span class="line">        cur.next = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(k):</span><br><span class="line">            cur = cur.next</span><br><span class="line">        new_head = cur.next</span><br><span class="line">        cur.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> new_head</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/26/rotate-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Duplicates From Sorted List II]]></title>
      <link>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list-2/</link>
      <guid>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list-2/</guid>
      <pubDate>Tue, 25 Aug 2015 11:27:13 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers f]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>For example,<br>Given 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return 1-&gt;2-&gt;5.<br>Given 1-&gt;1-&gt;1-&gt;2-&gt;3, return 2-&gt;3.</p>
</blockquote>
<p>和<a href="/2015/08/25/remove-duplicates-from-sorted-list/">Remove Duplicates from Sorted List</a>设定基本一样，要求返回值只包括唯一的元素。</p>
<h2 id="分析">分析</h2><p>需要额外判断删除了重复值后剩下的数是本来就唯一呢，还是曾经有重复值。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            dup = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.val == cur.next.val:</span><br><span class="line">                dup = <span class="keyword">True</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># now cur is the either an unique number or the last one the a sequence of duplicates</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dup:</span><br><span class="line">                prev.next = cur</span><br><span class="line">                prev = prev.next</span><br><span class="line">            cur = cur.next</span><br><span class="line">        prev.next = cur</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Duplicates From Sorted List]]></title>
      <link>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list/</link>
      <guid>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list/</guid>
      <pubDate>Tue, 25 Aug 2015 11:27:13 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For exa]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们之前做过一道<a href="/2015/08/18/remove-duplicates-from-sorted-array/">Remove Duplicates from Sorted Array</a>，跟这道题解法其实是一样的，只是数据结构换成了链表。注意指针的维护。时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(<span class="keyword">None</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.val == prev.val:</span><br><span class="line">                prev.next = cur.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                prev = prev.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/remove-duplicates-from-sorted-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Partition List]]></title>
      <link>http://garfieldog.github.io/2015/08/25/partition-list/</link>
      <guid>http://garfieldog.github.io/2015/08/25/partition-list/</guid>
      <pubDate>Tue, 25 Aug 2015 09:24:18 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>For example,<br>Given 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 and x = 3,<br>return 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5.</p>
</blockquote>
<h2 id="分析">分析</h2><p>就是快排中的parition，但使用链表数据结构，实现有一些不一样。维护两个链表，一个把小于x的值串起来，一个把大于等于x的值串起来，最后把这两个链表拼接起来就可以。时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        left_dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        right_dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        left_cur = left_dummy</span><br><span class="line">        right_cur = right_dummy</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                left_cur.next = head</span><br><span class="line">                left_cur = head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right_cur.next = head</span><br><span class="line">                right_cur = head</span><br><span class="line">            head = head.next</span><br><span class="line"></span><br><span class="line">        left_cur.next = right_dummy.next</span><br><span class="line">        right_cur.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> left_dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/partition-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Linked List II]]></title>
      <link>http://garfieldog.github.io/2015/08/25/reverse-linked-list-2/</link>
      <guid>http://garfieldog.github.io/2015/08/25/reverse-linked-list-2/</guid>
      <pubDate>Tue, 25 Aug 2015 07:25:54 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p>
<p>For example:<br>Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,</p>
<p>return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</p>
<p>Note:<br>Given m, n satisfy the following condition:<br>1 ≤ m ≤ n ≤ length of list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要求部分翻转一个链表。看起来不是很难，但要写对真是非常费力。</p>
<ol>
<li>找到需要翻转的子链表头部的前一个元素<code>new_head</code>（为了防止第一个元素没有前一个元素，可以用一个dummy元素插在原链表头部）</li>
<li>从子链表的第二个元素开始遍历子链表，把当前元素插入到<code>new_head</code>之后，也就是子链表第一个元素之前，并维护好指针指向。</li>
<li>dummy元素之后的链表就是最终结果</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - <span class="number">1</span>):</span><br><span class="line">            prev = prev.next</span><br><span class="line"></span><br><span class="line">        new_head = prev</span><br><span class="line">        prev = new_head.next</span><br><span class="line"></span><br><span class="line">        cur = prev.next</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m, n):</span><br><span class="line">            prev.next = cur.next</span><br><span class="line">            cur.next = new_head.next</span><br><span class="line">            new_head.next = cur</span><br><span class="line">            cur = prev.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/reverse-linked-list-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Linked List]]></title>
      <link>http://garfieldog.github.io/2015/08/25/reverse-linked-list/</link>
      <guid>http://garfieldog.github.io/2015/08/25/reverse-linked-list/</guid>
      <pubDate>Tue, 25 Aug 2015 07:17:23 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a singly linked list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，翻转单链表。时间<code>O(n)</code>，空间<co]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse a singly linked list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，翻转单链表。时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        last = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            next = head.next</span><br><span class="line">            head.next = last</span><br><span class="line">            last = head</span><br><span class="line">            head = next</span><br><span class="line">        <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/reverse-linked-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Add Two Numbers]]></title>
      <link>http://garfieldog.github.io/2015/08/25/add-two-numbers/</link>
      <guid>http://garfieldog.github.io/2015/08/25/add-two-numbers/</guid>
      <pubDate>Tue, 25 Aug 2015 06:08:06 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse or]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单的链表题，复用已有链表本身的节点，可以实现时间<code>O(n)</code>，空间<code>O(1)</code>的算法。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type l1: ListNode</span><br><span class="line">        :type l2: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line"></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        head = l1</span><br><span class="line">        tail = l1</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            tail = l1</span><br><span class="line">            carry, l1.val = divmod(l1.val + l2.val + carry, <span class="number">10</span>)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1:</span><br><span class="line">            tail = l1</span><br><span class="line">            carry, l1.val = divmod(l1.val + carry, <span class="number">10</span>)</span><br><span class="line">            l1 = l1.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            tail.next = l2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l2:</span><br><span class="line">            tail = l2</span><br><span class="line">            carry, l2.val = divmod(l2.val + carry, <span class="number">10</span>)</span><br><span class="line">            l2 = l2.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">            tail.next = ListNode(carry)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/add-two-numbers/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Single Number III]]></title>
      <link>http://garfieldog.github.io/2015/08/25/single-number-3/</link>
      <guid>http://garfieldog.github.io/2015/08/25/single-number-3/</guid>
      <pubDate>Tue, 25 Aug 2015 05:46:34 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p>For example:</p>
<p>Given nums = [1, 2, 1, 3, 2, 5], return [3, 5].</p>
<p>Note:<br>The order of the result is not important. So in the above example, [5, 3] is also correct.<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant space complexity?</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/08/25/single-number/">Single Number</a>基本设定一致，区别在于这次有两个出现一次的数，设为<code>x</code>和<code>y</code>。这给我们了一点启发，那我们是不是可以套用[Single Number]的解法呢？是可以的，不过我们给所有数取异或后，剩下的值是 $ z = x \oplus y<br>$，这时候我们要怎么把x和y给分别求出来呢？我们只需要用一个bit位就能够区分出来，任取z的为1的某一位（说明x和y在这一位上不一致），把原数组中这一位是1的数放到一拨，为0的放到一拨，分别取异或，就解出了x和y。</p>
<p>取z的某一位为1的bit位，可以就用<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E4%BD%8E%E6%9C%89%E6%95%88%E4%BD%8D" target="_blank" rel="external">LSB</a>，它有一个漂亮的求法<code>n &amp; -n</code>，更多位运算的奇技淫巧看这里：<a href="https://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="external">Bit Twiddling Hacks</a>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        z = reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br><span class="line">        lsb = z &amp; -z</span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n &amp; lsb:</span><br><span class="line">                x ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                y ^= n</span><br><span class="line">        <span class="keyword">return</span> [x, y]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/single-number-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Single Number II]]></title>
      <link>http://garfieldog.github.io/2015/08/25/single-number-2/</link>
      <guid>http://garfieldog.github.io/2015/08/25/single-number-2/</guid>
      <pubDate>Tue, 25 Aug 2015 03:50:49 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, every element appears three times except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h2 id="分析">分析</h2><p>这次变成了其他数字出现3次，不是偶数次，所以直接使用异或是行不通的，我们可以用一个长度为32（int的位数）的数组来记录每一个位上出现的次数，如果不是3的倍数则提取出来，组成结果的数。这个算法是空间<code>O(1)</code>的，因为数组大小固定是32，有点基排序的意思，但显得不那么优雅。可以用三个变量来代替这32个变量，模拟三进制运算：用<code>ones</code>记录二进制1出现1次（mod 3余1）的位数，<code>twos</code>记录二进制1出现2次（mod 3余2）的位数，出现3次时该位清零。</p>
<h2 id="代码">代码</h2><h3 id="固定大小数组">固定大小数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        s = <span class="number">32</span></span><br><span class="line">        b = [<span class="number">0</span>] * s</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(s):</span><br><span class="line">                f = (<span class="number">1</span> &lt;&lt; i) &amp; x</span><br><span class="line">                <span class="keyword">if</span> f:</span><br><span class="line">                    b[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(s):</span><br><span class="line">            <span class="keyword">if</span> b[i] % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">                ret |= <span class="number">1</span> &lt;&lt; i</span><br><span class="line">        <span class="keyword">return</span> ret <span class="keyword">if</span> b[-<span class="number">1</span>] % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">else</span> ret - (<span class="number">1</span> &lt;&lt; s)</span><br></pre></td></tr></table></figure>
<h3 id="模拟三进制">模拟三进制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ones, twos, xthrees = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            twos |= (ones &amp; x)  <span class="comment"># 这时候twos里包括了2次或3次的</span></span><br><span class="line">            ones ^= x  <span class="comment"># 这时候ones中包括了出现1次或者3次的</span></span><br><span class="line">            xthrees = ~(ones &amp; twos)  <span class="comment"># xthrees里包括了出现1次或2次的</span></span><br><span class="line">            ones &amp;= xthrees</span><br><span class="line">            twos &amp;= xthrees</span><br><span class="line">        <span class="keyword">return</span> ones</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/single-number-2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
