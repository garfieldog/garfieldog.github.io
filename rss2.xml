<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Tue, 15 Sep 2015 12:01:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Combination Sum III]]></title>
      <link>http://garfieldog.github.io/2015/09/15/combination-sum-3/</link>
      <guid>http://garfieldog.github.io/2015/09/15/combination-sum-3/</guid>
      <pubDate>Tue, 15 Sep 2015 11:42:08 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Ensure that numbers within the set are sorted in ascending order.</p>
<p>Example 1:</p>
<p>Input: k = 3, n = 7</p>
<p>Output:</p>
<p>[[1,2,4]]</p>
<p>Example 2:</p>
<p>Input: k = 3, n = 9</p>
<p>Output:</p>
<p>[[1,2,6], [1,3,5], [2,3,4]]<br>Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/09/15/combination-sum/">Combination Sum</a>、<a href="/2015/09/15/combination-sum-2/">Combination Sum II</a>这两道题是一系列的，解法也大同小异。这次多了一个步长。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, k, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(candidates)):</span><br><span class="line">            c = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> candidates[i] <span class="keyword">and</span> (<span class="keyword">not</span> path <span class="keyword">or</span> c &gt;= path[-<span class="number">1</span>]) <span class="keyword">and</span> target - c &gt;= <span class="number">0</span>:</span><br><span class="line">                path.append(c)</span><br><span class="line">                candidates[i] = <span class="number">1</span></span><br><span class="line">                self.dfs(candidates, target - c, k - <span class="number">1</span>, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line">                candidates[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type k: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        candidates = [<span class="number">0</span>] * <span class="number">9</span></span><br><span class="line">        self.dfs(candidates, n, k, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/combination-sum-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Combination Sum II]]></title>
      <link>http://garfieldog.github.io/2015/09/15/combination-sum-2/</link>
      <guid>http://garfieldog.github.io/2015/09/15/combination-sum-2/</guid>
      <pubDate>Tue, 15 Sep 2015 11:29:14 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C wh]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set 10,1,2,7,6,1,5 and target 8,<br>A solution set is:<br>[1, 7]<br>[1, 2, 5]<br>[2, 6]<br>[1, 1, 6] </p>
</blockquote>
<h2 id="分析">分析</h2><p>这次要求一个元素只能用一次（但同样数值的元素可能出现多次，我们用一个OrderedDict来存储计数），稍微修改<a href="/2015/09/15/combination-sum/">Combination Sum</a>中的答案就可以了。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict, Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> c, v <span class="keyword">in</span> candidates.iteritems():</span><br><span class="line">            <span class="keyword">if</span> v &gt; <span class="number">0</span> <span class="keyword">and</span> (<span class="keyword">not</span> path <span class="keyword">or</span> c &gt;= path[-<span class="number">1</span>]) <span class="keyword">and</span> target - c &gt;= <span class="number">0</span>:</span><br><span class="line">                path.append(c)</span><br><span class="line">                candidates[c] -= <span class="number">1</span></span><br><span class="line">                self.dfs(candidates, target - c, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line">                candidates[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type candidates: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> target &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        c = Counter(candidates)</span><br><span class="line">        candidates = OrderedDict(sorted(c.items()))</span><br><span class="line">        self.dfs(candidates, target, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/combination-sum-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Combination Sum]]></title>
      <link>http://garfieldog.github.io/2015/09/15/combination-sum/</link>
      <guid>http://garfieldog.github.io/2015/09/15/combination-sum/</guid>
      <pubDate>Tue, 15 Sep 2015 11:16:43 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The same repeated number may be chosen from C unlimited number of times.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set 2,3,6,7 and target 7,<br>A solution set is:<br>[7]<br>[2, 2, 3] </p>
</blockquote>
<h2 id="分析">分析</h2><p>依然是回溯法，不再解释，注意剪枝条件（保证combination是递增的）</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> path <span class="keyword">or</span> c &gt;= path[-<span class="number">1</span>]) <span class="keyword">and</span> target - c &gt;= <span class="number">0</span>:</span><br><span class="line">                path.append(c)</span><br><span class="line">                self.dfs(candidates, target - c, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type candidates: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> target &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.dfs(candidates, target, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/combination-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Restore Ip Addresses]]></title>
      <link>http://garfieldog.github.io/2015/09/15/restore-ip-addresses/</link>
      <guid>http://garfieldog.github.io/2015/09/15/restore-ip-addresses/</guid>
      <pubDate>Tue, 15 Sep 2015 09:21:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>For example:<br>Given “25525511135”,</p>
<p>return [“255.255.11.135”, “255.255.111.35”]. (Order does not matter)</p>
</blockquote>
<h2 id="分析">分析</h2><p>做了那么多回溯法的题，这道题简直就是套模板。时间<code>O(n^4)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">or</span> (x[<span class="number">0</span>] == <span class="string">'0'</span> <span class="keyword">and</span> len(x) &gt; <span class="number">1</span>) <span class="keyword">or</span> int(x) &gt; <span class="number">255</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, start, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> start == len(s):</span><br><span class="line">                rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start, len(s)):</span><br><span class="line">            part = s[start:i + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.isValid(part):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(part)</span><br><span class="line">            self.dfs(s, i + <span class="number">1</span>, path, rs)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(s, <span class="number">0</span>, path, rs)</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'.'</span>.join(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/restore-ip-addresses/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-N Queens II]]></title>
      <link>http://garfieldog.github.io/2015/09/15/n-queens-2/</link>
      <guid>http://garfieldog.github.io/2015/09/15/n-queens-2/</guid>
      <pubDate>Tue, 15 Sep 2015 09:07:53 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total num]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total number of distinct solutions.</p>
</blockquote>
<h2 id="分析">分析</h2><p>跟<a href="/2015/09/15/n-queens/">上一题</a>其实完全一样，不用维护路径，只用一个全局变量计数就可以了。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, depth, diag1, diag2, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == depth:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = depth</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[y] <span class="keyword">and</span> <span class="keyword">not</span> diag1[x + y] <span class="keyword">and</span> <span class="keyword">not</span> diag2[x - y + n - <span class="number">1</span>]:</span><br><span class="line">                visited[y] = <span class="keyword">True</span></span><br><span class="line">                diag1[x + y] = <span class="keyword">True</span></span><br><span class="line">                diag2[x - y + n - <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">                self.dfs(n, depth + <span class="number">1</span>, diag1, diag2, visited)</span><br><span class="line">                visited[y] = <span class="keyword">False</span></span><br><span class="line">                diag1[x + y] = <span class="keyword">False</span></span><br><span class="line">                diag2[x - y + n - <span class="number">1</span>] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        diag1 = [<span class="keyword">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">        diag2 = [<span class="keyword">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">        visited = [<span class="keyword">False</span>] * n</span><br><span class="line">        self.dfs(n, <span class="number">0</span>, diag1, diag2, visited)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/n-queens-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-N Queens]]></title>
      <link>http://garfieldog.github.io/2015/09/15/n-queens/</link>
      <guid>http://garfieldog.github.io/2015/09/15/n-queens/</guid>
      <pubDate>Tue, 15 Sep 2015 08:28:17 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p><img src="/images/n-queens.png" alt="n-queens"></p>
<p>Given an integer n, return all distinct solutions ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p><img src="/images/n-queens.png" alt="n-queens"></p>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>For example,<br>There exist two distinct solutions to the 4-queens puzzle:</p>
<p>[<br> [“.Q..”,  // Solution 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p>
<p> [“..Q.”,  // Solution 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题非常经典，最基础的做法就是DFS回溯。还有很多优化加速的方法，比如对角线缓存法。</p>
<h2 id="代码">代码</h2><h3 id="回溯">回溯</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, path, y)</span>:</span></span><br><span class="line">        j = len(path)</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(path):</span><br><span class="line">            <span class="keyword">if</span> x == y <span class="keyword">or</span> y - j == x - i <span class="keyword">or</span> y + j == x + i:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == len(path):</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> self.check(path, i):</span><br><span class="line">                path.append(i)</span><br><span class="line">                self.dfs(n, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listToMaze</span><span class="params">(self, lst)</span>:</span></span><br><span class="line">        rs = []</span><br><span class="line">        n = len(lst)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">            rs.append(<span class="string">'.'</span> * x + <span class="string">'Q'</span> + <span class="string">'.'</span> * (n - x - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(n, path, rs)</span><br><span class="line">        <span class="keyword">return</span> [self.listToMaze(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
<h3 id="缓存对角线加速">缓存对角线加速</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, path, rs, diag1, diag2, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == len(path):</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = len(path)</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[y] <span class="keyword">and</span> <span class="keyword">not</span> diag1[x + y] <span class="keyword">and</span> <span class="keyword">not</span> diag2[x - y + n - <span class="number">1</span>]:</span><br><span class="line">                path.append(y)</span><br><span class="line">                visited[y] = <span class="keyword">True</span></span><br><span class="line">                diag1[x + y] = <span class="keyword">True</span></span><br><span class="line">                diag2[x - y + n - <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">                self.dfs(n, path, rs, diag1, diag2, visited)</span><br><span class="line">                visited[y] = <span class="keyword">False</span></span><br><span class="line">                diag1[x + y] = <span class="keyword">False</span></span><br><span class="line">                diag2[x - y + n - <span class="number">1</span>] = <span class="keyword">False</span></span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listToMaze</span><span class="params">(self, lst)</span>:</span></span><br><span class="line">        rs = []</span><br><span class="line">        n = len(lst)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">            rs.append(<span class="string">'.'</span> * x + <span class="string">'Q'</span> + <span class="string">'.'</span> * (n - x - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        diag1 = [<span class="keyword">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">        diag2 = [<span class="keyword">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">        visited = [<span class="keyword">False</span>] * n</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(n, path, rs, diag1, diag2, visited)</span><br><span class="line">        <span class="keyword">return</span> [self.listToMaze(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/n-queens/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Unique Paths II]]></title>
      <link>http://garfieldog.github.io/2015/09/15/unique-paths-2/</link>
      <guid>http://garfieldog.github.io/2015/09/15/unique-paths-2/</guid>
      <pubDate>Tue, 15 Sep 2015 07:28:07 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many uniq]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<p>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>The total number of unique paths is 2.</p>
<p>Note: m and n will be at most 100.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这次有障碍了，就不能简单用组合数解了。可以DFS，但是容易超时，可以把<a href="/2015/09/15/unique-paths/">上一题</a>的动态规划改一下，注意有障碍物的格子走法要处理为0。</p>
<h2 id="代码">代码</h2><h3 id="DFS(超时)">DFS(超时)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type obstacleGrid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == m - <span class="number">1</span> <span class="keyword">and</span> y == n - <span class="number">1</span>:</span><br><span class="line">                self.count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> x + <span class="number">1</span> &lt; m <span class="keyword">and</span> A[x + <span class="number">1</span>][y] == <span class="number">0</span>:</span><br><span class="line">                dfs(x + <span class="number">1</span>, y)</span><br><span class="line">            <span class="keyword">if</span> y + <span class="number">1</span> &lt; n <span class="keyword">and</span> A[x][y + <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                dfs(x, y + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        A = obstacleGrid</span><br><span class="line">        m = len(A)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(A[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
<h3 id="动态规划">动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type obstacleGrid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        A = obstacleGrid</span><br><span class="line">        m = len(A)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(A[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m)]</span><br><span class="line">        dp[m - <span class="number">1</span>][n - <span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> A[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i][n - <span class="number">1</span>] == <span class="number">0</span> <span class="keyword">and</span> dp[i + <span class="number">1</span>][n - <span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                dp[i][n - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[m - <span class="number">1</span>][j] == <span class="number">0</span> <span class="keyword">and</span> dp[m - <span class="number">1</span>][j + <span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                dp[m - <span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[i][j] == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/unique-paths-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Unique Paths]]></title>
      <link>http://garfieldog.github.io/2015/09/15/unique-paths/</link>
      <guid>http://garfieldog.github.io/2015/09/15/unique-paths/</guid>
      <pubDate>Tue, 15 Sep 2015 07:10:50 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>T]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<p><img src="/images/robot.png" alt="robot.png"><br>Above is a 3 x 7 grid. How many possible unique paths are there?</p>
<p>Note: m and n will be at most 100.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这个很容易看出来动态规划的解。用<code>dp[i][j]</code>表示从坐标<code>(i, j)</code>到终点坐标有多少种走法，可知<code>dp[i][j] = dp[i+1][j] + dp[i][j+1]</code>。从下到上，从右到左扫表即可。时间<code>O(mn)</code>，空间<code>O(mn)</code>。</p>
<p>其实，还有一个更漂亮的解，从<code>(0, 0)</code>到<code>(m, n)</code>需要走<code>m + n - 2</code>步，而其中有<code>m - 1</code>步是向下的，<code>n - 1</code>步是向右的。可知解为 $ \binom{ m + n - 2 }{ m - 1 } $</p>
<h2 id="代码">代码</h2><h3 id="动态规划">动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            dp[i][n - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">            dp[m - <span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="组合数">组合数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nCr</span><span class="params">(self, n, r)</span>:</span></span><br><span class="line">        f = math.factorial</span><br><span class="line">        <span class="keyword">return</span> f(n) / f(n - r) / f(r)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.nCr(m + n - <span class="number">2</span>, m - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/unique-paths/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Palindrome Partitioning II]]></title>
      <link>http://garfieldog.github.io/2015/09/15/palindrome-partitioning-2/</link>
      <guid>http://garfieldog.github.io/2015/09/15/palindrome-partitioning-2/</guid>
      <pubDate>Tue, 15 Sep 2015 06:00:12 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return t]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return the minimum cuts needed for a palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return 1 since the palindrome partitioning [“aa”,”b”] could be produced using 1 cut.</p>
</blockquote>
<h2 id="分析">分析</h2><p>是<a href="/2015/09/15/palindrome-partitioning/">上一题</a>的升级版，要求找到最小划分。<br>采用动态规划法，设<code>f(i, j)</code>为<code>s[i:j+1]</code>之间最小的切割数，则有<code>f(i, j) = min(f(i, k) + f(k + 1, j)), i&lt;=k&lt;j</code>。可以把这个递推条件转化为一维的，另<code>dp[i]</code>表示<code>s[0:i]</code>的最小切割数，则<code>dp[i] = min(dp[j] + 1), 0&lt;=j&lt;i</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        isPal = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i, n):</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &gt; j - <span class="number">1</span> <span class="keyword">or</span> isPal[i + <span class="number">1</span>][j - <span class="number">1</span>]) <span class="keyword">and</span> s[i] == s[j]:</span><br><span class="line">                    isPal[i][j] = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> isPal[j][i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i] = min(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/palindrome-partitioning-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Palindrome Partitioning]]></title>
      <link>http://garfieldog.github.io/2015/09/15/palindrome-partitioning/</link>
      <guid>http://garfieldog.github.io/2015/09/15/palindrome-partitioning/</guid>
      <pubDate>Tue, 15 Sep 2015 01:50:08 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return a]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s, partition s such that every substring of the partition is a palindrome.</p>
<p>Return all possible palindrome partitioning of s.</p>
<p>For example, given s = “aab”,<br>Return</p>
<p>  [<br>    [“aa”,”b”],<br>    [“a”,”a”,”b”]<br>  ]</p>
</blockquote>
<h2 id="分析">分析</h2><p>一个长度为<code>n</code>的字符串有<code>n - 1</code>个空隙，每个空隙可以选择切还是不切，所以共有<code>2 ^ (n - 1)</code>种划分。使用回溯法，时间复杂度<code>O(n*2^n)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">            <span class="keyword">if</span> s[start] != s[end]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">            end -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path, rs, start)</span>:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> start == n:</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start, n):</span><br><span class="line">            <span class="keyword">if</span> self.isPalindrome(s, start, i):</span><br><span class="line">                path.append(s[start: i + <span class="number">1</span>])</span><br><span class="line">                self.dfs(s, path, rs, i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [[]]</span><br><span class="line">        path = []</span><br><span class="line">        rs = []</span><br><span class="line">        self.dfs(s, path, rs, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/palindrome-partitioning/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Surrounded Regions]]></title>
      <link>http://garfieldog.github.io/2015/09/14/surrounded-regions/</link>
      <guid>http://garfieldog.github.io/2015/09/14/surrounded-regions/</guid>
      <pubDate>Mon, 14 Sep 2015 11:11:24 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a 2D board containing ‘X’ and ‘O’, capture all regions surrounded by ‘X’.</p>
<p>A region is captur]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a 2D board containing ‘X’ and ‘O’, capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>For example,<br>X X X X<br>X O O X<br>X X O X<br>X O X X<br>After running your function, the board should be:</p>
<p>X X X X<br>X X X X<br>X X X X<br>X O X X</p>
</blockquote>
<h2 id="分析">分析</h2><p>有点像苹果棋的规则。如果一个<code>O</code>能够沿着<code>O</code>构成的路径通往边界，它就是安全的（不会被<code>X</code>掉）。我们从边缘四周的<code>O</code>开始做深度或广度优先遍历，把安全的<code>O</code>都标记起来。</p>
<h2 id="代码">代码</h2><h3 id="BFS（会超时）">BFS（会超时）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, board, i, j)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= m <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> board[x][y] != <span class="string">'O'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        m = len(board)</span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">if</span> is_valid(i, j):</span><br><span class="line">            q.append((i, j))</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            board[x][y] = <span class="string">'*'</span></span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> [(x - <span class="number">1</span>, y), (x + <span class="number">1</span>, y), (x, y - <span class="number">1</span>), (x, y + <span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> is_valid(i, j):</span><br><span class="line">                    q.append((i, j))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type board: List[List[str]]</span><br><span class="line">        :rtype: void Do not return anything, modify board in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        m = len(board)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            self.bfs(board, i, <span class="number">0</span>)</span><br><span class="line">            self.bfs(board, i, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">            self.bfs(board, <span class="number">0</span>, j)</span><br><span class="line">            self.bfs(board, m - <span class="number">1</span>, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">'*'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br></pre></td></tr></table></figure>
<h3 id="优化后的BFS">优化后的BFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type board: List[List[str]]</span><br><span class="line">        :rtype: void Do not return anything, modify board in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= m <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> board[x][y] != <span class="string">'O'</span> <span class="keyword">or</span> visited[x][y]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        m = len(board)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        visited = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m)]</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">if</span> is_valid(i, <span class="number">0</span>):</span><br><span class="line">                q.append((i, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">if</span> is_valid(i, n - <span class="number">1</span>):</span><br><span class="line">                q.append((i, n - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> is_valid(<span class="number">0</span>, j):</span><br><span class="line">                q.append((<span class="number">0</span>, j))</span><br><span class="line">            <span class="keyword">if</span> is_valid(m - <span class="number">1</span>, j):</span><br><span class="line">                q.append((m - <span class="number">1</span>, j))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            x, y = q.popleft()</span><br><span class="line">            board[x][y] = <span class="string">'*'</span></span><br><span class="line">            visited[x][y] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">for</span> i, j <span class="keyword">in</span> [(x - <span class="number">1</span>, y), (x + <span class="number">1</span>, y), (x, y - <span class="number">1</span>), (x, y + <span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> is_valid(i, j):</span><br><span class="line">                    q.append((i, j))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'O'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">'*'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/14/surrounded-regions/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Word Ladder II]]></title>
      <link>http://garfieldog.github.io/2015/09/14/word-ladder-2/</link>
      <guid>http://garfieldog.github.io/2015/09/14/word-ladder-2/</guid>
      <pubDate>Mon, 14 Sep 2015 08:18:05 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two words (start and end), and a dictionary’s word list, find all shortest transformation sequence(]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two words (start and end), and a dictionary’s word list, find all shortest transformation sequence(s) from start to end, such that:</p>
<p>Only one letter can be changed at a time<br>Each intermediate word must exist in the word list<br>For example,</p>
<p>Given:<br>start = “hit”<br>end = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>Return<br>  [<br>    [“hit”,”hot”,”dot”,”dog”,”cog”],<br>    [“hit”,”hot”,”lot”,”log”,”cog”]<br>  ]<br>Note:<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题比较难，要把所有的最短路径都找出来。其实本质上就是标准的求的图两点间最小路径。先BFS遍历记录路径信息，再DFS反向构建路径。</p>
<p>难点在于第一要维护路径的信息，第二不能像上一题那样直接从字典中删掉入列的词（因为它可能存在于两条最短路径上）。写了很久没有写对，先放一个<a href="https://leetcode.com/discuss/24191/defaultdict-for-traceback-and-easy-writing-lines-python-code" target="_blank" rel="external">别人的正确答案</a>，解法很漂亮，回头详细分析。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLadders</span><span class="params">(self, start, end, wordlist)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type start: str</span><br><span class="line">        :type end: str</span><br><span class="line">        :type wordlist: Set[str]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        wordlist.add(end)</span><br><span class="line">        level = &#123;start&#125;</span><br><span class="line">        parents = defaultdict(set)  <span class="comment"># pre-node in shortest paths</span></span><br><span class="line">        <span class="keyword">while</span> level <span class="keyword">and</span> end <span class="keyword">not</span> <span class="keyword">in</span> parents:</span><br><span class="line">            next_level = defaultdict(set)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> level:</span><br><span class="line">                <span class="keyword">for</span> char <span class="keyword">in</span> string.ascii_lowercase:</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(start)):</span><br><span class="line">                        n = node[:i] + char + node[i + <span class="number">1</span>:]</span><br><span class="line">                        <span class="keyword">if</span> n <span class="keyword">in</span> wordlist <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> parents:</span><br><span class="line">                            next_level[n].add(node)</span><br><span class="line">            level = next_level  <span class="comment"># actually it means `level = next_level.keys()`</span></span><br><span class="line">            parents.update(next_level)</span><br><span class="line">        res = [[end]]</span><br><span class="line">        <span class="keyword">while</span> res <span class="keyword">and</span> res[<span class="number">0</span>][<span class="number">0</span>] != start:</span><br><span class="line">            res = [[p] + r <span class="keyword">for</span> r <span class="keyword">in</span> res <span class="keyword">for</span> p <span class="keyword">in</span> parents[r[<span class="number">0</span>]]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/14/word-ladder-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Word Ladder]]></title>
      <link>http://garfieldog.github.io/2015/09/14/word-ladder/</link>
      <guid>http://garfieldog.github.io/2015/09/14/word-ladder/</guid>
      <pubDate>Mon, 14 Sep 2015 07:40:06 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two words (beginWord and endWord), and a dictionary, find the length of shortest transformation seq]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two words (beginWord and endWord), and a dictionary, find the length of shortest transformation sequence from beginWord to endWord, such that:</p>
<p>Only one letter can be changed at a time<br>Each intermediate word must exist in the dictionary<br>For example,</p>
<p>Given:<br>start = “hit”<br>end = “cog”<br>dict = [“hot”,”dot”,”dog”,”lot”,”log”]<br>As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p>
<p>Note:<br>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.</p>
</blockquote>
<h2 id="分析">分析</h2><p>寻找最短变换路径，使用广度优先遍历。好好想一想这样找到的路径为什么可以保证是最短的。时间复杂度。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type beginWord: str</span><br><span class="line">        :type endWord: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        al = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line">        q = deque()</span><br><span class="line">        d = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> beginWord:</span><br><span class="line">            q.append(beginWord)</span><br><span class="line">            q.append(<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">        wordDict.add(endWord)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                <span class="keyword">if</span> cur == endWord:</span><br><span class="line">                    <span class="keyword">return</span> d + <span class="number">1</span></span><br><span class="line">                arr = list(cur)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(arr)):</span><br><span class="line">                    <span class="keyword">for</span> c <span class="keyword">in</span> al:</span><br><span class="line">                        <span class="keyword">if</span> arr[i] == c:</span><br><span class="line">                            <span class="keyword">continue</span></span><br><span class="line">                        tmp = arr[i]</span><br><span class="line">                        arr[i] = c</span><br><span class="line">                        new_word = <span class="string">''</span>.join(arr)</span><br><span class="line">                        <span class="keyword">if</span> new_word <span class="keyword">in</span> wordDict:</span><br><span class="line">                            q.append(new_word)</span><br><span class="line">                            wordDict.remove(new_word)</span><br><span class="line">                        arr[i] = tmp</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    q.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/14/word-ladder/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Letter Combinations of a Phone Number]]></title>
      <link>http://garfieldog.github.io/2015/09/14/letter-combinations-of-a-phone-number/</link>
      <guid>http://garfieldog.github.io/2015/09/14/letter-combinations-of-a-phone-number/</guid>
      <pubDate>Mon, 14 Sep 2015 07:17:47 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A m]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a digit string, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below.<br><img src="/images/phone.png" alt="phone.png"></p>
<p>Input:Digit string “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].<br>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
</blockquote>
<h2 id="分析">分析</h2><p>依然回溯法。回溯法其实就是n叉树的深度优先遍历。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    keyboard = &#123;</span><br><span class="line">        <span class="string">'2'</span>: <span class="string">'abc'</span>,</span><br><span class="line">        <span class="string">'3'</span>: <span class="string">'def'</span>,</span><br><span class="line">        <span class="string">'4'</span>: <span class="string">'ghi'</span>,</span><br><span class="line">        <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">        <span class="string">'6'</span>: <span class="string">'mno'</span>,</span><br><span class="line">        <span class="string">'7'</span>: <span class="string">'pqrs'</span>,</span><br><span class="line">        <span class="string">'8'</span>: <span class="string">'tuv'</span>,</span><br><span class="line">        <span class="string">'9'</span>: <span class="string">'wxyz'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, digits, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(digits) == len(path):</span><br><span class="line">            rs.append(<span class="string">''</span>.join(path))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        n = len(path)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.keyboard.get(digits[n], <span class="string">''</span>):</span><br><span class="line">            path.append(c)</span><br><span class="line">            self.dfs(digits, path, rs)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type digits: str</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        path = []</span><br><span class="line">        rs = []</span><br><span class="line">        self.dfs(digits, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/14/letter-combinations-of-a-phone-number/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Combinations]]></title>
      <link>http://garfieldog.github.io/2015/09/14/combinations/</link>
      <guid>http://garfieldog.github.io/2015/09/14/combinations/</guid>
      <pubDate>Mon, 14 Sep 2015 06:48:12 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>For exampl]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>For example,<br>If n = 4 and k = 2, a solution is:</p>
<p>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>典型的回溯法。时间<code>O(n!)</code>，空间<code>O(n)</code>。注意组合数和排列数不同，[1, 2] 和[2, 1]是同一个组合，不要加重了。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, k, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == k:</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> path <span class="keyword">or</span> path[-<span class="number">1</span>] &lt; i:</span><br><span class="line">                path.append(i)</span><br><span class="line">                self.dfs(n, k, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        path = []</span><br><span class="line">        rs = []</span><br><span class="line">        self.dfs(n, k, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="递归（稍作优化）">递归（稍作优化）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, k, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == k:</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        start = path[-<span class="number">1</span>] + <span class="number">1</span> <span class="keyword">if</span> path <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start, n + <span class="number">1</span>):</span><br><span class="line">            path.append(i)</span><br><span class="line">            self.dfs(n, k, path, rs)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        path = []</span><br><span class="line">        rs = []</span><br><span class="line">        self.dfs(n, k, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/14/combinations/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Permutations II]]></title>
      <link>http://garfieldog.github.io/2015/09/14/permutations-2/</link>
      <guid>http://garfieldog.github.io/2015/09/14/permutations-2/</guid>
      <pubDate>Mon, 14 Sep 2015 03:49:16 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>For example,<br>[1,1,2] have the following unique permutations:<br>[1,1,2], [1,2,1], and [2,1,1].</p>
</blockquote>
<h2 id="分析">分析</h2><p>这次数组中有重复值，用<code>next permutation</code>法的话，上一题<a href="/2015/09/14/permutations/">Permutations</a>的答案可以直接用。DFS的话要判断当前元素被用了几次。</p>
<h2 id="代码">代码</h2><h3 id="Next_Permutation">Next Permutation</h3><p>见<a href="/2015/09/14/permutations/">Permutations</a>。</p>
<h3 id="DFS">DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, items, n, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == len(path):</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> items:</span><br><span class="line">            c = path.count(k)</span><br><span class="line">            <span class="keyword">if</span> c &lt; v:</span><br><span class="line">                path.append(k)</span><br><span class="line">                self.dfs(items, n, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        count = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            count.setdefault(x, <span class="number">0</span>)</span><br><span class="line">            count[x] += <span class="number">1</span></span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        n = len(nums)</span><br><span class="line">        items = count.items()</span><br><span class="line">        self.dfs(items, n, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/14/permutations-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Permutations]]></title>
      <link>http://garfieldog.github.io/2015/09/14/permutations/</link>
      <guid>http://garfieldog.github.io/2015/09/14/permutations/</guid>
      <pubDate>Mon, 14 Sep 2015 02:56:24 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of numbers, return all possible permutations.</p>
<p>For example,<br>[1,2,3] have the ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of numbers, return all possible permutations.</p>
<p>For example,<br>[1,2,3] have the following permutations:<br>[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1].</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们之前做过一道<a href="/2015/08/21/next-permutation/">Next Permutation</a>的题，稍加改动其实就可以了。还可以深度搜索来做。</p>
<h2 id="代码">代码</h2><h3 id="Next_Permutation">Next Permutation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        pivot = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                pivot = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> pivot &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[pivot]:</span><br><span class="line">                nums[pivot], nums[i] = nums[i], nums[pivot]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        self.reverse(nums, pivot + <span class="number">1</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        t = (j - i + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(t):</span><br><span class="line">            nums[i + k], nums[j - k] = nums[j - k], nums[i + k]  <span class="comment"># swap</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            rs.append(nums[:])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.nextPermutation(nums):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="DFS">DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == len(nums):</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> path:</span><br><span class="line">                path.append(x)</span><br><span class="line">                self.dfs(nums, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(nums, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/14/permutations/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Subsets II]]></title>
      <link>http://garfieldog.github.io/2015/09/11/subsets-2/</link>
      <guid>http://garfieldog.github.io/2015/09/11/subsets-2/</guid>
      <pubDate>Fri, 11 Sep 2015 08:38:32 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets.</p>
<p>N]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets.</p>
<p>Note:<br>Elements in a subset must be in non-descending order.<br>The solution set must not contain duplicate subsets.<br>For example,<br>If nums = [1,2,2], a solution is:</p>
<p>[<br>  [2],<br>  <a href="/2015/09/11/subsets/">1</a>,<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/09/11/subsets/">Subsets</a>做法基本一样，只是要注意去掉多余的子集。这里采用的方法是，判断当前元素是否和上个元素相等，如果相等，则只扩展上次添加了的子集们，如果不等，就扩展全部。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums</span></span><br><span class="line">    <span class="comment"># @return &#123;integer[][]&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        rs = [[]]</span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        last_s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            s = len(rs)</span><br><span class="line">            start = last_s <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(start, s):</span><br><span class="line">                rs.append([nums[i]] + rs[j])</span><br><span class="line">            last_s = s</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/subsets-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Subsets]]></title>
      <link>http://garfieldog.github.io/2015/09/11/subsets/</link>
      <guid>http://garfieldog.github.io/2015/09/11/subsets/</guid>
      <pubDate>Fri, 11 Sep 2015 08:25:33 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of distinct integers, nums, return all possible subsets.</p>
<p>Note:<br>Elements in a subset]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of distinct integers, nums, return all possible subsets.</p>
<p>Note:<br>Elements in a subset must be in non-descending order.<br>The solution set must not contain duplicate subsets.<br>For example,<br>If nums = [1,2,3], a solution is:</p>
<p>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>生成全部子集，递归很容易，改成迭代也不难，时间<code>O(2^n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [[]]</span><br><span class="line">        nums.sort()</span><br><span class="line">        subsets = self.subsets(nums[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(subsets)):</span><br><span class="line">            subsets.append(nums[:<span class="number">1</span>] + subsets[i])</span><br><span class="line">        <span class="keyword">return</span> subsets</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        rs = [[]]</span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            n = len(rs)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">                rs.append([x] + rs[i])</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/subsets/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Search a 2D Matrix II]]></title>
      <link>http://garfieldog.github.io/2015/09/11/search-a-2d-matrix-2/</link>
      <guid>http://garfieldog.github.io/2015/09/11/search-a-2d-matrix-2/</guid>
      <pubDate>Fri, 11 Sep 2015 07:56:13 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,</p>
<p>Consider the following matrix:</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>Given target = 5, return true.</p>
<p>Given target = 20, return false.</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/11/search-a-2d-matrix/">上一题</a>的升级版。这次矩阵每一行是排序的，每一列也是排序的，但不保证前一行的所有数小于后一行的。仍然使用二分查找，不过每次只能剔除<code>1/4</code>的元素。(如果中心值比目标大，则剔除右下角的矩阵块，如果小，则剔除左上角)</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrixR</span><span class="params">(self, matrix, x1, y1, x2, y2, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x1 &gt; x2 <span class="keyword">or</span> y1 &gt; y2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mid_x = x1 + (x2 - x1) / <span class="number">2</span></span><br><span class="line">        mid_y = y1 + (y2 - y1) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> matrix[mid_x][mid_y] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> matrix[mid_x][mid_y] &gt; target:</span><br><span class="line">            <span class="keyword">return</span> self.searchMatrixR(matrix, x1, y1, mid_x - <span class="number">1</span>, y2, target) <span class="keyword">or</span> \</span><br><span class="line">                self.searchMatrixR(matrix, mid_x, y1, x2, mid_y - <span class="number">1</span>, target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.searchMatrixR(matrix, x1, mid_y + <span class="number">1</span>, mid_x, y2, target) <span class="keyword">or</span> \</span><br><span class="line">                self.searchMatrixR(matrix, mid_x + <span class="number">1</span>, y1, x2, y2, target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> self.searchMatrixR(matrix, <span class="number">0</span>, <span class="number">0</span>, m - <span class="number">1</span>, n - <span class="number">1</span>, target)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/search-a-2d-matrix-2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
