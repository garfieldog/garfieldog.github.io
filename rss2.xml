<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Sat, 22 Aug 2015 08:46:37 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Permutation Sequence]]></title>
      <link>http://garfieldog.github.io/2015/08/22/permutation-sequence/</link>
      <guid>http://garfieldog.github.io/2015/08/22/permutation-sequence/</guid>
      <pubDate>Sat, 22 Aug 2015 07:33:28 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.</p>
<p>Note: Given n will be between 1 and 9 inclusive.</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们在上一题<a href="/2015/08/21/next-permutation">Next Permutation</a>得出了给定一个排列求下一个排列的解法。那对于这道题，最直接的办法，就是从第一个排列开始，调用<code>k - 1</code>次<code>next permutation</code>嘛，这样的解法时间复杂度是<code>O(n^2)</code>。但这样显然有许多浪费，我们只要<code>第k个</code>，而不需要<code>前k个</code>，有没有更快的方法呢？</p>
<h3 id="康托展开">康托展开</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80" target="_blank" rel="external">康托展开</a>是一个全排列到一个自然数的双射，给定一个排列，可以计算出它在所有由小到大全排列中的顺序，并且这个计算是可逆的，这不正是我们要的么？康托展开的公式是<br>$$ X = a_n(n-1)! + a_{n-1}(n-2)! + … + a_1 \cdot 0! $$<br>维基百科<a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80" target="_blank" rel="external">康托展开</a>条目下的例子很好，我们直接拿来用：</p>
<blockquote>
<p>例如，3 5 7 4 1 2 9 6 8 展开为 98884。因为<code>X=2*8!+3*7!+4*6!+2*5!+0*4!+0*3!+2*2!+0*1!+0*0!=98884</code>.<br>解释：<br>排列的第一位是3，比3小的数有两个，以这样的数开始的排列有8!个，因此第一项为<code>2*8!</code><br>排列的第二位是5，比5小的数有1、2、3、4，由于3已经出现，因此共有3个比5小的数，这样的排列有7!个，因此第二项为<code>3*7!</code><br>以此类推，直至<code>0*0!</code></p>
</blockquote>
<p>在这里我们需要的是康托展开的逆运算，就是给定X，求原排列。同样我们引用维基的例子：</p>
<blockquote>
<p>给定n=5, x=96,<br>首先用96-1得到95，说明x之前有95个排列.(将此数本身减去！)<br>用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.<br>用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.<br>用5去除2!得到2余1，类似地，这一位是3.<br>用1去除1!得到1余0，这一位是2.<br>最后一位只能是1.<br>所以这个数是45321.</p>
</blockquote>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            x *= i</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        a = k - <span class="number">1</span></span><br><span class="line">        seq = range(<span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line">        rs = []</span><br><span class="line">        f = self.factorial(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>):</span><br><span class="line">            r = seq[a / f]</span><br><span class="line">            seq.remove(r)</span><br><span class="line">            rs.append(r)</span><br><span class="line">            a = a % f</span><br><span class="line">            f /= n - <span class="number">1</span> - i</span><br><span class="line">        rs.append(seq[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/22/permutation-sequence/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Next Permutation]]></title>
      <link>http://garfieldog.github.io/2015/08/21/next-permutation/</link>
      <guid>http://garfieldog.github.io/2015/08/21/next-permutation/</guid>
      <pubDate>Fri, 21 Aug 2015 03:07:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
</blockquote>
<p>给定一个序列，求下一个排列形式（按字典序）。例如一个集合<code>{1, 2, 3}</code>，它的全排列有6种，按字典顺序：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>如果给定序列<code>1 3 2</code>，那么下一个排列就是<code>2 1 3</code>，如果给定最后一个排列<code>3 2 1</code>，应该返回第一个排列<code>1 2 3</code>。要求空间复杂度<code>O(1)</code>。也就是说不能开新数组，需要inplace进行替换。</p>
<h2 id="分析">分析</h2><p>搞清楚排列数的规律，可以用以下算法完成：</p>
<ol>
<li>从右向左扫描数组，找到第一个破坏升序(从右向左升序)规律的下标<code>pivot</code>。下一个排列不需要改变pivot左边的序列(想想为什么)。如果找不到pivot，也就是说数组整体是倒序了，那说明是最后一个排列，翻转成第一个排列就好了。</li>
<li>这个时候我们知道要重新排列pivot右边的序列，这个序列（不包括pivot）是从左到右降序的。下一个排列在pivot位置上的数，应该是右边序列中比pivot上的数大的最小的数(想想为什么)。因此我们再次从右向左扫描数组（也可以二分查找），找到第一个比pivot大的数，交换它和pivot上的数。</li>
<li>这时候，pivot位置右侧的序列仍然是降序的，我们翻转这个序列（变成升序的），这时候数组中的值就构成了下一个排列。</li>
</ol>
<p>这个算法的时间复杂度是<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: void Do not return anything, modify nums in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        pivot = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                pivot = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pivot &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[pivot]:</span><br><span class="line">                    nums[pivot], nums[i] = nums[i], nums[pivot]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        self.reverse(nums, pivot + <span class="number">1</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        t = (j - i + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(t):</span><br><span class="line">            nums[i + k], nums[j - k] = nums[j - k], nums[i + k]  <span class="comment"># swap</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/21/next-permutation/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Element]]></title>
      <link>http://garfieldog.github.io/2015/08/21/remove-element/</link>
      <guid>http://garfieldog.github.io/2015/08/21/remove-element/</guid>
      <pubDate>Fri, 21 Aug 2015 02:49:09 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p>删除数组中的给定元素。</p>
<h2 id="分析">分析</h2><p>这是一道简单题，使用两指针，一个记录当前有效数组的尾部，一个遍历原数组。这样做的正确性在于，第一个指针之后、第二个指针之前的数组空间肯定是<code>安全的</code>（要么已经被复制到第一个指针之前的区域，要么是要删掉的值）。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type val: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n != val:</span><br><span class="line">                nums[i] = n</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/21/remove-element/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-4Sum]]></title>
      <link>http://garfieldog.github.io/2015/08/21/4-sum/</link>
      <guid>http://garfieldog.github.io/2015/08/21/4-sum/</guid>
      <pubDate>Fri, 21 Aug 2015 01:56:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:<br>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)<br>The solution set must not contain duplicate quadruplets.<br>For example, given array S = {1 0 -1 0 -2 2}, and target = 0.</p>
<p>A solution set is:<br>(-1,  0, 0, 1)<br>(-2, -1, 1, 2)<br>(-2,  0, 0, 2)</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/08/20/3-sum/">3Sum</a>可以用一样的两指针夹逼解法，时间复杂度<code>O(n^3)</code>，空间复杂度O(1)。还可以用空间换时间，用一个哈希表去缓存两数之和，时间复杂度平均降到<code>O(n^2)</code>，最坏<code>O(n^4)</code>(即所有元素都相等的时候)，空间复杂度<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="两指针法">两指针法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of length 4, [[val1,val2,val3,val4]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        rs = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, len(nums) - <span class="number">2</span>):</span><br><span class="line">                k = j + <span class="number">1</span></span><br><span class="line">                r = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> k &lt; r:</span><br><span class="line">                    s = nums[i] + nums[j] + nums[k] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> s == target:</span><br><span class="line">                        rs.add((nums[i], nums[j], nums[k], nums[r]))</span><br><span class="line">                        k += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> s &gt; target:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [list(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
<h3 id="哈希表加速">哈希表加速</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of length 4, [[val1,val2,val3,val4]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        rs = set()</span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                cache.setdefault(nums[i] + nums[j], []).append((i, j))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">for</span> k, r <span class="keyword">in</span> cache.get(target - nums[i] - nums[j], []):</span><br><span class="line">                    <span class="keyword">if</span> j &lt; k:  <span class="comment"># notice: think about this condition</span></span><br><span class="line">                        rs.add((nums[i], nums[j], nums[k], nums[r]))</span><br><span class="line">        <span class="keyword">return</span> [list(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/21/4-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-3Sum Closest]]></title>
      <link>http://garfieldog.github.io/2015/08/20/3sum-closest/</link>
      <guid>http://garfieldog.github.io/2015/08/20/3sum-closest/</guid>
      <pubDate>Thu, 20 Aug 2015 05:33:43 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<p>和上一题<a href="/2015/08/20/3-sum/">3Sum</a>基本设定一样，不过这次要求找到与<code>target</code>最相近的三数之和。返回和的值即可，不需要给出所有组合。</p>
<h2 id="分析">分析</h2><p>沿用<a href="/2015/08/20/3-sum/">3Sum</a>的解法，用一个变量维护当前最小绝对差值即可。时间复杂度<code>O(n^2)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ret = <span class="keyword">None</span></span><br><span class="line">        cur_diff = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">2</span>):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">elif</span> s &gt; target:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur_diff <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> cur_diff &gt; abs(s - target):</span><br><span class="line">                    cur_diff = abs(s - target)</span><br><span class="line">                    ret = s</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/20/3sum-closest/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-3Sum]]></title>
      <link>http://garfieldog.github.io/2015/08/20/3-sum/</link>
      <guid>http://garfieldog.github.io/2015/08/20/3-sum/</guid>
      <pubDate>Thu, 20 Aug 2015 03:24:10 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:<br>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.<br>For example, given array S = {-1 0 1 2 -1 -4},</p>
<p>A solution set is:<br>(-1, 0, 1)<br>(-1, -1, 2)</p>
</blockquote>
<p>和上一题<a href="/2015/08/20/two-sum/">Two Sum</a>有点类似，不过变成了找3个数加和等于给定的数字（这里是0）。需要返回数字本身而不是下标。</p>
<h2 id="分析">分析</h2><p>如果我们固定一个数，那就转换成了<a href="/2015/08/20/two-sum/">Tow Sum</a>问题，所以，简单的解法就是遍历数组，固定当前数字，然后用<a href="/2015/08/20/two-sum/">Two Sum</a>的解法，时间和空间复杂度都是<code>O(n^2)</code>。</p>
<p>还可以用一种更通用的解法，适用于<code>k-Sum</code>问题，排序数组，然后用<code>k-2</code>个循环遍历数组，在最内层循环用两个指针左右夹逼找到解。时间复杂度<code>O(max(nlog(n), n^(k-1))</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of length 3, [[val1,val2,val3]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        rs = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">2</span>):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                    rs.add((nums[i], nums[j], nums[k]))</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [list(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/20/3-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Two Sum]]></title>
      <link>http://garfieldog.github.io/2015/08/20/two-sum/</link>
      <guid>http://garfieldog.github.io/2015/08/20/two-sum/</guid>
      <pubDate>Thu, 20 Aug 2015 02:57:43 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>Th]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单的做法就是用哈希表存储数字和它在数组中的下标，然后扫描一遍数组即可。时间复杂度O(n)，空间复杂度O(n)。题目中没有说明数组中有没有重复，如果有重复的数字这个算法还有效吗？乍一看是不对的，但其实仍然是有效的，因为构建哈希表我们是按照数组顺序遍历的，所以如果一个数字出现在多个位置，那哈希表中它存储的下标一定是最大的那个，这样一来，第二次扫描数组，如果<code>target = 2 * A[i]</code>，在哈希表中查找<code>A[i]</code>，得到的下标<code>j</code>一定大于<code>i</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a tuple, (index1, index2)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        d = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums)&#125;</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            j = d.get(target - x)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">and</span> j &gt; i:  <span class="comment"># notice: the condition is important</span></span><br><span class="line">                <span class="keyword">return</span> (i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/20/two-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-最长连续序列]]></title>
      <link>http://garfieldog.github.io/2015/08/19/longest-consecutive-sequence/</link>
      <guid>http://garfieldog.github.io/2015/08/19/longest-consecutive-sequence/</guid>
      <pubDate>Wed, 19 Aug 2015 15:51:57 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
</blockquote>
<p>给定一个未排序的整形数组，求出<code>最长连续元素序列</code>的长度。比如，给定数组<code>[100, 4, 200, 1, 3, 2]</code>，最长连续子序列为<code>[1, 2, 3, 4]</code>，长度为4。要求时间复杂度O(n)。</p>
<h2 id="分析">分析</h2><p>要求O(n)时间复杂度，就不能对数组排序，可以尝试用哈希表记录出现的元素。然后第二次遍历原数组，对每个元素，采用从中间向两边扩散的方式查找它的<code>相邻数</code>在不在哈希表中，一旦断掉就停止扩张，记录最长的序列长度。注意，要保证时间是O(n)的，就要记录元素有没有被<code>使用过</code>，被使用过的元素就不在进行判断，保证一个元素只被访问一次。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums</span></span><br><span class="line">    <span class="comment"># @return &#123;integer&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        d = &#123;n: <span class="keyword">True</span> <span class="keyword">for</span> n <span class="keyword">in</span> nums&#125;</span><br><span class="line">        cur_max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> d.get(n):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            d[n] = <span class="keyword">False</span></span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            cur_num = n + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> d.get(cur_num):</span><br><span class="line">                d[cur_num] = <span class="keyword">False</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur_num += <span class="number">1</span></span><br><span class="line">            cur_num = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> d.get(cur_num):</span><br><span class="line">                d[cur_num] = <span class="keyword">False</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur_num -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; cur_max_len:</span><br><span class="line">                cur_max_len = i</span><br><span class="line">        <span class="keyword">return</span> cur_max_len</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/19/longest-consecutive-sequence/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-找出两个有序数组的中位数]]></title>
      <link>http://garfieldog.github.io/2015/08/19/median-of-two-sorted-arrays/</link>
      <guid>http://garfieldog.github.io/2015/08/19/median-of-two-sorted-arrays/</guid>
      <pubDate>Wed, 19 Aug 2015 03:07:51 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sort]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
</blockquote>
<p>给定两个有序的数组，长度分别问m和n，把这两个数组看成一个整体，求中位数。要求时间复杂度O(log(m+n))。中位数的定义是，如果一个集合有奇数<code>2k + 1</code>个元素，那排序后第k个数就是中位数，如果有偶数<code>2k</code>个元素，那么中位数的定义为排序后第<code>k</code>个数和第<code>k+1</code>个数的平均值。</p>
<h2 id="分析">分析</h2><p>看时间复杂度的要求，首先想到的就是二分法，但是如何在两个数组上进行二分呢？我们把这个问题分解一下，先求解<code>在两个有序数组中查找整体第k大的数</code>，如果<code>m+n</code>是偶数，则调用两次子过程求平均，如果是奇数，调用一次。我们这样来找第k大的数：</p>
<ol>
<li>假设m和n都大于<code>k/2</code>，则比较<code>nums1[k/2 - 1]</code>和<code>nums2[k - k/2 - 1]</code></li>
<li>如果前者比较大，则可以扔掉<code>nums2[k - k/2 - 1]</code>之前的<code>k/2</code>个数</li>
<li>如果后者比较大，则可以扔掉<code>nums1[k/2 - 1]</code>之前的<code>k/2</code>个数</li>
<li>如果相等，说明第k个数已经找到</li>
</ol>
<p>如果m和n中有一个小于<code>k/2</code>呢？假设n比m小，那么就取<code>min(k/2, n)</code>和<code>k - min(k/2, n)</code>作为比较的下标值。<br>时间复杂度是O(log(k))。在写代码的过程中，边界判断是非常容易出错的，要反复练习。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums1</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums2</span></span><br><span class="line">    <span class="comment"># @return &#123;float&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        total = len(nums1) + len(nums2)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            c1 = self.findKthInSortedArrays(nums1, nums2, total / <span class="number">2</span>)</span><br><span class="line">            c2 = self.findKthInSortedArrays(nums1, nums2, total / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">            median = (c1 + c2) / <span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            median = float(self.findKthInSortedArrays(nums1, nums2, total / <span class="number">2</span> + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> median</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthInSortedArrays</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.findKthInSortedArraysR(nums1, <span class="number">0</span>, len(nums1) - <span class="number">1</span>,</span><br><span class="line">                                           nums2, <span class="number">0</span>, len(nums2) - <span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthInSortedArraysR</span><span class="params">(self, nums1, x1, y1, nums2, x2, y2, k)</span>:</span></span><br><span class="line">        m = y1 - x1 + <span class="number">1</span></span><br><span class="line">        n = y2 - x2 + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> m &lt; n:</span><br><span class="line">            <span class="keyword">return</span> self.findKthInSortedArraysR(nums2, x2, y2, nums1, x1, y1, k)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[x1 + k - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[x1], nums2[x2])</span><br><span class="line"></span><br><span class="line">        k2 = min(k / <span class="number">2</span>, n)</span><br><span class="line">        k1 = k - k2</span><br><span class="line">        <span class="keyword">if</span> nums1[x1 + k1 - <span class="number">1</span>] == nums2[x2 + k2 - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> nums1[x1 + k1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> nums1[x1 + k1 - <span class="number">1</span>] &gt; nums2[x2 + k2 - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findKthInSortedArraysR(nums1, x1, y1, nums2, x2 + k2, y2, k - k2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKthInSortedArraysR(nums1, x1 + k1, y1, nums2, x2, y2, k - k1)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/19/median-of-two-sorted-arrays/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-在被旋转的有序数组中查找目标II]]></title>
      <link>http://garfieldog.github.io/2015/08/19/search-in-rotated-sorted-array-2/</link>
      <guid>http://garfieldog.github.io/2015/08/19/search-in-rotated-sorted-array-2/</guid>
      <pubDate>Wed, 19 Aug 2015 02:25:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affe]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affect the run-time complexity? How and why?</p>
<p>Write a function to determine if a given target is in the array.</p>
</blockquote>
<p>基本设定和<a href="/2015/08/18/search-in-rotated-sorted-array/">上一题</a>一样，但允许重复元素。<br>另外，本题只需要输出<code>True</code> or <code>False</code>即可，不需要输出下标。</p>
<h2 id="分析">分析</h2><p>允许重复元素之后，<code>A[mid]</code>和<code>A[low]</code>就有可能相等，这种情况下我们就无法判断<code>A[mid]</code>是在哪个子数组中，这种情况下，我们可以简单地让<code>low</code>指针向前走一步。这样一来，算法最坏情况下时间复杂度增加到了O(n)，平均情况下仍然为O(log(n))。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_r</span><span class="params">(self, A, target, low, high)</span>:</span></span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> A[low] &lt; A[mid]:</span><br><span class="line">            <span class="comment"># A[mid] locates in the first sub-array</span></span><br><span class="line">            <span class="keyword">if</span> A[low] &lt;= target &lt; A[mid]:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, low, mid - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, mid + <span class="number">1</span>, high)</span><br><span class="line">        <span class="keyword">elif</span> A[low] == A[mid]:</span><br><span class="line">            <span class="keyword">return</span> self.search_r(A, target, low + <span class="number">1</span>, high)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># A[mid] locates in the second sub-array</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &lt; target &lt;= A[high]:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, mid + <span class="number">1</span>, high)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, low, mid - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.search_r(nums, target, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/19/search-in-rotated-sorted-array-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-在被旋转的有序数组中查找目标]]></title>
      <link>http://garfieldog.github.io/2015/08/18/search-in-rotated-sorted-array/</link>
      <guid>http://garfieldog.github.io/2015/08/18/search-in-rotated-sorted-array/</guid>
      <pubDate>Tue, 18 Aug 2015 15:33:09 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 mi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
</blockquote>
<p>一个有序的数组可能在某个位置被旋转，比如[0, 1, 2, 4, 5, 6, 7]在4这个数字位置上被旋转后变为[4, 5, 6, 7, 0, 1, 2]，给定一个目标元素，查找这个元素在数组中的下标，如果不存在，返回-1。假设数组中没有重复值。</p>
<h2 id="分析">分析</h2><p>在有序数组中查找目标，直接使用二分法即可。如果数组被旋转之后呢？考察这个数组的性质，它由两段有序子数组组成，并且，第一个子数组的任一个数都<code>大于</code>(因为数组没有重复值)第二个子数组的所有数。这样一来，我们仍然可以在这个数组上展开二分查找：当<code>A[mid] &gt; A[low]</code>时，我们知道mid肯定落在第一个子数组里，反则反之。这时候我们再对比<code>target</code>和<code>A[low]</code>, <code>A[mid]</code>, <code>A[high]</code>的大小，从而判断接下来在那个半区搜索。</p>
<p>难点在边界条件的判断。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_r</span><span class="params">(self, A, target, low, high)</span>:</span></span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> A[low] &lt;= A[mid]:</span><br><span class="line">            <span class="comment"># A[mid] locates in the first sub-array</span></span><br><span class="line">            <span class="keyword">if</span> A[low] &lt;= target &lt; A[mid]:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, low, mid - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, mid + <span class="number">1</span>, high)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># A[mid] locates in the second sub-array</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &lt; target &lt;= A[high]:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, mid + <span class="number">1</span>, high)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, low, mid - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.search_r(nums, target, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/18/search-in-rotated-sorted-array/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-去除有序数组中的重复元素II]]></title>
      <link>http://garfieldog.github.io/2015/08/18/remove-duplicates-from-sorted-array-2/</link>
      <guid>http://garfieldog.github.io/2015/08/18/remove-duplicates-from-sorted-array-2/</guid>
      <pubDate>Tue, 18 Aug 2015 09:28:17 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p>
<p>For example,<b]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Remove Duplicates”:<br>What if duplicates are allowed at most twice?</p>
<p>For example,<br>Given sorted array nums = [1,1,1,2,2,3],</p>
<p>Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p>基本设定和<a href="/2015/08/18/remove-duplicates-from-sorted-array/">上一题</a>是一样的，但是难度稍有增加，允许同一元素出现至多两次，比如[1, 1, 1, 2, 2, 3]中1出现了3次，去重后保留2次，2出现2次，全保留，3出现1次，全保留。去重后原数组变为[1, 1, 2, 2, 3]，长度为5。</p>
<h2 id="分析">分析</h2><p>由于相同元素肯定“扎堆出现”，修改<a href="/2015/08/18/remove-duplicates-from-sorted-array/">上一题</a>的代码，只要添加一个计数器，记录当前元素已经出现的个数就可以。时间复杂度O(n)，空间复杂度O(1)。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = <span class="number">1</span>  <span class="comment"># counter</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> m &lt; <span class="number">2</span> <span class="keyword">or</span> n != nums[i - <span class="number">1</span>]:</span><br><span class="line">                nums[i] = n</span><br><span class="line">                m = <span class="number">1</span> <span class="keyword">if</span> n != nums[i - <span class="number">1</span>] <span class="keyword">else</span> m + <span class="number">1</span>  <span class="comment"># reset m -&gt; 1 if a new number occurs</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/18/remove-duplicates-from-sorted-array-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-去除有序数组中的重复元素]]></title>
      <link>http://garfieldog.github.io/2015/08/18/remove-duplicates-from-sorted-array/</link>
      <guid>http://garfieldog.github.io/2015/08/18/remove-duplicates-from-sorted-array/</guid>
      <pubDate>Tue, 18 Aug 2015 08:34:22 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return t]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this in place with constant memory.</p>
<p>For example,<br>Given input array nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p>给定一个排序后的数组，要求移除重复的元素，返回新的数组长度。要求O(1)空间</p>
<h2 id="分析">分析</h2><p>这是一道简单题，使用两指针，一个记录去重后数组的尾部，一个扫原数组。可以实现inplace的时间O(n)空间O(1)的算法。另外，理解原题后就会发现，其实“有序”这个限定过于严格，只要保证相同的元素排列在一起就可以使用该算法。比如：[6, 6, 8, 8, 8, 7]</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> n != nums[i - <span class="number">1</span>]:</span><br><span class="line">                nums[i] = n</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/18/remove-duplicates-from-sorted-array/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Mew]]></title>
      <link>http://garfieldog.github.io/2015/08/18/mew/</link>
      <guid>http://garfieldog.github.io/2015/08/18/mew/</guid>
      <pubDate>Tue, 18 Aug 2015 02:56:14 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="猪肉卷">猪肉卷</h2><blockquote>
<p>我见过你们人类难以置信的事，<br>我见过太空飞船在猎户星座的边缘被击中，<br>燃起熊熊火光。<br>我见过Ｃ射线，<br>划过“唐怀瑟之门”那幽暗的宇宙空间。<br>然而所有的这些时刻都将消失在时间里，]]>
      </description>
      <content:encoded><![CDATA[<h2 id="猪肉卷">猪肉卷</h2><blockquote>
<p>我见过你们人类难以置信的事，<br>我见过太空飞船在猎户星座的边缘被击中，<br>燃起熊熊火光。<br>我见过Ｃ射线，<br>划过“唐怀瑟之门”那幽暗的宇宙空间。<br>然而所有的这些时刻都将消失在时间里，<br>就像……泪水……消失在雨中一样。<br>……<br>哎这炸酱面该下锅了吧！？</p>
</blockquote>
<h2 id="千层面">千层面</h2><p>$ E = mc^2 $</p>
<h2 id="披萨">披萨</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, start, end)</span>:</span></span><br><span class="line">    pivot = arr[start]</span><br><span class="line">    arr[end], arr[start] = arr[start], arr[end]</span><br><span class="line">    i = start</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(start, end, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= pivot:</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    arr[end], arr[i] = arr[i], arr[end]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort_r</span><span class="params">(arr, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; end:</span><br><span class="line">        p = partition(arr, start, end)</span><br><span class="line">        qsort_r(arr, start, p - <span class="number">1</span>)</span><br><span class="line">        qsort_r(arr, p + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    qsort_r(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/18/mew/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
