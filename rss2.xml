<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Fri, 18 Sep 2015 10:15:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Spiral Matrix II]]></title>
      <link>http://garfieldog.github.io/2015/09/18/spiral-matrix-2/</link>
      <guid>http://garfieldog.github.io/2015/09/18/spiral-matrix-2/</guid>
      <pubDate>Fri, 18 Sep 2015 10:04:01 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>Fo]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>For example,<br>Given n = 3,</p>
<p>You should return the following matrix:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/18/spiral-matrix/">Spiral Matrix</a>的后续。解法是一样的。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        left = up = <span class="number">0</span></span><br><span class="line">        right = down = n - <span class="number">1</span></span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">            <span class="keyword">if</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(left, right + <span class="number">1</span>):</span><br><span class="line">                    rs[up][i] = x</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> down &gt;= up <span class="keyword">and</span> right &gt;= left:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(up, down + <span class="number">1</span>):</span><br><span class="line">                    rs[i][right] = x</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    rs[down][i] = x</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                down -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> down &gt;= up <span class="keyword">and</span> right &gt;= left:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    rs[i][left] = x</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/spiral-matrix-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Spiral Matrix]]></title>
      <link>http://garfieldog.github.io/2015/09/18/spiral-matrix/</link>
      <guid>http://garfieldog.github.io/2015/09/18/spiral-matrix/</guid>
      <pubDate>Fri, 18 Sep 2015 09:33:21 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.<]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<p>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>You should return [1,2,3,6,9,8,7,4,5].</p>
</blockquote>
<h2 id="分析">分析</h2><p>细节实现题，注意边界判断。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        up = <span class="number">0</span></span><br><span class="line">        down = len(matrix) - <span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">while</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">            <span class="keyword">if</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(left, right + <span class="number">1</span>):</span><br><span class="line">                    rs.append(matrix[up][i])</span><br><span class="line">                up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> down &gt;= up <span class="keyword">and</span> right &gt;= left:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(up, down + <span class="number">1</span>):</span><br><span class="line">                    rs.append(matrix[i][right])</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    rs.append(matrix[down][i])</span><br><span class="line">                down -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> down &gt;= up <span class="keyword">and</span> right &gt;= left:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    rs.append(matrix[i][left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/spiral-matrix/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Pascal Triangle II]]></title>
      <link>http://garfieldog.github.io/2015/09/18/pascal-triangle-2/</link>
      <guid>http://garfieldog.github.io/2015/09/18/pascal-triangle-2/</guid>
      <pubDate>Fri, 18 Sep 2015 09:18:14 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return [1,3,3,1].</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/18/pascal-triangle/">Pascal Triangle</a>的后续。用类似动态规划的降维方式，可以实现空间<code>O(n)</code>的算法。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type rowIndex: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = [<span class="number">0</span>] * (rowIndex + <span class="number">1</span>)</span><br><span class="line">        rs[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, rowIndex + <span class="number">1</span>):</span><br><span class="line">            rs[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                rs[j] += rs[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/pascal-triangle-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Pascal Triangle]]></title>
      <link>http://garfieldog.github.io/2015/09/18/pascal-triangle/</link>
      <guid>http://garfieldog.github.io/2015/09/18/pascal-triangle/</guid>
      <pubDate>Fri, 18 Sep 2015 09:06:31 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br>Return</p>
<p>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>比较简单，打印杨辉三角。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type numRows: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = [[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, numRows):</span><br><span class="line">            row = [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, i):</span><br><span class="line">                row.append(rs[i - <span class="number">1</span>][j - <span class="number">1</span>] + rs[i - <span class="number">1</span>][j])</span><br><span class="line">            row.append(<span class="number">1</span>)</span><br><span class="line">            rs.append(row)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/pascal-triangle/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Substring with Concatenation of All Words]]></title>
      <link>http://garfieldog.github.io/2015/09/18/substring-with-concatenation-of-all-words/</link>
      <guid>http://garfieldog.github.io/2015/09/18/substring-with-concatenation-of-all-words/</guid>
      <pubDate>Fri, 18 Sep 2015 08:29:19 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p>
<p>For example, given:<br>s: “barfoothefoobarman”<br>words: [“foo”, “bar”]</p>
<p>You should return the indices: [0,9].<br>(order does not matter).</p>
</blockquote>
<h2 id="分析">分析</h2><p>这是一道细节实现题，方法是在对<code>s</code>每一个下标<code>i</code>，检查从<code>i</code>开始的<code>len(words)</code>个单词是不是刚好是<code>words</code>里的单词。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type words: List[str]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        ns = len(s)</span><br><span class="line">        nw = len(words[<span class="number">0</span>])</span><br><span class="line">        nws = len(words) * nw</span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">if</span> ns &lt; nws:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        expected = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            expected.setdefault(w, <span class="number">0</span>)</span><br><span class="line">            expected[w] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(ns - nws + <span class="number">1</span>):</span><br><span class="line">            found = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(words)):</span><br><span class="line">                word = s[i + j * nw: i + (j + <span class="number">1</span>) * nw]</span><br><span class="line">                <span class="keyword">if</span> expected.get(word, <span class="number">0</span>) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                found.setdefault(word, <span class="number">0</span>)</span><br><span class="line">                found[word] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> found[word] &gt; expected[word]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rs.append(i)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/substring-with-concatenation-of-all-words/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Multiply Strings]]></title>
      <link>http://garfieldog.github.io/2015/09/18/multiply-strings/</link>
      <guid>http://garfieldog.github.io/2015/09/18/multiply-strings/</guid>
      <pubDate>Fri, 18 Sep 2015 07:30:54 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note: ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note: The numbers can be arbitrarily large and are non-negative.</p>
</blockquote>
<h2 id="分析">分析</h2><p>大整数乘法，把字符串转换为数组，然后数组相乘。我们这里用9个字符组成一个数字，可以任意选 <code>0 &lt; n &lt; 10</code>的长度。(10位以上的字符串不能用一个32位整数存储)</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">UNIT_LEN = <span class="number">9</span></span><br><span class="line">BASE = <span class="number">1000000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">str2vec</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        v = []</span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> xrange(n, <span class="number">0</span>, -UNIT_LEN):</span><br><span class="line">            start = max(end - UNIT_LEN, <span class="number">0</span>)</span><br><span class="line">            v.append(int(s[start: end]))</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">vec2str</span><span class="params">(self, vec)</span>:</span></span><br><span class="line">        fmt = <span class="string">'%%0%dd'</span> % UNIT_LEN</span><br><span class="line">        ss = [str(vec[len(vec) - <span class="number">1</span>])]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(vec) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            ss.append(fmt % vec[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(ss)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply_vec</span><span class="params">(self, v1, v2)</span>:</span></span><br><span class="line">        n1 = len(v1)</span><br><span class="line">        n2 = len(v2)</span><br><span class="line">        v = [<span class="number">0</span>] * (n1 + n2)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n2):</span><br><span class="line">                v[i + j] += v1[i] * v2[j]</span><br><span class="line">                <span class="keyword">if</span> v[i + j] &gt;= BASE:</span><br><span class="line">                    v[i + j + <span class="number">1</span>] += v[i + j] / BASE</span><br><span class="line">                    v[i + j] %= BASE</span><br><span class="line">        <span class="keyword">while</span> len(v) &gt; <span class="number">1</span> <span class="keyword">and</span> v[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            v.pop()</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type num1: str</span><br><span class="line">        :type num2: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num1 <span class="keyword">or</span> <span class="keyword">not</span> num2:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        vec1 = self.str2vec(num1)</span><br><span class="line">        vec2 = self.str2vec(num2)</span><br><span class="line">        v = self.multiply_vec(vec1, vec2)</span><br><span class="line">        <span class="keyword">return</span> self.vec2str(v)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/multiply-strings/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Minimum Window Substring]]></title>
      <link>http://garfieldog.github.io/2015/09/18/minimum-window-substring/</link>
      <guid>http://garfieldog.github.io/2015/09/18/minimum-window-substring/</guid>
      <pubDate>Fri, 18 Sep 2015 06:03:58 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example,<br>S = “ADOBECODEBANC”<br>T = “ABC”<br>Minimum window is “BANC”.</p>
<p>Note:<br>If there is no such window in S that covers all characters in T, return the emtpy string “”.</p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题技巧性很强，题目要求时间<code>O(n)</code>。使用两指针<code>i, j</code>，j先走，找到第一个满足条件的窗口<code>[i, j)</code>，然后让i前进，收缩窗口到尽可能小（同时满足条件），这样就找到了一个候选窗口。然后i向前走一步，破坏了条件，让j重复开始的搜索逻辑。详情参考<a href="http://www.cnblogs.com/TenosDoIt/p/3461301.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        expected = defaultdict(int)</span><br><span class="line">        appeared = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            expected[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        m = len(t)</span><br><span class="line">        n = len(s)</span><br><span class="line">        min_window = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> m &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> appeared[s[j]] &lt; expected[s[j]]:</span><br><span class="line">                    m -= <span class="number">1</span></span><br><span class="line">                appeared[s[j]] += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># found a window, minimize it</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> appeared[s[i]] &gt; expected[s[i]]:</span><br><span class="line">                    appeared[s[i]] -= <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> min_window <span class="keyword">or</span> (j - i) &lt; (min_window[<span class="number">1</span>] - min_window[<span class="number">0</span>]):</span><br><span class="line">                    min_window = (i, j)</span><br><span class="line">                <span class="comment"># i++</span></span><br><span class="line">                appeared[s[i]] -= <span class="number">1</span></span><br><span class="line">                m += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min_window <span class="keyword">and</span> s[min_window[<span class="number">0</span>]: min_window[<span class="number">1</span>]] <span class="keyword">or</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/minimum-window-substring/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Merge Intervals]]></title>
      <link>http://garfieldog.github.io/2015/09/18/merge-intervals/</link>
      <guid>http://garfieldog.github.io/2015/09/18/merge-intervals/</guid>
      <pubDate>Fri, 18 Sep 2015 05:49:28 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given [1,3],[2,6]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>
</blockquote>
<h2 id="分析">分析</h2><p>和[Insert Interval][1]很像，解法也很类似，先按start排序然后遍历数组前后合并。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type intervals: List[Interval]</span><br><span class="line">        :rtype: List[Interval]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">        rs = []</span><br><span class="line">        last = intervals[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(intervals)):</span><br><span class="line">            v = intervals[i]</span><br><span class="line">            <span class="keyword">if</span> last.end &lt; v.start:</span><br><span class="line">                rs.append(last)</span><br><span class="line">                last = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># overlap</span></span><br><span class="line">                last.end = max(last.end, v.end)</span><br><span class="line">        rs.append(last)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/merge-intervals/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Insert Interval]]></title>
      <link>http://garfieldog.github.io/2015/09/18/insert-interval/</link>
      <guid>http://garfieldog.github.io/2015/09/18/insert-interval/</guid>
      <pubDate>Fri, 18 Sep 2015 03:33:32 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).<]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p>Example 1:<br>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p>Example 2:<br>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>
<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
</blockquote>
<h2 id="分析">分析</h2><p>看似简单，写对了不容易。思路是这样的，遍历已有区间，和新区间进行比较，有三种情况</p>
<ol>
<li>没有重叠，当前区间整体在新区间前面，则当前区间添加到结果集。</li>
<li>没有重叠，当前区间整体在新区间后面，添加新区间到结果集。后面的区间可以一一添加即可。</li>
<li>有重叠，把当前区间和新区间合并，生成的新区间继续和后面的区间进行上述过程。</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type intervals: List[Interval]</span><br><span class="line">        :type newInterval: Interval</span><br><span class="line">        :rtype: List[Interval]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> v.end &lt; newInterval.start:</span><br><span class="line">                rs.append(v)</span><br><span class="line">            <span class="keyword">elif</span> v.start &gt; newInterval.end:</span><br><span class="line">                rs.append(newInterval)</span><br><span class="line">                newInterval = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># overlap</span></span><br><span class="line">                newInterval.start = min(v.start, newInterval.start)</span><br><span class="line">                newInterval.end = max(v.end, newInterval.end)</span><br><span class="line">        rs.append(newInterval)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/insert-interval/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Palindrome Number]]></title>
      <link>http://garfieldog.github.io/2015/09/18/palindrome-number/</link>
      <guid>http://garfieldog.github.io/2015/09/18/palindrome-number/</guid>
      <pubDate>Fri, 18 Sep 2015 03:11:03 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>Some hints:<br>Could ne]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>Some hints:<br>Could negative integers be palindromes? (ie, -1)</p>
<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>
<p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p>
<p>There is a more generic way of solving this problem.</p>
</blockquote>
<h2 id="分析">分析</h2><p>用<a href="/2015/09/18/reverse-integer/">Reverse Integer</a>中实现的方法，把整数翻转看结果是否和它自己相等（另外注意负数不可能是回文）。还有一种解法，就是和<a href="/2015/08/31/valid-palindrome/">字符串判别回文</a>差不多，两指针从两边夹逼。</p>
<h2 id="代码">代码</h2><h3 id="翻转整数">翻转整数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        x = abs(x)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            x, mod = divmod(x, <span class="number">10</span>)</span><br><span class="line">            r = r * <span class="number">10</span> + mod</span><br><span class="line">            <span class="comment"># overflow check</span></span><br><span class="line">            <span class="keyword">if</span> r &gt; <span class="number">2147483647</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> sign * r</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.reverse(x) == x</span><br></pre></td></tr></table></figure>
<h3 id="头尾遍历">头尾遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        divisor = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> divisor * <span class="number">10</span> &lt;= x:</span><br><span class="line">            divisor *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            head = x / divisor</span><br><span class="line">            tail = x % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> head != tail:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            x = (x % divisor) / <span class="number">10</span></span><br><span class="line">            divisor /= <span class="number">100</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/palindrome-number/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Integer]]></title>
      <link>http://garfieldog.github.io/2015/09/18/reverse-integer/</link>
      <guid>http://garfieldog.github.io/2015/09/18/reverse-integer/</guid>
      <pubDate>Fri, 18 Sep 2015 02:51:22 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p>]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p>
<p>Have you thought about this?<br>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p>
<p>If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.</p>
<p>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?</p>
<p>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
</blockquote>
<h2 id="分析">分析</h2><p>算法没难度，细节实现题，测试用例里假设整数只有32位，但是Python在64位机器上int是64位的，而且一旦超出会自动转换为long，而long是没有精度限制的，所以说Python里整数不会溢出，这里为了过测试，要强行加上判断。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        x = abs(x)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            x, mod = divmod(x, <span class="number">10</span>)</span><br><span class="line">            r = r * <span class="number">10</span> + mod</span><br><span class="line">            <span class="comment"># overflow check</span></span><br><span class="line">            <span class="keyword">if</span> r &gt; <span class="number">2147483647</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> sign * r</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/reverse-integer/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Clone Graph]]></title>
      <link>http://garfieldog.github.io/2015/09/18/clone-graph/</link>
      <guid>http://garfieldog.github.io/2015/09/18/clone-graph/</guid>
      <pubDate>Fri, 18 Sep 2015 02:13:32 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>
<p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.<br>Second node is labeled as 1. Connect node 1 to node 2.<br>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.<br>Visually, the graph looks like the following:</p>
<pre><code>   <span class="number">1</span>
  / <span class="string">\</span>
 /   <span class="string">\</span>
<span class="number">0</span> --- <span class="number">2</span>
     / <span class="string">\</span>
     <span class="string">\_/</span>
</code></pre></blockquote>
<h2 id="分析">分析</h2><p>深度优先或广度优先遍历图即可，用一个字典维护已经被拷贝的节点。</p>
<h2 id="代码">代码</h2><h3 id="DFS">DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a undirected graph node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.neighbors = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, copied)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> copied:</span><br><span class="line">            <span class="keyword">return</span> copied[node]</span><br><span class="line">        new_node = UndirectedGraphNode(node.label)</span><br><span class="line">        copied[node] = new_node</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> node.neighbors:</span><br><span class="line">            new_node.neighbors.append(self.dfs(n, copied))</span><br><span class="line">        <span class="keyword">return</span> new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type node: UndirectedGraphNode</span><br><span class="line">        :rtype: UndirectedGraphNode</span><br><span class="line">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(node, d)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/clone-graph/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Word Break II]]></title>
      <link>http://garfieldog.github.io/2015/09/17/word-break-2/</link>
      <guid>http://garfieldog.github.io/2015/09/17/word-break-2/</guid>
      <pubDate>Thu, 17 Sep 2015 11:29:06 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.</p>
<p>Return all such possible sentences.</p>
<p>For example, given<br>s = “catsanddog”,<br>dict = [“cat”, “cats”, “and”, “sand”, “dog”].</p>
<p>A solution is [“cats and dog”, “cat sand dog”].</p>
</blockquote>
<h2 id="分析">分析</h2><p>在<a href="/2015/09/17/word-break/">Word Break</a>的基础上，要求返回所有可能的分词结果。我们用一个二维数组<code>A[i][j]</code>来表示<code>s[j:i]</code>是不是一个单词（注意下标是反的）。然后通过对<code>A</code>进行DFS我们可以还原所有的合法组合。理解了之后要写对还是不容易。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, A, idx, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">            rs.append(<span class="string">' '</span>.join(path[::-<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(idx):</span><br><span class="line">            <span class="keyword">if</span> A[idx][i]:</span><br><span class="line">                <span class="comment"># s[i: idx] is a word</span></span><br><span class="line">                path.append(s[i: idx])</span><br><span class="line">                self.dfs(s, A, i, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="keyword">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        A = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j: i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="keyword">True</span></span><br><span class="line">                    A[i][j] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dp[n]:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(s, A, n, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/word-break-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Word Break]]></title>
      <link>http://garfieldog.github.io/2015/09/17/word-break/</link>
      <guid>http://garfieldog.github.io/2015/09/17/word-break/</guid>
      <pubDate>Thu, 17 Sep 2015 11:16:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated s]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>
<p>Return true because “leetcode” can be segmented as “leet code”.</p>
</blockquote>
<h2 id="分析">分析</h2><p>一维动态规划，令<code>dp[i]</code>表示前i个字符构成的字符串是否可以被分词，则<code>dp[i] = any(dp[j] &amp;&amp; s[j:i] in wordDict), 0 &lt;= j &lt; i</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="keyword">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j: i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/word-break/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Distinct Subsequences]]></title>
      <link>http://garfieldog.github.io/2015/09/17/distinct-subsequences/</link>
      <guid>http://garfieldog.github.io/2015/09/17/distinct-subsequences/</guid>
      <pubDate>Thu, 17 Sep 2015 09:39:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequenc]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>Here is an example:<br>S = “rabbbit”, T = “rabbit”</p>
<p>Return 3.</p>
</blockquote>
<h2 id="分析">分析</h2><p>令<code>dp[i][j]</code>表示t的前j个字符在s的前i个字符组成的字符串中的subsequences个数，如果<code>s[i] == t[j]</code>，则可以选择用t[j]或者不用t[j]，<code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]</code>，若<code>s[i] != t[j]</code>，则显然<code>dp[i][j] = dp[i - 1][j]</code>。可以把dp数组降到一维。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        m = len(s)</span><br><span class="line">        n = len(t)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == t[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/distinct-subsequences/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Decode Ways]]></title>
      <link>http://garfieldog.github.io/2015/09/17/decode-ways/</link>
      <guid>http://garfieldog.github.io/2015/09/17/decode-ways/</guid>
      <pubDate>Thu, 17 Sep 2015 08:32:33 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br>Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p>
<p>The number of ways decoding “12” is 2.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题乍一看让人想起了<a href="/2015/09/15/restore-ip-addresses/">Restore IP Addresses</a>，这道题用DFS肯定能做，但效率不高。简单观察一下就会发现动态规划的最优子结构。用<code>dp[i]</code>表示前i个字符解码方法数，则如果当前字符和前一个字符可以构成合法的两位数，则<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，否则<code>dp[i] = dp[i - 1]</code>。 注意这道题的测试用例里有很多非法的<code>0</code>，处理这些非法值是比较麻烦的一点。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">9</span> &lt; int(s[i - <span class="number">2</span>: i]) &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/decode-ways/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Edit Distance]]></title>
      <link>http://garfieldog.github.io/2015/09/17/edit-distance/</link>
      <guid>http://garfieldog.github.io/2015/09/17/edit-distance/</guid>
      <pubDate>Thu, 17 Sep 2015 08:13:19 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (ea]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
</blockquote>
<h2 id="分析">分析</h2><p><code>编辑距离</code>是一个很重要的文本相似度度量标准，比较经典，通常的解法都是二维动态规划。<code>dp[i][j]</code>代表word1中前i个字符和word2前j个字符的编辑距离，则有</p>
<pre><code>dp[<span class="link_label">i</span>][<span class="link_reference">j</span>] = dp[<span class="link_label">i - 1</span>][<span class="link_reference">j - 1</span>] (if word1[i] == word2[j])
dp[<span class="link_label">i</span>][<span class="link_reference">j</span>] = min(dp[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>], dp[<span class="link_label">i</span>][<span class="link_reference">j - 1</span>], dp[<span class="link_label">i - 1</span>][<span class="link_reference">j - 1</span>]) + 1 (otherwise)
</code></pre><h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type word1: str</span><br><span class="line">        :type word2: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n1 = len(word1)</span><br><span class="line">        n2 = len(word2)</span><br><span class="line">        <span class="keyword">if</span> word1 == word2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n2 + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n1 + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/edit-distance/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Minimum Path Sum]]></title>
      <link>http://garfieldog.github.io/2015/09/17/minimum-path-sum/</link>
      <guid>http://garfieldog.github.io/2015/09/17/minimum-path-sum/</guid>
      <pubDate>Thu, 17 Sep 2015 07:55:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which mini]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
</blockquote>
<h2 id="分析">分析</h2><p>终于来了道简单点的找点自信，普通二维动态规划，<code>dp[i][j]</code>代表以<code>(i, j)</code>为终点的路径的最小长度，则有<code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code>，很容易转化为一维空间。时间<code>O(mn)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type grid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + grid[<span class="number">0</span>][i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                dp[j] = min(dp[j], dp[j - <span class="number">1</span>]) + grid[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/minimum-path-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Scramble String]]></title>
      <link>http://garfieldog.github.io/2015/09/17/scramble-string/</link>
      <guid>http://garfieldog.github.io/2015/09/17/scramble-string/</guid>
      <pubDate>Thu, 17 Sep 2015 06:51:45 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings re]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of s1 = “great”:</p>
<pre><code>great
</code></pre><p>   /    \<br>  gr    eat<br> / \    /  \<br>g   r  e   at<br>           / \<br>          a   t<br>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”.</p>
<pre><code>rgeat
</code></pre><p>   /    \<br>  rg    eat<br> / \    /  \<br>r   g  e   at<br>           / \<br>          a   t<br>We say that “rgeat” is a scrambled string of “great”.</p>
<p>Similarly, if we continue to swap the children of nodes “eat” and “at”, it produces a scrambled string “rgtae”.</p>
<pre><code>rgtae
</code></pre><p>   /    \<br>  rg    tae<br> / \    /  \<br>r   g  ta  e<br>       / \<br>      t   a<br>We say that “rgtae” is a scrambled string of “great”.</p>
<p>Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题我已经弃疗了，三维动态规划，正确解摆在面前也费劲。参考<a href="http://www.acmerblog.com/leetcode-solution-scramble-string-6224.html" target="_blank" rel="external">这里</a>。</p>
<p>有一个递归的解写起来比较容易，但是会超时。</p>
<h2 id="代码">代码</h2><h3 id="动态规划">动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) != len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(s1)</span><br><span class="line">        dp = [[[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)] <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                dp[<span class="number">1</span>][i][j] = s1[i] == s2[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - z + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n - z + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">1</span>, z):</span><br><span class="line">                        <span class="keyword">if</span> (dp[k][i][j] <span class="keyword">and</span> dp[z - k][i + k][j + k]) <span class="keyword">or</span> \</span><br><span class="line">                                (dp[k][i][j + z - k] <span class="keyword">and</span> dp[z - k][i + k][j]):</span><br><span class="line">                            dp[z][i][j] = <span class="keyword">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="递归（超时）">递归（超时）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) != len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(s1)</span><br><span class="line">        <span class="keyword">if</span> s1 == s2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[:i]) <span class="keyword">and</span> \</span><br><span class="line">                    self.isScramble(s1[i:], s2[i:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[-i:]) <span class="keyword">and</span> \</span><br><span class="line">                    self.isScramble(s1[i:], s2[:-i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/scramble-string/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Interleaving String]]></title>
      <link>http://garfieldog.github.io/2015/09/17/interleaving-string/</link>
      <guid>http://garfieldog.github.io/2015/09/17/interleaving-string/</guid>
      <pubDate>Thu, 17 Sep 2015 05:56:59 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Give]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 = “aabcc”,<br>s2 = “dbbca”,</p>
<p>When s3 = “aadbbcbcac”, return true.<br>When s3 = “aadbbbaccc”, return false.</p>
</blockquote>
<h2 id="分析">分析</h2><p>二维动态规划的思路，令<code>dp[i][j]</code>表示<code>s3的前i + j个字符是否可以由s1的前i个和s2的前j个字符交织组成</code>，显然有<code>dp[0][0] = True</code>，而<code>dp[0][j]</code>和<code>dp[i][0]</code>可以很容易预先填充，然后对于<code>dp[i][j]</code>，有递推公式</p>
<pre><code>dp[<span class="link_label">i</span>][<span class="link_reference">j</span>] = (dp[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>] and s1[i - 1] == s3[i + j - 1]) or \
<span class="code">            (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])</span>
</code></pre><h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1, s2, s3)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :type s3: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        n1 = len(s1)</span><br><span class="line">        n2 = len(s2)</span><br><span class="line">        <span class="keyword">if</span> len(s3) != n1 + n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (n2 + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n1 + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dp[i][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dp[<span class="number">0</span>][j]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/interleaving-string/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
