<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Tue, 25 Aug 2015 03:47:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Single Number]]></title>
      <link>http://garfieldog.github.io/2015/08/25/single-number/</link>
      <guid>http://garfieldog.github.io/2015/08/25/single-number/</guid>
      <pubDate>Tue, 25 Aug 2015 03:32:03 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>
<p>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<h2 id="分析">分析</h2><p>空间<code>O(n)</code>的算法很容易想，但是题目要求空间<code>O(1)</code>，这个就有一些奇技淫巧了，想到了就很容易，没想到还真是抓瞎。用<code>xor</code>操作的性质，给一个序列的数使用<code>xor</code>进行reduce，如果一个数出现偶数次，那么就跟没有出现过是一样的，也就是$ x \oplus y \oplus x = y $。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/single-number/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Candy]]></title>
      <link>http://garfieldog.github.io/2015/08/25/candy/</link>
      <guid>http://garfieldog.github.io/2015/08/25/candy/</guid>
      <pubDate>Tue, 25 Aug 2015 02:36:28 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving can]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<p>Each child must have at least one candy.<br>Children with a higher rating get more candies than their neighbors.<br>What is the minimum candies you must give?</p>
</blockquote>
<h2 id="分析">分析</h2><p>有一定难度。对于某个位置<code>i</code>上的小孩，它的糖果数取决于他自己和左右邻居的关系。设<code>ratings</code>数组为<code>R</code>，分配给小孩的糖果数为数组<code>C</code>。我们可以这样来考虑这个问题，拆分为两个步骤：</p>
<ol>
<li>首先，如果只要求<code>C[i] &gt; C[i-1]</code> iff <code>R[i] &gt; R[i-1]</code>，也就是说只考虑每个小孩左手边的小孩，那么如果<code>R[i] &gt; R[i-1]</code>则<code>C[i] = C[i-1] + 1</code>，否则<code>C[i] = 1</code>。</li>
<li>然后我们再考虑加上右手边小孩的限制，如果<code>R[i] &gt; R[i+1]</code>，则<code>C[i] = max(C[i+1] + 1, C[i])</code>。</li>
</ol>
<p>这样一来，考虑到上面被分解的两个问题内部的互相依赖情况，我们就可以用两个循环分别从左到右、从右到左遍历数组，得到时间<code>O(n)</code>，空间<code>O(n)</code>的算法。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">candy</span><span class="params">(self, R)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type R: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(R)</span><br><span class="line">        C = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> R[i] &gt; R[i - <span class="number">1</span>]:</span><br><span class="line">                C[i] = C[i - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> R[i] &gt; R[i + <span class="number">1</span>]:</span><br><span class="line">                C[i] = max(C[i + <span class="number">1</span>] + <span class="number">1</span>, C[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum(C)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/25/candy/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Gas Station]]></title>
      <link>http://garfieldog.github.io/2015/08/24/gas-station/</link>
      <guid>http://garfieldog.github.io/2015/08/24/gas-station/</guid>
      <pubDate>Mon, 24 Aug 2015 10:18:32 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>Y]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once, otherwise return -1.</p>
<p>Note:<br>The solution is guaranteed to be unique.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题等价于，对每个加油站，油的存量和到下一个加油站的消耗之差<code>diff[i] = gas[i] -cost[i]</code>这样一个循环数组，找到一个下标<code>x</code>，使得从<code>x</code>开始<code>diff[i]</code>的累加和永远非负。想到一个<code>O(n^2)</code>时间的算法很容易，但我们应该找到更好的。</p>
<p>首先，有一个很重要的结论，如果 $\sum_{i=0}^{N-1} gas[i] - cost[i] &gt;= 0 $，则肯定有解。如果小于0，则一定无解。这个结论如何证明需要仔细想一想。然后，如何找到这个下标呢？这个问题其实满足贪心法的最优子结构：</p>
<ol>
<li>从第0个加油站开始，寻找第一个使得<code>sum(diff[i]) &lt; 0</code>的下标，如果找不到，则说明，第一个加油站就满足条件。</li>
<li>找到这样的下标<code>i</code>，则说明<code>0..i</code>之间的加油站肯定不满足条件。可能的解只会在<code>i+1 ... N-1</code>之间。</li>
<li>将<code>sum</code>清零，从<code>i+1</code>开始继续搜索diff累加和为负的下标<code>j</code>，找到则说明<code>i+1 ... j</code>之间的加油站都不符合条件。以此类推。</li>
<li>最后判断全体的diff和是否非负，如果是，则按照之前的结论，肯定有解，这个解就是我们上面搜索过程中最后一个累加起始位置。</li>
</ol>
<p>时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canCompleteCircuit</span><span class="params">(self, gas, cost)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type gas: List[int]</span><br><span class="line">        :type cost: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        n = len(gas)</span><br><span class="line">        cur_sum, total_sum = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            diff = gas[i] - cost[i]</span><br><span class="line">            cur_sum += diff</span><br><span class="line">            total_sum += diff</span><br><span class="line">            <span class="keyword">if</span> cur_sum &lt; <span class="number">0</span>:</span><br><span class="line">                cur_sum = <span class="number">0</span></span><br><span class="line">                x = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> total_sum &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/24/gas-station/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Set Matrix Zeros]]></title>
      <link>http://garfieldog.github.io/2015/08/24/set-matrix-zeros/</link>
      <guid>http://garfieldog.github.io/2015/08/24/set-matrix-zeros/</guid>
      <pubDate>Mon, 24 Aug 2015 08:41:50 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p>Foll]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place.</p>
<p>Follow up:<br>Did you use extra space?<br>A straight forward solution using O(mn) space is probably a bad idea.<br>A simple improvement uses O(m + n) space, but still not the best solution.<br>Could you devise a constant space solution?</p>
</blockquote>
<p>给一个矩阵，如果某一个单元格值为0，那么把这一整行与一整列设为0。</p>
<h2 id="分析">分析</h2><p>这道题解出来不难，但要解得漂亮还是有一些技巧。需要多少空间复杂度呢？我们应该能轻松想到空间<code>O(m+n)</code>的算法，用<code>m+n</code>长度的哈希表记录对应行和列是否有0。事实上，我们完全可以把这个额外空间给省掉。我们有一个<code>m by
n</code>的矩阵，可以利用这个矩阵本身的存储空间来记录这个信息。就是拿出矩阵本身的一行和一列来当作我们<code>O(m+n)</code>算法中的哈希表空间。怎么取这一行和一列呢？有很多种取法。比如可以就用第一行和第一列，对他们额外处理一下就可以。或者，可以用某个0所在的行和列。需要遍历两遍数组，第一遍来记录出现0的行和列，第二遍用来对符合条件的每个位置清0。</p>
<p>时间复杂度<code>O(mn)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type A: List[List[int]]</span><br><span class="line">        :rtype: void Do not return anything, modify matrix in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        m = len(A)</span><br><span class="line">        n = len(A[<span class="number">0</span>])</span><br><span class="line">        first_row_has0, first_col_has0 = <span class="keyword">False</span>, <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                first_col_has0 = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> A[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                first_row_has0 = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> A[i][j] == <span class="number">0</span>:</span><br><span class="line">                    A[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">                    A[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> A[<span class="number">0</span>][j] == <span class="number">0</span> <span class="keyword">or</span> A[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                    A[i][j] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> first_col_has0:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">                A[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> first_row_has0:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                A[<span class="number">0</span>][j] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/24/set-matrix-zeros/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Rotate Image]]></title>
      <link>http://garfieldog.github.io/2015/08/24/rotate-image/</link>
      <guid>http://garfieldog.github.io/2015/08/24/rotate-image/</guid>
      <pubDate>Mon, 24 Aug 2015 07:41:53 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise)]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Follow up:<br>Could you do this in-place?</p>
</blockquote>
<h2 id="分析">分析</h2><p>将矩阵顺时针旋转90°，等同于先沿水平中线翻转，再按主对角线翻转。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :rtype: void Do not return anything, modify matrix in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n / <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                matrix[i][j], matrix[n - <span class="number">1</span> - i][j] = matrix[n - <span class="number">1</span> - i][j], matrix[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/24/rotate-image/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Gary Code]]></title>
      <link>http://garfieldog.github.io/2015/08/24/gary-code/</link>
      <guid>http://garfieldog.github.io/2015/08/24/gary-code/</guid>
      <pubDate>Mon, 24 Aug 2015 06:29:49 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The gray code is a binary numeral system where two successive values differ in only one bit.</p>
<p>Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p>
<p>For example, given n = 2, return [0,1,3,2]. Its gray code sequence is:</p>
<p>00 - 0<br>01 - 1<br>11 - 3<br>10 - 2<br>Note:<br>For a given n, a gray code sequence is not uniquely defined.</p>
<p>For example, [0,2,3,1] is also a valid gray code sequence according to the above definition.</p>
<p>For now, the judge is able to judge based on one instance of gray code sequence. Sorry about that.</p>
</blockquote>
<h2 id="分析">分析</h2><p>格雷码有数学公式：第n个格雷码<code>G(n)= n xor (n / 2)</code>，因此只要顺序给出从0到<code>2^n -1</code>个格雷码就可以。</p>
<p>数学公式虽然精妙，但如果你不知道这个公式，是很难现场推出来的。还可以从定义出发，递归给出格雷码:</p>
<ol>
<li>当n=1时，格雷码序列是<code>L(1) = [0, 1]</code></li>
<li>当n&gt;1时，格雷码序列是 <code>0前缀 ++ L(n - 1)</code> 和<code>1前缀 ++ reverse(L(n - 1))</code>的拼接。</li>
</ol>
<h2 id="代码">代码</h2><h3 id="公式法">公式法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span> ** n):</span><br><span class="line">            rs.append(i ^ (i / <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="递归法">递归法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            h = <span class="number">1</span> &lt;&lt; i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(rs) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                rs.append(h | rs[j])</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/24/gary-code/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Climbing Stairs]]></title>
      <link>http://garfieldog.github.io/2015/08/24/climbing-stairs/</link>
      <guid>http://garfieldog.github.io/2015/08/24/climbing-stairs/</guid>
      <pubDate>Mon, 24 Aug 2015 06:14:27 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either clim]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
</blockquote>
<h2 id="分析">分析</h2><p>稍一分析就知道答案是斐波那契数<code>F(n + 1)</code>。因为<code>f(1) = 1, f(2) = 2</code>，而<code>n &gt; 2</code>时，有多少种走法呢，可以分解为：</p>
<ol>
<li>如果第一次走一步，那么有<code>f(n-1)</code>种走法。</li>
<li>如果第一次走两步，那么有<code>f(n-2)</code>种走法。</li>
<li>因此<code>f(n) = f(n-1) + f(n-2)</code>，故<code>f(n)</code>是第<code>n+1</code>个斐波那契数。</li>
</ol>
<p>使用动态规划算法，时间复杂度<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">2</span>):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/24/climbing-stairs/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Plus One]]></title>
      <link>http://garfieldog.github.io/2015/08/24/plus-one/</link>
      <guid>http://garfieldog.github.io/2015/08/24/plus-one/</guid>
      <pubDate>Mon, 24 Aug 2015 05:57:51 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a non-negative number represented as an array of digits, plus one to the number.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
</blockquote>
<h2 id="分析">分析</h2><p>没什么好分析的，循环进位。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type digits: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(digits) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            s = digits[i] + carry</span><br><span class="line">            carry, r = divmod(s, <span class="number">10</span>)</span><br><span class="line">            digits[i] = r</span><br><span class="line">        <span class="keyword">if</span> carry &gt; <span class="number">0</span>:</span><br><span class="line">            digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/24/plus-one/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Trapping Rain Water]]></title>
      <link>http://garfieldog.github.io/2015/08/22/trapping-rain-water/</link>
      <guid>http://garfieldog.github.io/2015/08/22/trapping-rain-water/</guid>
      <pubDate>Sat, 22 Aug 2015 10:06:40 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<p>For example,<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="/images/rainwatertrap.png" alt="trapping-rain-water"> </p>
</blockquote>
<p>这道题非常经典。给一排高低不等的木板，求下雨后能存多少水。</p>
<h2 id="分析">分析</h2><p>对于某一块木板而言，它能存多少水取决于它左边最高的板与右边最高的板中较小的那个：<code>min(max_left, max_right) -
height</code>。可以遍历两遍数组，一次从左到右，记录每块板左边最高板的高度，第二次从右到左，记录每块板右边最高板的高度。时间与空间复杂度都是<code>O(n)</code>。</p>
<p>还可以再极端一点，只遍历一次数组，使用两指针前后遍历，比较两指针当前的值，如果左边比较小，则左指针一直往前移动，直到找到一个更大的值。在这中间的这段区域，存水量必然可以确定（因为左边最大值必然比右边最大值小），右指针的行为正好相反。写代码时一定要注意边界条件的判断。时间复杂度<code>O(n)</code>并且只需要遍历一次数组，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="两次遍历法">两次遍历法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        max_lefts = []</span><br><span class="line">        cur_max = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> height:</span><br><span class="line">            cur_max = max(cur_max, n)</span><br><span class="line">            max_lefts.append(cur_max)</span><br><span class="line">        cur_max = <span class="number">0</span></span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(height) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            n = height[i]</span><br><span class="line">            cur_max = max(cur_max, n)</span><br><span class="line">            x += min(cur_max, max_lefts[i]) - n</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h3 id="两指针法">两指针法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trap</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        low, high = <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            <span class="keyword">if</span> height[low] &lt; height[high]:</span><br><span class="line">                k = low + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> height[k] &lt;= height[low]:</span><br><span class="line">                    s += height[low] - height[k]</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                low = k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k = high - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> height[k] &lt; height[high]:</span><br><span class="line">                    s += height[high] - height[k]</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                high = k</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/22/trapping-rain-water/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Valid Sudoku]]></title>
      <link>http://garfieldog.github.io/2015/08/22/valid-sudoku/</link>
      <guid>http://garfieldog.github.io/2015/08/22/valid-sudoku/</guid>
      <pubDate>Sat, 22 Aug 2015 08:50:10 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx" target="_blank]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx" target="_blank" rel="external">Sudoku Puzzles - The Rules</a>.</p>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<p><img src="/images/sudoku.png" alt="sudoku.png"></p>
<p>A partially filled sudoku which is valid.</p>
<p>Note:<br>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>
</blockquote>
<p>判断一个数独棋盘状态是不是合法（不需要可解）。</p>
<h2 id="分析">分析</h2><p>可以分三次遍历棋盘，分别检查行、列、和小九宫格是否合法(同一数字最多出现一次)。时间复杂度<code>O(n^2)</code>，空间复杂度<code>O(n)</code>。还可以把三次遍历合并为一次，空间复杂度增加至<code>O(n^2)</code>，时间复杂度系数项减小。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type board: List[List[str]]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        n = len(board)</span><br><span class="line">        used_cols = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        used_cells = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            used_row = [<span class="keyword">False</span>] * n</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] != <span class="string">'.'</span>:</span><br><span class="line">                    k = int(board[i][j]) - <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> self.check(used_row, k) <span class="keyword">or</span> \</span><br><span class="line">                       <span class="keyword">not</span> self.check(used_cols[j], k) <span class="keyword">or</span> \</span><br><span class="line">                       <span class="keyword">not</span> self.check(used_cells[j / <span class="number">3</span> * <span class="number">3</span> + i / <span class="number">3</span>], k):</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, flags, k)</span>:</span></span><br><span class="line">        valid = <span class="keyword">not</span> flags[k]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flags[k]:</span><br><span class="line">            flags[k] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> valid</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/22/valid-sudoku/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Permutation Sequence]]></title>
      <link>http://garfieldog.github.io/2015/08/22/permutation-sequence/</link>
      <guid>http://garfieldog.github.io/2015/08/22/permutation-sequence/</guid>
      <pubDate>Sat, 22 Aug 2015 07:33:28 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order,<br>We get the following sequence (ie, for n = 3):</p>
<p>“123”<br>“132”<br>“213”<br>“231”<br>“312”<br>“321”<br>Given n and k, return the kth permutation sequence.</p>
<p>Note: Given n will be between 1 and 9 inclusive.</p>
</blockquote>
<h2 id="分析">分析</h2><p>我们在上一题<a href="/2015/08/21/next-permutation">Next Permutation</a>得出了给定一个排列求下一个排列的解法。那对于这道题，最直接的办法，就是从第一个排列开始，调用<code>k - 1</code>次<code>next permutation</code>嘛，这样的解法时间复杂度是<code>O(n^2)</code>。但这样显然有许多浪费，我们只要<code>第k个</code>，而不需要<code>前k个</code>，有没有更快的方法呢？</p>
<h3 id="康托展开">康托展开</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80" target="_blank" rel="external">康托展开</a>是一个全排列到一个自然数的双射，给定一个排列，可以计算出它在所有由小到大全排列中的顺序，并且这个计算是可逆的，这不正是我们要的么？康托展开的公式是<br>$$ X = a_n(n-1)! + a_{n-1}(n-2)! + … + a_1 \cdot 0! $$<br>维基百科<a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80" target="_blank" rel="external">康托展开</a>条目下的例子很好，我们直接拿来用：</p>
<blockquote>
<p>例如，3 5 7 4 1 2 9 6 8 展开为 98884。因为<code>X=2*8!+3*7!+4*6!+2*5!+0*4!+0*3!+2*2!+0*1!+0*0!=98884</code>.<br>解释：<br>排列的第一位是3，比3小的数有两个，以这样的数开始的排列有8!个，因此第一项为<code>2*8!</code><br>排列的第二位是5，比5小的数有1、2、3、4，由于3已经出现，因此共有3个比5小的数，这样的排列有7!个，因此第二项为<code>3*7!</code><br>以此类推，直至<code>0*0!</code></p>
</blockquote>
<p>在这里我们需要的是康托展开的逆运算，就是给定X，求原排列。同样我们引用维基的例子：</p>
<blockquote>
<p>给定n=5, x=96,<br>首先用96-1得到95，说明x之前有95个排列.(将此数本身减去！)<br>用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.<br>用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.<br>用5去除2!得到2余1，类似地，这一位是3.<br>用1去除1!得到1余0，这一位是2.<br>最后一位只能是1.<br>所以这个数是45321.</p>
</blockquote>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            x *= i</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        a = k - <span class="number">1</span></span><br><span class="line">        seq = range(<span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line">        rs = []</span><br><span class="line">        f = self.factorial(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>):</span><br><span class="line">            r = seq[a / f]</span><br><span class="line">            seq.remove(r)</span><br><span class="line">            rs.append(r)</span><br><span class="line">            a = a % f</span><br><span class="line">            f /= n - <span class="number">1</span> - i</span><br><span class="line">        rs.append(seq[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/22/permutation-sequence/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Next Permutation]]></title>
      <link>http://garfieldog.github.io/2015/08/21/next-permutation/</link>
      <guid>http://garfieldog.github.io/2015/08/21/next-permutation/</guid>
      <pubDate>Fri, 21 Aug 2015 03:07:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
</blockquote>
<p>给定一个序列，求下一个排列形式（按字典序）。例如一个集合<code>{1, 2, 3}</code>，它的全排列有6种，按字典顺序：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>如果给定序列<code>1 3 2</code>，那么下一个排列就是<code>2 1 3</code>，如果给定最后一个排列<code>3 2 1</code>，应该返回第一个排列<code>1 2 3</code>。要求空间复杂度<code>O(1)</code>。也就是说不能开新数组，需要inplace进行替换。</p>
<h2 id="分析">分析</h2><p>搞清楚排列数的规律，可以用以下算法完成：</p>
<ol>
<li>从右向左扫描数组，找到第一个破坏升序(从右向左升序)规律的下标<code>pivot</code>。下一个排列不需要改变pivot左边的序列(想想为什么)。如果找不到pivot，也就是说数组整体是倒序了，那说明是最后一个排列，翻转成第一个排列就好了。</li>
<li>这个时候我们知道要重新排列pivot右边的序列，这个序列（不包括pivot）是从左到右降序的。下一个排列在pivot位置上的数，应该是右边序列中比pivot上的数大的最小的数(想想为什么)。因此我们再次从右向左扫描数组（也可以二分查找），找到第一个比pivot大的数，交换它和pivot上的数。</li>
<li>这时候，pivot位置右侧的序列仍然是降序的，我们翻转这个序列（变成升序的），这时候数组中的值就构成了下一个排列。</li>
</ol>
<p>这个算法的时间复杂度是<code>O(n)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: void Do not return anything, modify nums in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        pivot = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                pivot = i - <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pivot &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[pivot]:</span><br><span class="line">                    nums[pivot], nums[i] = nums[i], nums[pivot]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        self.reverse(nums, pivot + <span class="number">1</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, nums, i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        t = (j - i + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(t):</span><br><span class="line">            nums[i + k], nums[j - k] = nums[j - k], nums[i + k]  <span class="comment"># swap</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/21/next-permutation/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Remove Element]]></title>
      <link>http://garfieldog.github.io/2015/08/21/remove-element/</link>
      <guid>http://garfieldog.github.io/2015/08/21/remove-element/</guid>
      <pubDate>Fri, 21 Aug 2015 02:49:09 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array and a value, remove all instances of that value in place and return the new length.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
</blockquote>
<p>删除数组中的给定元素。</p>
<h2 id="分析">分析</h2><p>这是一道简单题，使用两指针，一个记录当前有效数组的尾部，一个遍历原数组。这样做的正确性在于，第一个指针之后、第二个指针之前的数组空间肯定是<code>安全的</code>（要么已经被复制到第一个指针之前的区域，要么是要删掉的值）。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type val: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n != val:</span><br><span class="line">                nums[i] = n</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/21/remove-element/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-4Sum]]></title>
      <link>http://garfieldog.github.io/2015/08/21/4-sum/</link>
      <guid>http://garfieldog.github.io/2015/08/21/4-sum/</guid>
      <pubDate>Fri, 21 Aug 2015 01:56:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:<br>Elements in a quadruplet (a,b,c,d) must be in non-descending order. (ie, a ≤ b ≤ c ≤ d)<br>The solution set must not contain duplicate quadruplets.<br>For example, given array S = {1 0 -1 0 -2 2}, and target = 0.</p>
<p>A solution set is:<br>(-1,  0, 0, 1)<br>(-2, -1, 1, 2)<br>(-2,  0, 0, 2)</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/08/20/3-sum/">3Sum</a>可以用一样的两指针夹逼解法，时间复杂度<code>O(n^3)</code>，空间复杂度O(1)。还可以用空间换时间，用一个哈希表去缓存两数之和，时间复杂度平均降到<code>O(n^2)</code>，最坏<code>O(n^4)</code>(即所有元素都相等的时候)，空间复杂度<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="两指针法">两指针法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of length 4, [[val1,val2,val3,val4]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        rs = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, len(nums) - <span class="number">2</span>):</span><br><span class="line">                k = j + <span class="number">1</span></span><br><span class="line">                r = len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> k &lt; r:</span><br><span class="line">                    s = nums[i] + nums[j] + nums[k] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> s == target:</span><br><span class="line">                        rs.add((nums[i], nums[j], nums[k], nums[r]))</span><br><span class="line">                        k += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> s &gt; target:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [list(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
<h3 id="哈希表加速">哈希表加速</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of length 4, [[val1,val2,val3,val4]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        rs = set()</span><br><span class="line">        cache = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                cache.setdefault(nums[i] + nums[j], []).append((i, j))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">for</span> k, r <span class="keyword">in</span> cache.get(target - nums[i] - nums[j], []):</span><br><span class="line">                    <span class="keyword">if</span> j &lt; k:  <span class="comment"># notice: think about this condition</span></span><br><span class="line">                        rs.add((nums[i], nums[j], nums[k], nums[r]))</span><br><span class="line">        <span class="keyword">return</span> [list(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/21/4-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-3Sum Closest]]></title>
      <link>http://garfieldog.github.io/2015/08/20/3sum-closest/</link>
      <guid>http://garfieldog.github.io/2015/08/20/3sum-closest/</guid>
      <pubDate>Thu, 20 Aug 2015 05:33:43 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p>
<p>For example, given array S = {-1 2 1 -4}, and target = 1.</p>
<p>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p>
</blockquote>
<p>和上一题<a href="/2015/08/20/3-sum/">3Sum</a>基本设定一样，不过这次要求找到与<code>target</code>最相近的三数之和。返回和的值即可，不需要给出所有组合。</p>
<h2 id="分析">分析</h2><p>沿用<a href="/2015/08/20/3-sum/">3Sum</a>的解法，用一个变量维护当前最小绝对差值即可。时间复杂度<code>O(n^2)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ret = <span class="keyword">None</span></span><br><span class="line">        cur_diff = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">2</span>):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">elif</span> s &gt; target:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur_diff <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> cur_diff &gt; abs(s - target):</span><br><span class="line">                    cur_diff = abs(s - target)</span><br><span class="line">                    ret = s</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/20/3sum-closest/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-3Sum]]></title>
      <link>http://garfieldog.github.io/2015/08/20/3-sum/</link>
      <guid>http://garfieldog.github.io/2015/08/20/3-sum/</guid>
      <pubDate>Thu, 20 Aug 2015 03:24:10 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:<br>Elements in a triplet (a,b,c) must be in non-descending order. (ie, a ≤ b ≤ c)<br>The solution set must not contain duplicate triplets.<br>For example, given array S = {-1 0 1 2 -1 -4},</p>
<p>A solution set is:<br>(-1, 0, 1)<br>(-1, -1, 2)</p>
</blockquote>
<p>和上一题<a href="/2015/08/20/two-sum/">Two Sum</a>有点类似，不过变成了找3个数加和等于给定的数字（这里是0）。需要返回数字本身而不是下标。</p>
<h2 id="分析">分析</h2><p>如果我们固定一个数，那就转换成了<a href="/2015/08/20/two-sum/">Tow Sum</a>问题，所以，简单的解法就是遍历数组，固定当前数字，然后用<a href="/2015/08/20/two-sum/">Two Sum</a>的解法，时间和空间复杂度都是<code>O(n^2)</code>。</p>
<p>还可以用一种更通用的解法，适用于<code>k-Sum</code>问题，排序数组，然后用<code>k-2</code>个循环遍历数组，在最内层循环用两个指针左右夹逼找到解。时间复杂度<code>O(max(nlog(n), n^(k-1))</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a list of lists of length 3, [[val1,val2,val3]]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        rs = set()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(nums) - <span class="number">2</span>):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">                    rs.add((nums[i], nums[j], nums[k]))</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &gt; <span class="number">0</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [list(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/20/3-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Two Sum]]></title>
      <link>http://garfieldog.github.io/2015/08/20/two-sum/</link>
      <guid>http://garfieldog.github.io/2015/08/20/two-sum/</guid>
      <pubDate>Thu, 20 Aug 2015 02:57:43 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>Th]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单的做法就是用哈希表存储数字和它在数组中的下标，然后扫描一遍数组即可。时间复杂度O(n)，空间复杂度O(n)。题目中没有说明数组中有没有重复，如果有重复的数字这个算法还有效吗？乍一看是不对的，但其实仍然是有效的，因为构建哈希表我们是按照数组顺序遍历的，所以如果一个数字出现在多个位置，那哈希表中它存储的下标一定是最大的那个，这样一来，第二次扫描数组，如果<code>target = 2 * A[i]</code>，在哈希表中查找<code>A[i]</code>，得到的下标<code>j</code>一定大于<code>i</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @return a tuple, (index1, index2)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        d = &#123;x: i <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums)&#125;</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            j = d.get(target - x)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">and</span> j &gt; i:  <span class="comment"># notice: the condition is important</span></span><br><span class="line">                <span class="keyword">return</span> (i + <span class="number">1</span>, j + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/20/two-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-最长连续序列]]></title>
      <link>http://garfieldog.github.io/2015/08/19/longest-consecutive-sequence/</link>
      <guid>http://garfieldog.github.io/2015/08/19/longest-consecutive-sequence/</guid>
      <pubDate>Wed, 19 Aug 2015 15:51:57 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>For example,<br>Given [100, 4, 200, 1, 3, 2],<br>The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.</p>
<p>Your algorithm should run in O(n) complexity.</p>
</blockquote>
<p>给定一个未排序的整形数组，求出<code>最长连续元素序列</code>的长度。比如，给定数组<code>[100, 4, 200, 1, 3, 2]</code>，最长连续子序列为<code>[1, 2, 3, 4]</code>，长度为4。要求时间复杂度O(n)。</p>
<h2 id="分析">分析</h2><p>要求O(n)时间复杂度，就不能对数组排序，可以尝试用哈希表记录出现的元素。然后第二次遍历原数组，对每个元素，采用从中间向两边扩散的方式查找它的<code>相邻数</code>在不在哈希表中，一旦断掉就停止扩张，记录最长的序列长度。注意，要保证时间是O(n)的，就要记录元素有没有被<code>使用过</code>，被使用过的元素就不在进行判断，保证一个元素只被访问一次。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums</span></span><br><span class="line">    <span class="comment"># @return &#123;integer&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        d = &#123;n: <span class="keyword">True</span> <span class="keyword">for</span> n <span class="keyword">in</span> nums&#125;</span><br><span class="line">        cur_max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> d.get(n):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            d[n] = <span class="keyword">False</span></span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            cur_num = n + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> d.get(cur_num):</span><br><span class="line">                d[cur_num] = <span class="keyword">False</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur_num += <span class="number">1</span></span><br><span class="line">            cur_num = n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> d.get(cur_num):</span><br><span class="line">                d[cur_num] = <span class="keyword">False</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur_num -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; cur_max_len:</span><br><span class="line">                cur_max_len = i</span><br><span class="line">        <span class="keyword">return</span> cur_max_len</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/19/longest-consecutive-sequence/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-找出两个有序数组的中位数]]></title>
      <link>http://garfieldog.github.io/2015/08/19/median-of-two-sorted-arrays/</link>
      <guid>http://garfieldog.github.io/2015/08/19/median-of-two-sorted-arrays/</guid>
      <pubDate>Wed, 19 Aug 2015 03:07:51 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sort]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
</blockquote>
<p>给定两个有序的数组，长度分别问m和n，把这两个数组看成一个整体，求中位数。要求时间复杂度O(log(m+n))。中位数的定义是，如果一个集合有奇数<code>2k + 1</code>个元素，那排序后第k个数就是中位数，如果有偶数<code>2k</code>个元素，那么中位数的定义为排序后第<code>k</code>个数和第<code>k+1</code>个数的平均值。</p>
<h2 id="分析">分析</h2><p>看时间复杂度的要求，首先想到的就是二分法，但是如何在两个数组上进行二分呢？我们把这个问题分解一下，先求解<code>在两个有序数组中查找整体第k大的数</code>，如果<code>m+n</code>是偶数，则调用两次子过程求平均，如果是奇数，调用一次。我们这样来找第k大的数：</p>
<ol>
<li>假设m和n都大于<code>k/2</code>，则比较<code>nums1[k/2 - 1]</code>和<code>nums2[k - k/2 - 1]</code></li>
<li>如果前者比较大，则可以扔掉<code>nums2[k - k/2 - 1]</code>之前的<code>k/2</code>个数</li>
<li>如果后者比较大，则可以扔掉<code>nums1[k/2 - 1]</code>之前的<code>k/2</code>个数</li>
<li>如果相等，说明第k个数已经找到</li>
</ol>
<p>如果m和n中有一个小于<code>k/2</code>呢？假设n比m小，那么就取<code>min(k/2, n)</code>和<code>k - min(k/2, n)</code>作为比较的下标值。<br>时间复杂度是O(log(k))。在写代码的过程中，边界判断是非常容易出错的，要反复练习。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums1</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums2</span></span><br><span class="line">    <span class="comment"># @return &#123;float&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        total = len(nums1) + len(nums2)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            c1 = self.findKthInSortedArrays(nums1, nums2, total / <span class="number">2</span>)</span><br><span class="line">            c2 = self.findKthInSortedArrays(nums1, nums2, total / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">            median = (c1 + c2) / <span class="number">2.0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            median = float(self.findKthInSortedArrays(nums1, nums2, total / <span class="number">2</span> + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> median</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthInSortedArrays</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.findKthInSortedArraysR(nums1, <span class="number">0</span>, len(nums1) - <span class="number">1</span>,</span><br><span class="line">                                           nums2, <span class="number">0</span>, len(nums2) - <span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthInSortedArraysR</span><span class="params">(self, nums1, x1, y1, nums2, x2, y2, k)</span>:</span></span><br><span class="line">        m = y1 - x1 + <span class="number">1</span></span><br><span class="line">        n = y2 - x2 + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> m &lt; n:</span><br><span class="line">            <span class="keyword">return</span> self.findKthInSortedArraysR(nums2, x2, y2, nums1, x1, y1, k)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[x1 + k - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[x1], nums2[x2])</span><br><span class="line"></span><br><span class="line">        k2 = min(k / <span class="number">2</span>, n)</span><br><span class="line">        k1 = k - k2</span><br><span class="line">        <span class="keyword">if</span> nums1[x1 + k1 - <span class="number">1</span>] == nums2[x2 + k2 - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> nums1[x1 + k1 - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> nums1[x1 + k1 - <span class="number">1</span>] &gt; nums2[x2 + k2 - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findKthInSortedArraysR(nums1, x1, y1, nums2, x2 + k2, y2, k - k2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKthInSortedArraysR(nums1, x1 + k1, y1, nums2, x2, y2, k - k1)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/19/median-of-two-sorted-arrays/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-在被旋转的有序数组中查找目标II]]></title>
      <link>http://garfieldog.github.io/2015/08/19/search-in-rotated-sorted-array-2/</link>
      <guid>http://garfieldog.github.io/2015/08/19/search-in-rotated-sorted-array-2/</guid>
      <pubDate>Wed, 19 Aug 2015 02:25:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affe]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?</p>
<p>Would this affect the run-time complexity? How and why?</p>
<p>Write a function to determine if a given target is in the array.</p>
</blockquote>
<p>基本设定和<a href="/2015/08/18/search-in-rotated-sorted-array/">上一题</a>一样，但允许重复元素。<br>另外，本题只需要输出<code>True</code> or <code>False</code>即可，不需要输出下标。</p>
<h2 id="分析">分析</h2><p>允许重复元素之后，<code>A[mid]</code>和<code>A[low]</code>就有可能相等，这种情况下我们就无法判断<code>A[mid]</code>是在哪个子数组中，这种情况下，我们可以简单地让<code>low</code>指针向前走一步。这样一来，算法最坏情况下时间复杂度增加到了O(n)，平均情况下仍然为O(log(n))。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_r</span><span class="params">(self, A, target, low, high)</span>:</span></span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> A[low] &lt; A[mid]:</span><br><span class="line">            <span class="comment"># A[mid] locates in the first sub-array</span></span><br><span class="line">            <span class="keyword">if</span> A[low] &lt;= target &lt; A[mid]:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, low, mid - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, mid + <span class="number">1</span>, high)</span><br><span class="line">        <span class="keyword">elif</span> A[low] == A[mid]:</span><br><span class="line">            <span class="keyword">return</span> self.search_r(A, target, low + <span class="number">1</span>, high)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># A[mid] locates in the second sub-array</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &lt; target &lt;= A[high]:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, mid + <span class="number">1</span>, high)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.search_r(A, target, low, mid - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.search_r(nums, target, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/08/19/search-in-rotated-sorted-array-2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
