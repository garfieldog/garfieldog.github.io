<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Fri, 11 Sep 2015 09:43:38 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Subsets II]]></title>
      <link>http://garfieldog.github.io/2015/09/11/subsets-2/</link>
      <guid>http://garfieldog.github.io/2015/09/11/subsets-2/</guid>
      <pubDate>Fri, 11 Sep 2015 08:38:32 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets.</p>
<p>N]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets.</p>
<p>Note:<br>Elements in a subset must be in non-descending order.<br>The solution set must not contain duplicate subsets.<br>For example,<br>If nums = [1,2,2], a solution is:</p>
<p>[<br>  [2],<br>  <a href="/2015/09/11/subsets/">1</a>,<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/09/11/subsets/">Subsets</a>做法基本一样，只是要注意去掉多余的子集。这里采用的方法是，判断当前元素是否和上个元素相等，如果相等，则只扩展上次添加了的子集们，如果不等，就扩展全部。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;integer[]&#125; nums</span></span><br><span class="line">    <span class="comment"># @return &#123;integer[][]&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        rs = [[]]</span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        n = len(nums)</span><br><span class="line">        last_s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            s = len(rs)</span><br><span class="line">            start = last_s <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(start, s):</span><br><span class="line">                rs.append([nums[i]] + rs[j])</span><br><span class="line">            last_s = s</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/subsets-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Subsets]]></title>
      <link>http://garfieldog.github.io/2015/09/11/subsets/</link>
      <guid>http://garfieldog.github.io/2015/09/11/subsets/</guid>
      <pubDate>Fri, 11 Sep 2015 08:25:33 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of distinct integers, nums, return all possible subsets.</p>
<p>Note:<br>Elements in a subset]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of distinct integers, nums, return all possible subsets.</p>
<p>Note:<br>Elements in a subset must be in non-descending order.<br>The solution set must not contain duplicate subsets.<br>For example,<br>If nums = [1,2,3], a solution is:</p>
<p>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>生成全部子集，递归很容易，改成迭代也不难，时间<code>O(2^n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [[]]</span><br><span class="line">        nums.sort()</span><br><span class="line">        subsets = self.subsets(nums[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(subsets)):</span><br><span class="line">            subsets.append(nums[:<span class="number">1</span>] + subsets[i])</span><br><span class="line">        <span class="keyword">return</span> subsets</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        rs = [[]]</span><br><span class="line">        nums.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            n = len(rs)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">                rs.append([x] + rs[i])</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/subsets/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Search a 2D Matrix II]]></title>
      <link>http://garfieldog.github.io/2015/09/11/search-a-2d-matrix-2/</link>
      <guid>http://garfieldog.github.io/2015/09/11/search-a-2d-matrix-2/</guid>
      <pubDate>Fri, 11 Sep 2015 07:56:13 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.<br>For example,</p>
<p>Consider the following matrix:</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>Given target = 5, return true.</p>
<p>Given target = 20, return false.</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/11/search-a-2d-matrix/">上一题</a>的升级版。这次矩阵每一行是排序的，每一列也是排序的，但不保证前一行的所有数小于后一行的。仍然使用二分查找，不过每次只能剔除<code>1/4</code>的元素。(如果中心值比目标大，则剔除右下角的矩阵块，如果小，则剔除左上角)</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrixR</span><span class="params">(self, matrix, x1, y1, x2, y2, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> x1 &gt; x2 <span class="keyword">or</span> y1 &gt; y2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mid_x = x1 + (x2 - x1) / <span class="number">2</span></span><br><span class="line">        mid_y = y1 + (y2 - y1) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> matrix[mid_x][mid_y] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> matrix[mid_x][mid_y] &gt; target:</span><br><span class="line">            <span class="keyword">return</span> self.searchMatrixR(matrix, x1, y1, mid_x - <span class="number">1</span>, y2, target) <span class="keyword">or</span> \</span><br><span class="line">                self.searchMatrixR(matrix, mid_x, y1, x2, mid_y - <span class="number">1</span>, target)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.searchMatrixR(matrix, x1, mid_y + <span class="number">1</span>, mid_x, y2, target) <span class="keyword">or</span> \</span><br><span class="line">                self.searchMatrixR(matrix, mid_x + <span class="number">1</span>, y1, x2, y2, target)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> self.searchMatrixR(matrix, <span class="number">0</span>, <span class="number">0</span>, m - <span class="number">1</span>, n - <span class="number">1</span>, target)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/search-a-2d-matrix-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Search a 2D Matrix]]></title>
      <link>http://garfieldog.github.io/2015/09/11/search-a-2d-matrix/</link>
      <guid>http://garfieldog.github.io/2015/09/11/search-a-2d-matrix/</guid>
      <pubDate>Fri, 11 Sep 2015 07:29:34 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.<br>For example,</p>
<p>Consider the following matrix:</p>
<p>[<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>Given target = 3, return true.</p>
</blockquote>
<h2 id="分析">分析</h2><p>就是二分查找，多一个坐标转换。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = m * n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            x, y = divmod(mid, n)</span><br><span class="line">            <span class="keyword">if</span> matrix[x][y] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[x][y] &gt; target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/search-a-2d-matrix/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Search Insert Position]]></title>
      <link>http://garfieldog.github.io/2015/09/11/search-insert-position/</link>
      <guid>http://garfieldog.github.io/2015/09/11/search-insert-position/</guid>
      <pubDate>Fri, 11 Sep 2015 07:11:39 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the inde]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Here are few examples.<br>[1,3,5,6], 5 → 2<br>[1,3,5,6], 2 → 1<br>[1,3,5,6], 7 → 4<br>[1,3,5,6], 0 → 0</p>
</blockquote>
<h2 id="分析">分析</h2><p>其实就是上一题<a href="/2015/09/11/search-for-a-range/">Search for a Range</a>实现的<code>lowerBound</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/search-insert-position/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Search for a Range]]></title>
      <link>http://garfieldog.github.io/2015/09/11/search-for-a-range/</link>
      <guid>http://garfieldog.github.io/2015/09/11/search-for-a-range/</guid>
      <pubDate>Fri, 11 Sep 2015 06:17:57 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Y]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>For example,<br>Given [5, 7, 7, 8, 8, 10] and target value 8,<br>return [3, 4].</p>
</blockquote>
<h2 id="分析">分析</h2><p>可以先二分查找，再从中心向左右扩张。<br>但这样其实在某些极端情况下性能不佳，比如全是相同元素数组。可以用两次二分查找，一次找上界，一次找下界。</p>
<h2 id="代码">代码</h2><h3 id="先二分，后扩张">先二分，后扩张</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        found = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                found = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        i = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[i] == target:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        j = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; len(nums) <span class="keyword">and</span> nums[j] == target:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [i + <span class="number">1</span>, j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="两次二分">两次二分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        lower = self.lowerBound(nums, target)</span><br><span class="line">        upper = self.upperBound(nums, target)</span><br><span class="line">        <span class="keyword">if</span> lower &gt;= len(nums) <span class="keyword">or</span> nums[lower] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [lower, upper]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upperBound</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> high</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowerBound</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/search-for-a-range/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Sort Colors]]></title>
      <link>http://garfieldog.github.io/2015/09/11/sort-colors/</link>
      <guid>http://garfieldog.github.io/2015/09/11/sort-colors/</guid>
      <pubDate>Fri, 11 Sep 2015 03:30:10 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note:<br>You are not suppose to use the library’s sort function for this problem.<br>Follow up:<br>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.</p>
<p>Could you come up with an one-pass algorithm using only constant space?</p>
</blockquote>
<h2 id="分析">分析</h2><p>使用计数排序很简单。题目进阶要求只扫一遍数组，就有点意思了。可以用两指针左右夹逼，遇到0就放到前面，遇到2就放到后面，比较像快排中的partition。</p>
<h2 id="代码">代码</h2><h3 id="计数排序">计数排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: void Do not return anything, modify nums in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        counts = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            counts[x] += <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(counts)):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> xrange(counts[j]):</span><br><span class="line">                nums[i] = j</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="两指针">两指针</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: void Do not return anything, modify nums in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        pivot = <span class="number">1</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = len(nums) - <span class="number">1</span></span><br><span class="line">        k = i</span><br><span class="line">        <span class="keyword">while</span> k &lt;= j:</span><br><span class="line">            <span class="keyword">if</span> nums[k] &lt; pivot:</span><br><span class="line">                <span class="keyword">if</span> k == i:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[k], nums[i] = nums[i], nums[k]</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[k] &gt; pivot:</span><br><span class="line">                nums[k], nums[j] = nums[j], nums[k]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                k += <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/sort-colors/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-First Missing Positive]]></title>
      <link>http://garfieldog.github.io/2015/09/11/first-missing-positive/</link>
      <guid>http://garfieldog.github.io/2015/09/11/first-missing-positive/</guid>
      <pubDate>Fri, 11 Sep 2015 02:44:36 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an unsorted integer array, find the first missing positive integer.</p>
<p>For example,<br>Given [1,2,0] return 3,<br>and [3,4,-1,1] return 2.</p>
<p>Your algorithm should run in O(n) time and uses constant space.</p>
</blockquote>
<h2 id="分析">分析</h2><p>使用基排序的技巧，将对应数字交换到它对应的下标上去。注意如果被交换来的数字依然不是他应该在的位置，应该持续交换。最多需要交换<code>n</code>次。</p>
<p>要注意负数，越界数（大于数组长度的数）以及重复出现的数。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">while</span> nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] &lt;= n <span class="keyword">and</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] == nums[nums[i] - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                a = nums[i]</span><br><span class="line">                nums[i] = nums[a - <span class="number">1</span>]</span><br><span class="line">                nums[a - <span class="number">1</span>] = a</span><br><span class="line"></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(nums) <span class="keyword">and</span> nums[i] == i + <span class="number">1</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/first-missing-positive/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Sort List]]></title>
      <link>http://garfieldog.github.io/2015/09/11/sort-list/</link>
      <guid>http://garfieldog.github.io/2015/09/11/sort-list/</guid>
      <pubDate>Fri, 11 Sep 2015 02:20:07 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
</blockquote>
<h2 id="分析">分析</]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要求时间<code>O(nlogn)</code>，上一题的插入排序就不能用了，可以使用归并排序，先split成两个链表，分别递归排序，再归并。可以用到我们之前的<a href="/2015/09/10/merge-two-sorted-lists/">Merge Two Sorted List</a>。</p>
<h2 id="代码">代码</h2><h3 id="归并排序">归并排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = l1</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                prev.next = l2</span><br><span class="line">                prev = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.next = l1</span><br><span class="line">                prev = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            prev.next = l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev.next = l1</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        h1 = head</span><br><span class="line">        h2 = head.next</span><br><span class="line">        p1 = h1</span><br><span class="line">        p2 = h2</span><br><span class="line">        <span class="keyword">while</span> p2:</span><br><span class="line">            p1.next = p2.next</span><br><span class="line">            <span class="keyword">if</span> p2.next:</span><br><span class="line">                p2.next = p2.next.next</span><br><span class="line">            p1 = p1.next</span><br><span class="line">            p2 = p2.next</span><br><span class="line">        <span class="keyword">return</span> h1, h2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># split to two lists</span></span><br><span class="line">        l1, l2 = self.splitList(head)</span><br><span class="line">        l1 = self.sortList(l1)</span><br><span class="line">        l2 = self.sortList(l2)</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(l1, l2)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/11/sort-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Insertion Sort List]]></title>
      <link>http://garfieldog.github.io/2015/09/10/insertion-sort-list/</link>
      <guid>http://garfieldog.github.io/2015/09/10/insertion-sort-list/</guid>
      <pubDate>Thu, 10 Sep 2015 14:06:16 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Sort a linked list using insertion sort.</p>
</blockquote>
<h2 id="分析">分析</h2><p>链表的插入排序，不难，但程序写对不容易。 </p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Sort a linked list using insertion sort.</p>
</blockquote>
<h2 id="分析">分析</h2><p>链表的插入排序，不难，但程序写对不容易。 </p>
<h2 id="代码">代码</h2><h3 id="总是超时的解，发誓逻辑是对的">总是超时的解，发誓逻辑是对的</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            pre = dummy</span><br><span class="line">            <span class="keyword">while</span> pre != cur <span class="keyword">and</span> pre.next.val &lt; cur.next.val:</span><br><span class="line">                pre = pre.next</span><br><span class="line">            <span class="keyword">if</span> pre == cur:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                next = cur.next</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">                next.next = pre.next</span><br><span class="line">                pre.next = next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h3 id="针对已排序情况做优化">针对已排序情况做优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertionSortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur.next:</span><br><span class="line">            <span class="keyword">if</span> cur.next.val &lt; cur.val:</span><br><span class="line">                pre = dummy</span><br><span class="line">                <span class="keyword">while</span> pre != cur <span class="keyword">and</span> pre.next.val &lt; cur.next.val:</span><br><span class="line">                    pre = pre.next</span><br><span class="line">                <span class="keyword">if</span> pre == cur:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    next = cur.next</span><br><span class="line">                    cur.next = cur.next.next</span><br><span class="line">                    next.next = pre.next</span><br><span class="line">                    pre.next = next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/10/insertion-sort-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Merge k Sorted Lists]]></title>
      <link>http://garfieldog.github.io/2015/09/10/merge-k-sorted-lists/</link>
      <guid>http://garfieldog.github.io/2015/09/10/merge-k-sorted-lists/</guid>
      <pubDate>Thu, 10 Sep 2015 03:12:24 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
</]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/09/10/merge-two-sorted-lists/">上一题</a>思路是一样的，不过简单的按顺序合并提交会超时，要想办法加速。空间换时间，利用一个heap，使得找当前最小值从<code>O(k)</code>降到<code>O(logk)</code>。</p>
<h2 id="代码">代码</h2><h3 id="K条同时合并（提交会超时）">K条同时合并（提交会超时）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">argmin</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        idx = -<span class="number">1</span></span><br><span class="line">        min_val = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i, node <span class="keyword">in</span> enumerate(lists):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">and</span> node.val &lt; min_val:</span><br><span class="line">                idx = i</span><br><span class="line">                min_val = node.val</span><br><span class="line">        <span class="keyword">return</span> idx</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type lists: List[ListNode]</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            idx = self.argmin(lists)</span><br><span class="line">            <span class="keyword">if</span> idx &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p.next = lists[idx]</span><br><span class="line">            p = p.next</span><br><span class="line">            lists[idx] = lists[idx].next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h3 id="一个一个合并（仍然超时）">一个一个合并（仍然超时）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type l1: ListNode</span><br><span class="line">        :type l2: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = l1</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                prev.next = l2</span><br><span class="line">                prev = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.next = l1</span><br><span class="line">                prev = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            prev.next = l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev.next = l1</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type lists: List[ListNode]</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        p = lists[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lists[<span class="number">1</span>:]:</span><br><span class="line">            p = self.mergeTwoLists(p, l)</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure>
<h3 id="利用heap加速">利用heap加速</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type lists: List[ListNode]</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        prev = dummy</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> p:</span><br><span class="line">                heap.append((p.val, p))</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            <span class="comment"># pop min</span></span><br><span class="line">            val, p = heapq.heappop(heap)</span><br><span class="line">            prev.next = p</span><br><span class="line">            prev = prev.next</span><br><span class="line">            <span class="keyword">if</span> p.next:</span><br><span class="line">                heapq.heappush(heap, (p.next.val, p.next))</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/10/merge-k-sorted-lists/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Merge Two Sorted Lists]]></title>
      <link>http://garfieldog.github.io/2015/09/10/merge-two-sorted-lists/</link>
      <guid>http://garfieldog.github.io/2015/09/10/merge-two-sorted-lists/</guid>
      <pubDate>Thu, 10 Sep 2015 02:50:42 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing togeth]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
</blockquote>
<h2 id="分析">分析</h2><p>和合并两有序数组基本一样，链表操作还会更简单一点。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type l1: ListNode</span><br><span class="line">        :type l2: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.next = l1</span><br><span class="line">        prev = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val:</span><br><span class="line">                prev.next = l2</span><br><span class="line">                prev = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev.next = l1</span><br><span class="line">                prev = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            prev.next = l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prev.next = l1</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/10/merge-two-sorted-lists/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Merge Sorted Array]]></title>
      <link>http://garfieldog.github.io/2015/09/10/merge-sorted-array/</link>
      <guid>http://garfieldog.github.io/2015/09/10/merge-sorted-array/</guid>
      <pubDate>Thu, 10 Sep 2015 02:33:49 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要<code>in-place</code>，就不能从前向后扫，要从后往前扫，不难，但要争取一遍写出无错的。时间复杂度<code>O(m + n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums1: List[int]</span><br><span class="line">        :type m: int</span><br><span class="line">        :type nums2: List[int]</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: void Do not return anything, modify nums1 in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        i = m - <span class="number">1</span></span><br><span class="line">        j = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i] &gt; nums2[j]:</span><br><span class="line">                nums1[i + j + <span class="number">1</span>] = nums1[i]</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[i + j + <span class="number">1</span>] = nums2[j]</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[j] = nums2[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/10/merge-sorted-array/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Sum Root to Leaf Numbers]]></title>
      <link>http://garfieldog.github.io/2015/09/09/sum-root-to-leaf-numbers/</link>
      <guid>http://garfieldog.github.io/2015/09/09/sum-root-to-leaf-numbers/</guid>
      <pubDate>Wed, 09 Sep 2015 09:09:53 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p>For example,</p>
<pre><code><span class="number">1</span>
</code></pre><p>   / \<br>  2   3<br>The root-to-leaf path 1-&gt;2 represents the number 12.<br>The root-to-leaf path 1-&gt;3 represents the number 13.</p>
<p>Return the sum = 12 + 13 = 25.</p>
</blockquote>
<h2 id="分析">分析</h2><p>深度优先遍历，自顶向下传递和值。时间<code>O(n)</code>，空间<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbersR</span><span class="params">(self, root, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s = s * <span class="number">10</span> + root.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.sumNumbersR(root.left, s) + self.sumNumbersR(root.right, s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.sumNumbersR(root, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/sum-root-to-leaf-numbers/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Maximum Path Sum]]></title>
      <link>http://garfieldog.github.io/2015/09/09/binary-tree-maximum-path-sum/</link>
      <guid>http://garfieldog.github.io/2015/09/09/binary-tree-maximum-path-sum/</guid>
      <pubDate>Wed, 09 Sep 2015 08:36:51 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find the maximum path sum.</p>
<p>The path may start and end at any node in the tree]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find the maximum path sum.</p>
<p>The path may start and end at any node in the tree.</p>
<p>For example:<br>Given the below binary tree,</p>
<pre><code>  <span class="number">1</span>
 / \
<span class="number">2</span>   <span class="number">3</span>
</code></pre><p>Return 6.</p>
</blockquote>
<h2 id="分析">分析</h2><p>题目难度标了<code>Hard</code>，其实并不难，关键是要理解最长路径的构成。用深度优先遍历，对于每一个节点，都去考察<code>以该节点为根，所能构成的最大半条路径</code>，所谓<code>半条路径</code>就是指这条路径上的节点要么都在该节点的左子树，要么都在右子树，没有跨越的情况。这样一来，当前以当前节点为根的最长路径就是把左子树中最长<code>半条路径</code>和右子树的最长<code>半条路径</code>拼起来。</p>
<p>注意节点的值有可能是负数，所以，如果<code>半条路径</code>长是负值，我们就不要它。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    max_sum = float(<span class="string">'-inf'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSumR</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        s1 = self.maxPathSumR(root.left)</span><br><span class="line">        s2 = self.maxPathSumR(root.right)</span><br><span class="line">        <span class="comment"># update max_sum</span></span><br><span class="line">        self.max_sum = max(s1 + s2 + root.val, s1 + root.val,</span><br><span class="line">                           s2 + root.val, root.val, self.max_sum)</span><br><span class="line">        <span class="keyword">return</span> max(s1, s2, <span class="number">0</span>) + root.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        self.maxPathSumR(root)</span><br><span class="line">        <span class="keyword">return</span> self.max_sum</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/binary-tree-maximum-path-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Path Sum II]]></title>
      <link>http://garfieldog.github.io/2015/09/09/path-sum-2/</link>
      <guid>http://garfieldog.github.io/2015/09/09/path-sum-2/</guid>
      <pubDate>Wed, 09 Sep 2015 08:00:01 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,<br>              5<br>             / \<br>            4   8<br>           /   / \<br>          11  13  4<br>         /  \    / \<br>        7    2  5   1<br>return<br>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>比<a href="/2015/09/09/path-sum/">Path Sum</a>更进一步，要求把符合要求的路径都记下来。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            ss.append((root, sum, []))</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            cur, n, l = ss.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                <span class="keyword">if</span> n == cur.val:</span><br><span class="line">                    rs.append(l + [cur.val])</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                ss.append((cur.right, n - cur.val, l + [cur.val]))</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                ss.append((cur.left, n - cur.val, l + [cur.val]))</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/path-sum-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Path Sum]]></title>
      <link>http://garfieldog.github.io/2015/09/09/path-sum/</link>
      <guid>http://garfieldog.github.io/2015/09/09/path-sum/</guid>
      <pubDate>Wed, 09 Sep 2015 07:47:07 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,<br>              5<br>             / \<br>            4   8<br>           /   / \<br>          11  13  4<br>         /  \      \<br>        7    2      1<br>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
</blockquote>
<h2 id="分析">分析</h2><p>深度优先遍历可解，时间<code>O(n)</code>，空间<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> root.val == sum</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum - root.val) <span class="keyword">or</span> \</span><br><span class="line">            self.hasPathSum(root.right, sum - root.val)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/path-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Maximum Depth of Binary Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/09/maximum-depth-of-binary-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/09/maximum-depth-of-binary-tree/</guid>
      <pubDate>Wed, 09 Sep 2015 07:37:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the lo]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<h2 id="分析">分析</h2><p>深度优先遍历可解，时间<code>O(n)</code>，空间平均<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        d1 = self.maxDepth(root.left)</span><br><span class="line">        d2 = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(d1, d2) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/maximum-depth-of-binary-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Minimum Depth of Binary Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/09/minimum-depth-of-binary-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/09/minimum-depth-of-binary-tree/</guid>
      <pubDate>Wed, 09 Sep 2015 07:23:08 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the sh]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, find its minimum depth.</p>
<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>
</blockquote>
<h2 id="分析">分析</h2><p>广度优先遍历可解，找到第一个叶子节点停止搜索返回高度。时间<code>O(n)</code>，空间<code>O(n)</code>。</p>
<h2 id="解题">解题</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        q = deque()</span><br><span class="line">        depth = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            depth += <span class="number">1</span></span><br><span class="line">            q.append(root)</span><br><span class="line">            q.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left <span class="keyword">and</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    <span class="comment"># leaf node</span></span><br><span class="line">                    <span class="keyword">return</span> depth</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> q:</span><br><span class="line">                    depth += <span class="number">1</span></span><br><span class="line">                    q.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> depth</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/minimum-depth-of-binary-tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Convert Sorted List to Binary Search Tree]]></title>
      <link>http://garfieldog.github.io/2015/09/09/convert-sorted-list-to-binary-search-tree/</link>
      <guid>http://garfieldog.github.io/2015/09/09/convert-sorted-list-to-binary-search-tree/</guid>
      <pubDate>Wed, 09 Sep 2015 06:57:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/09/09/convert-sorted-array-to-binary-search-tree/">上一题</a>不同的是，这次是链表，不能随机访问，那么自顶向下的分治法就失效了。不过可以稍作改动，就可以实现自底向上的构建，需要维护一个全局变量。时间<code>O(n)</code>，空间平均<code>O(logn)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    cur = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBSTR</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt; end:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = (end - start) / <span class="number">2</span> + start</span><br><span class="line">        left = self.sortedListToBSTR(start, root - <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># now `self.cur` is root</span></span><br><span class="line">        node = TreeNode(self.cur.val)</span><br><span class="line">        self.cur = self.cur.next</span><br><span class="line">        right = self.sortedListToBSTR(root + <span class="number">1</span>, end)</span><br><span class="line">        node.left = left</span><br><span class="line">        node.right = right</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        self.cur = head</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> self.sortedListToBSTR(<span class="number">0</span>, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/09/convert-sorted-list-to-binary-search-tree/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
