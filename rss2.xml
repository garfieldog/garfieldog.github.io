<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Mon, 07 Sep 2015 12:21:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Zigzag Level Order Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-zigzag-level-order-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-zigzag-level-order-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 11:59:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to righ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its zigzag level order traversal as:<br>[<br>  [3],<br>  [20,9],<br>  [15,7]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/07/binary-tree-level-order-traversal/">Level Order Traveral</a>的姐妹版，要求每一层从左到右、从右到左花插着来。</p>
<p>用一个flag来标识当前level是从左到右还是从右到左，另外在queue中插入行间标示符（这里用<code>None</code>）来分割各行。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        level = []</span><br><span class="line">        rs = []</span><br><span class="line">        zig = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        queue.append(<span class="keyword">None</span>)  <span class="comment"># None as level seperator</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                level.append(cur.val)</span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    queue.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    queue.append(cur.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># level end</span></span><br><span class="line">                <span class="keyword">if</span> zig:</span><br><span class="line">                    rs.append(level)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rs.append(level[::-<span class="number">1</span>])</span><br><span class="line">                level = []</span><br><span class="line">                zig = <span class="keyword">not</span> zig</span><br><span class="line">                <span class="keyword">if</span> queue:</span><br><span class="line">                    queue.append(<span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-zigzag-level-order-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Level Order Traversal II]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal-2/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal-2/</guid>
      <pubDate>Mon, 07 Sep 2015 11:49:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to r]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its bottom-up level order traversal as:<br>[<br>  [15,7],<br>  [9,20],<br>  [3]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/07/binary-tree-level-order-traversal/">Level Order Traveral</a>的姐妹版，要求最底层的先输出。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue.append((root, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur, idx = queue.popleft()</span><br><span class="line">            d.setdefault(idx, []).append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append((cur.left, idx + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append((cur.right, idx + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> [v <span class="keyword">for</span> k, v <span class="keyword">in</span> sorted(d.items(), key=<span class="keyword">lambda</span> x: -x[<span class="number">0</span>])]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Level Order Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 11:34:45 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, leve]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree {3,9,20,#,#,15,7},<br>    3<br>   / \<br>  9  20<br>    /  \<br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>广度优先遍历，用队列实现。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque, OrderedDict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        d = OrderedDict()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        queue.append((root, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            cur, idx = queue.popleft()</span><br><span class="line">            d.setdefault(idx, []).append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                queue.append((cur.left, idx + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                queue.append((cur.right, idx + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-level-order-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Postorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-postorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-postorder-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 08:07:48 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given bi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the postorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [3,2,1].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<h2 id="分析">分析</h2><p>后序遍历是三种遍历中最难的一种，迭代版需要一个额外的指针记录上一个访问过的节点，只有当一个节点左子树和右子树都遍历过后才能访问当前节点，左子树依靠栈来保证（跟中序遍历一样），右子树需要靠prev节点来判断是否访问过。</p>
<p>Morris遍历也要更复杂一些，看<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">这里</a>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversalR</span><span class="params">(self, root, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postorderTraversalR(root.left, rs)</span><br><span class="line">        self.postorderTraversalR(root.right, rs)</span><br><span class="line">        rs.append(root.val)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        self.postorderTraversalR(root, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        cur = root</span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                ss.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            prev = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">while</span> ss:</span><br><span class="line">                cur = ss.pop()</span><br><span class="line">                <span class="keyword">if</span> cur.right == prev:</span><br><span class="line">                    rs.append(cur.val)</span><br><span class="line">                    prev = cur</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ss.append(cur)</span><br><span class="line">                    cur = cur.right</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="Morris">Morris</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        dummy = TreeNode(-<span class="number">1</span>)</span><br><span class="line">        dummy.left = root</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># look up predecessor in left sub-tree</span></span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># make threaded</span></span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    <span class="comment"># visit left node to predecessor</span></span><br><span class="line">                    tmp = node</span><br><span class="line">                    self.reverse(cur.left, node)</span><br><span class="line">                    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                        rs.append(tmp.val)</span><br><span class="line">                        <span class="keyword">if</span> tmp == cur.left:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        tmp = tmp.right</span><br><span class="line">                    self.reverse(node, cur.left)</span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> a == b:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = a</span><br><span class="line">        y = a.right</span><br><span class="line">        <span class="keyword">while</span> x != b:</span><br><span class="line">            z = y.right</span><br><span class="line">            y.right = x</span><br><span class="line">            x = y</span><br><span class="line">            y = z</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-postorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Inorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-inorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-inorder-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 07:32:04 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given bina]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the inorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [1,3,2].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<h2 id="分析">分析</h2><p>中序遍历，基本上沿用<a href="/2015/09/07/binary-tree-preorder-traversal/">上一题</a>的框架。</p>
<p>Morris遍历继续参考<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversalR</span><span class="params">(self, root, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorderTraversalR(root.left, rs)</span><br><span class="line">        rs.append(root.val)</span><br><span class="line">        self.inorderTraversalR(root.right, rs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        self.inorderTraversalR(root, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> ss:</span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                ss.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = ss.pop()</span><br><span class="line">                rs.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="Morris">Morris</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                rs.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># look up predecessor in left sub-tree</span></span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># make threaded</span></span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    rs.append(cur.val)</span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-inorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Binary Tree Preorder Traversal]]></title>
      <link>http://garfieldog.github.io/2015/09/07/binary-tree-preorder-traversal/</link>
      <guid>http://garfieldog.github.io/2015/09/07/binary-tree-preorder-traversal/</guid>
      <pubDate>Mon, 07 Sep 2015 07:00:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given bin]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:<br>Given binary tree {1,#,2,3},<br>   1<br>    \<br>     2<br>    /<br>   3<br>return [1,2,3].</p>
<p>Note: Recursive solution is trivial, could you do it iteratively?</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，二叉树的先序遍历。当使用迭代方法时，注意入栈的顺序，需要先push右节点，再push左节点。</p>
<p>还有一种不常用的方法<a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">Morris遍历</a>，可以做到空间<code>O(1)</code>，时间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversalR</span><span class="params">(self, root, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        rs.append(root.val)</span><br><span class="line">        self.preorderTraversalR(root.left, rs)</span><br><span class="line">        self.preorderTraversalR(root.right, rs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        self.preorderTraversalR(root, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            ss.append(root)</span><br><span class="line">        <span class="keyword">while</span> ss:</span><br><span class="line">            cur = ss.pop()</span><br><span class="line">            rs.append(cur.val)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                ss.append(cur.right)</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                ss.append(cur.left)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
<h3 id="Morris">Morris</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                rs.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># look up predecessor in left sub-tree</span></span><br><span class="line">                node = cur.left</span><br><span class="line">                <span class="keyword">while</span> node.right <span class="keyword">and</span> node.right != cur:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                    <span class="comment"># make threaded</span></span><br><span class="line">                    rs.append(cur.val)</span><br><span class="line">                    node.right = cur</span><br><span class="line">                    cur = cur.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># already threaded</span></span><br><span class="line">                    node.right = <span class="keyword">None</span></span><br><span class="line">                    cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/binary-tree-preorder-traversal/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Evaluate Reverse Polish Notation]]></title>
      <link>http://garfieldog.github.io/2015/09/07/evaluate-reverse-polish-notation/</link>
      <guid>http://garfieldog.github.io/2015/09/07/evaluate-reverse-polish-notation/</guid>
      <pubDate>Mon, 07 Sep 2015 06:37:01 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Some examples:<br>  [“2”, “1”, “+”, “3”, “*“] -&gt; ((2 + 1) * 3) -&gt; 9<br>  [“4”, “13”, “5”, “/“, “+”] -&gt; (4 + (13 / 5)) -&gt; 6</p>
</blockquote>
<h2 id="分析">分析</h2><p>逆波兰式求值，比较简单，注意代码里除法<code>int(float(a) / b))</code>是因为Python 2有一个奇葩的设置就是除法结果是负数的时候是向下取整的（我们需要向0取整）。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self, op, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> op == <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">return</span> a + b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> a - b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> a * b</span><br><span class="line">        <span class="keyword">elif</span> op == <span class="string">'/'</span>:</span><br><span class="line">            <span class="keyword">return</span> int(float(a) / b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type tokens: List[str]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">in</span> <span class="string">'+-*/'</span>:</span><br><span class="line">                b = ss.pop()</span><br><span class="line">                a = ss.pop()</span><br><span class="line">                ss.append(self.eval(t, a, b))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss.append(int(t))</span><br><span class="line">        <span class="keyword">return</span> ss[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/evaluate-reverse-polish-notation/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Largest Rectangle in Histogram]]></title>
      <link>http://garfieldog.github.io/2015/09/07/largest-rectangle-in-histogram/</link>
      <guid>http://garfieldog.github.io/2015/09/07/largest-rectangle-in-histogram/</guid>
      <pubDate>Mon, 07 Sep 2015 05:15:40 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, f]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<p><img src="/images/histogram.png" alt="histogram"><br>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p><img src="/images/histogram_area.png" alt="histogram-area"><br>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>For example,<br>Given height = [2,1,5,6,2,3],<br>return 10.</p>
</blockquote>
<h2 id="分析">分析</h2><p>时间<code>O(n^2)</code>的算法很容易想，每个位置上向两边扩散就可以。不过还可以更好：利用一个栈，栈内维护递增的序列，遇到破坏递增的元素就持续出栈（这时栈顶元素能围成多大的矩形已经可以计算），直到当前元素大于栈顶，继续入栈。详细分析可参考<a href="http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html" target="_blank" rel="external">这篇文章</a>。</p>
<p>注意<code>if not ss or height[i] &gt; height[ss[-1]]:</code> 中的判断<code>&gt;</code>还是<code>&gt;=</code>不影响正确性，想想为什么。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ss = []</span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        height.append(<span class="number">0</span>)</span><br><span class="line">        n = len(height)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss <span class="keyword">or</span> height[i] &gt; height[ss[-<span class="number">1</span>]]:</span><br><span class="line">                ss.append(i)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                idx = ss.pop()</span><br><span class="line">                w = i <span class="keyword">if</span> <span class="keyword">not</span> ss <span class="keyword">else</span> i - <span class="number">1</span> - ss[-<span class="number">1</span>]</span><br><span class="line">                max_area = max(max_area, height[idx] * w)</span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/07/largest-rectangle-in-histogram/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Longest Valid Parentheses]]></title>
      <link>http://garfieldog.github.io/2015/09/06/longest-valid-parentheses/</link>
      <guid>http://garfieldog.github.io/2015/09/06/longest-valid-parentheses/</guid>
      <pubDate>Sun, 06 Sep 2015 11:33:29 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-for]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>For “(()”, the longest valid parentheses substring is “()”, which has length = 2.</p>
<p>Another example is “)()())”, where the longest valid parentheses substring is “()()”, which has length = 4.</p>
<h2 id="分析">分析</h2><p>稍有难度，使用栈，时间<code>O(n)</code>，空间<code>O(n)</code>。</p>
</blockquote>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestValidParentheses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ss = []</span><br><span class="line">        n = len(s)</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        last = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">'('</span>:</span><br><span class="line">                ss.append(i)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                last = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss.pop()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">                    max_len = max(max_len, i - last)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    max_len = max(max_len, i - ss[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/longest-valid-parentheses/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Valid Parentheses]]></title>
      <link>http://garfieldog.github.io/2015/09/06/valid-parentheses/</link>
      <guid>http://garfieldog.github.io/2015/09/06/valid-parentheses/</guid>
      <pubDate>Sun, 06 Sep 2015 11:23:59 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input str]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单的Stack题，时间<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        d = &#123;</span><br><span class="line">            <span class="string">')'</span>: <span class="string">'('</span>,</span><br><span class="line">            <span class="string">'&#125;'</span>: <span class="string">'&#123;'</span>,</span><br><span class="line">            <span class="string">']'</span>: <span class="string">'['</span></span><br><span class="line">        &#125;</span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">'(&#123;['</span>:</span><br><span class="line">                ss.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">')&#125;]'</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ss <span class="keyword">or</span> d[c] != ss[-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                ss.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> ss</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/valid-parentheses/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Length of Last Word]]></title>
      <link>http://garfieldog.github.io/2015/09/06/length-of-last-word/</link>
      <guid>http://garfieldog.github.io/2015/09/06/length-of-last-word/</guid>
      <pubDate>Sun, 06 Sep 2015 09:42:05 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.</p>
<p>If the last word does not exist, return 0.</p>
<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>
<p>For example,<br>Given s = “Hello World”,<br>return 5.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，时间<code>O(n)</code>, 空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="One_Line_Solver">One Line Solver</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(s.rstrip().split(<span class="string">' '</span>)[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        last_space = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">' '</span>:</span><br><span class="line">                last_space = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            n = <span class="number">1</span> <span class="keyword">if</span> last_space <span class="keyword">else</span> n + <span class="number">1</span></span><br><span class="line">            last_space = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/length-of-last-word/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Simplify Path]]></title>
      <link>http://garfieldog.github.io/2015/09/06/simplify-path/</link>
      <guid>http://garfieldog.github.io/2015/09/06/simplify-path/</guid>
      <pubDate>Sun, 06 Sep 2015 09:25:02 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an absolute path for a file (Unix-style), simplify it.</p>
<p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”</p>
<p>Corner Cases:<br>Did you consider the case where path = “/../“?<br>In this case, you should return “/“.<br>Another corner case is the path might contain multiple slashes ‘/‘ together, such as “/home//foo/“.<br>In this case, you should ignore redundant slashes and return “/home/foo”.</p>
</blockquote>
<h2 id="分析">分析</h2><p>比较简单，用stack，注意corner cases。时间<code>O(n)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type path: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        ps = path.split(<span class="string">'/'</span>)</span><br><span class="line">        ss = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">            <span class="keyword">if</span> p == <span class="string">'.'</span> <span class="keyword">or</span> p == <span class="string">''</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> p == <span class="string">'..'</span>:</span><br><span class="line">                <span class="keyword">if</span> len(ss) &gt; <span class="number">0</span>:</span><br><span class="line">                    ss.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ss.append(p)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(ss)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/simplify-path/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Group Anagrams]]></title>
      <link>http://garfieldog.github.io/2015/09/06/group-anagrams/</link>
      <guid>http://garfieldog.github.io/2015/09/06/group-anagrams/</guid>
      <pubDate>Sun, 06 Sep 2015 08:30:58 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of strings, group anagrams together.</p>
<p>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:</p>
<p>[<br>  [“ate”, “eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note:<br>For the return value, each inner list’s elements must follow the lexicographic order.<br>All inputs will be in lower-case.</p>
</blockquote>
<h2 id="分析">分析</h2><p>用哈希表，理论上可以时间<code>O(nlogn)</code>，空间<code>O(n)</code>。我们下面的实现由于用了数组而不是链表，所以要慢一些，最坏情况<code>O(n^2)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            key = <span class="string">''</span>.join(sorted(s))</span><br><span class="line">            d.setdefault(key, [])</span><br><span class="line">            rs = d[key]</span><br><span class="line">            idx = bisect(rs, s)</span><br><span class="line">            rs.insert(idx, s)</span><br><span class="line">        <span class="keyword">return</span> d.values()</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/group-anagrams/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Count and Say]]></title>
      <link>http://garfieldog.github.io/2015/09/06/count-and-say/</link>
      <guid>http://garfieldog.github.io/2015/09/06/count-and-say/</guid>
      <pubDate>Sun, 06 Sep 2015 08:08:10 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The count-and-say sequence is the sequence of integers beginning as follows:<br>1, 11, 21, 1211, 111221, ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The count-and-say sequence is the sequence of integers beginning as follows:<br>1, 11, 21, 1211, 111221, …</p>
<p>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.<br>Given an integer n, generate the nth sequence.</p>
<p>Note: The sequence of integers will be represented as a string.</p>
</blockquote>
<h2 id="分析">分析</h2><p>暴力法模拟可解，时间复杂度<code>O(n^2)</code>，空间<code>O(n)</code>，实现不难。更好的方法没有想到。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        s = [<span class="string">'1'</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>):</span><br><span class="line">            rs = []</span><br><span class="line">            last = <span class="keyword">None</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> last <span class="keyword">or</span> c == last:</span><br><span class="line">                    last = c</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    rs.append(str(count))</span><br><span class="line">                    rs.append(last)</span><br><span class="line">                    last = c</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">            rs.append(str(count))</span><br><span class="line">            rs.append(c)</span><br><span class="line">            s = rs</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(s)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/count-and-say/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Roman to Integer]]></title>
      <link>http://garfieldog.github.io/2015/09/06/roman-to-integer/</link>
      <guid>http://garfieldog.github.io/2015/09/06/roman-to-integer/</guid>
      <pubDate>Sun, 06 Sep 2015 07:45:37 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999</p>
</blockquote>
<h2 id="分析">分析</h2><p>比<a href="/2015/09/06/integer-to-roman/">Integer to Roman</a>简单多了，是加法规则还是减法规则很好判断。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        d = &#123;</span><br><span class="line">            <span class="string">'M'</span>: <span class="number">1000</span>,</span><br><span class="line">            <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">'I'</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = len(s)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            a = d[s[i]]</span><br><span class="line">            <span class="keyword">if</span> i &lt; n - <span class="number">1</span> <span class="keyword">and</span> a &lt; d[s[i + <span class="number">1</span>]]:</span><br><span class="line">                a = -a</span><br><span class="line">            r += a</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/roman-to-integer/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Integer to Roman]]></title>
      <link>http://garfieldog.github.io/2015/09/06/integer-to-roman/</link>
      <guid>http://garfieldog.github.io/2015/09/06/integer-to-roman/</guid>
      <pubDate>Sun, 06 Sep 2015 06:06:29 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an integer, convert it to a roman numeral.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要考虑<a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97" target="_blank" rel="external">罗马数字</a>的加法规则和减法规则，要写对还是有一定技巧的，下面是一个精巧的解法。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        romans = [</span><br><span class="line">            (<span class="string">'M'</span>, <span class="number">1000</span>),</span><br><span class="line">            (<span class="string">'CM'</span>, <span class="number">900</span>),</span><br><span class="line">            (<span class="string">'D'</span>, <span class="number">500</span>),</span><br><span class="line">            (<span class="string">'CD'</span>, <span class="number">400</span>),</span><br><span class="line">            (<span class="string">'C'</span>, <span class="number">100</span>),</span><br><span class="line">            (<span class="string">'XC'</span>, <span class="number">90</span>),</span><br><span class="line">            (<span class="string">'L'</span>, <span class="number">50</span>),</span><br><span class="line">            (<span class="string">'XL'</span>, <span class="number">40</span>),</span><br><span class="line">            (<span class="string">'X'</span>, <span class="number">10</span>),</span><br><span class="line">            (<span class="string">'IX'</span>, <span class="number">9</span>),</span><br><span class="line">            (<span class="string">'V'</span>, <span class="number">5</span>),</span><br><span class="line">            (<span class="string">'IV'</span>, <span class="number">4</span>),</span><br><span class="line">            (<span class="string">'I'</span>, <span class="number">1</span>)</span><br><span class="line">        ]</span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">for</span> s, n <span class="keyword">in</span> romans:</span><br><span class="line">            c, num = divmod(num, n)</span><br><span class="line">            rs.extend([s] * c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(rs)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/integer-to-roman/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Valid Number]]></title>
      <link>http://garfieldog.github.io/2015/09/06/valid-number/</link>
      <guid>http://garfieldog.github.io/2015/09/06/valid-number/</guid>
      <pubDate>Sun, 06 Sep 2015 02:41:27 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Validate if a given string is numeric.</p>
<p>Some examples:<br>“0” =&gt; true<br>“ 0.1 “ =&gt; true<br>“]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Validate if a given string is numeric.</p>
<p>Some examples:<br>“0” =&gt; true<br>“ 0.1 “ =&gt; true<br>“abc” =&gt; false<br>“1 a” =&gt; false<br>“2e10” =&gt; true<br>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p>
</blockquote>
<h2 id="分析">分析</h2><p>有难度，需要构建状态机。画出来是这个样子的：</p>
<p><img src="/images/valid_number_automata.png" alt="automata"></p>
<p>上面的图是用<a href="http://www.graphviz.org/" target="_blank" rel="external">Graphviz</a>画的，非常好用。贴一下上图的dot语言源码:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">digraph</span> valid_number &#123; </span><br><span class="line">    rankdir<span class="label">=LR</span><span class="comment">;</span></span><br><span class="line">    node [shape = circle]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S1</span> [shape = doublecircle]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S4</span> [shape = doublecircle]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S7</span> [shape = doublecircle]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S8</span> [shape = doublecircle]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S0</span> -&gt; <span class="literal">S0</span> [label = <span class="string">"space"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S0</span> -&gt; <span class="literal">S3</span> [label = <span class="string">"+, -"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S0</span> -&gt; <span class="literal">S1</span> [label = <span class="string">"[0-9]"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S0</span> -&gt; <span class="literal">S2</span> [label = <span class="string">"."</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S0</span> -&gt; SS [label = <span class="string">"other"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S1</span> -&gt; <span class="literal">S8</span> [label = <span class="string">"space"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S1</span> -&gt; <span class="literal">S1</span> [label = <span class="string">"[0-9]"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S1</span> -&gt; <span class="literal">S4</span> [label = <span class="string">"."</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S1</span> -&gt; <span class="literal">S5</span> [label = <span class="string">"e"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S1</span> -&gt; SS [label = <span class="string">"other"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S2</span> -&gt; <span class="literal">S4</span> [label = <span class="string">"[0-9]"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S2</span> -&gt; SS [label = <span class="string">"other"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S3</span> -&gt; <span class="literal">S1</span> [label = <span class="string">"[0-9]"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S3</span> -&gt; <span class="literal">S2</span> [label = <span class="string">"."</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S3</span> -&gt; SS [label = <span class="string">"other"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S4</span> -&gt; <span class="literal">S8</span> [label = <span class="string">"space"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S4</span> -&gt; <span class="literal">S4</span> [label = <span class="string">"[0-9]"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S4</span> -&gt; <span class="literal">S5</span> [label = <span class="string">"e"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S4</span> -&gt; SS [label = <span class="string">"other"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S5</span> -&gt; <span class="literal">S6</span> [label = <span class="string">"+, -"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S5</span> -&gt; <span class="literal">S7</span> [label = <span class="string">"[0-9]"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S5</span> -&gt; SS [label = <span class="string">"other"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S6</span> -&gt; <span class="literal">S7</span> [label = <span class="string">"[0-9]"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S6</span> -&gt; SS [label = <span class="string">"other"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S7</span> -&gt; <span class="literal">S8</span> [label = <span class="string">"space"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S7</span> -&gt; <span class="literal">S7</span> [label = <span class="string">"[0-9]"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S7</span> -&gt; SS [label = <span class="string">"other"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S8</span> -&gt; <span class="literal">S8</span> [label = <span class="string">"space"</span>]<span class="comment">;</span></span><br><span class="line">    <span class="literal">S8</span> -&gt; SS [label = <span class="string">"other"</span>]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度<code>O(n)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCharType</span><span class="params">(self, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">' '</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">'+'</span> <span class="keyword">or</span> c == <span class="string">'-'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">'0123456789'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">'.'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">'e'</span> <span class="keyword">or</span> c == <span class="string">'E'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getAutoMata</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            (-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>),</span><br><span class="line">            (-<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>),</span><br><span class="line">            (-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">            (-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>),</span><br><span class="line">            (-<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">            (-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">            (-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">            (-<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, <span class="number">7</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">            (-<span class="number">1</span>, <span class="number">8</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        m = self.getAutoMata()</span><br><span class="line">        state = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            t = self.getCharType(c)</span><br><span class="line">            state = m[state][t]</span><br><span class="line">            <span class="keyword">if</span> state == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> state <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/valid-number/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Longest Common Prefix]]></title>
      <link>http://garfieldog.github.io/2015/09/06/longest-common-prefix/</link>
      <guid>http://garfieldog.github.io/2015/09/06/longest-common-prefix/</guid>
      <pubDate>Sun, 06 Sep 2015 01:43:36 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
</blockquote>
]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write a function to find the longest common prefix string amongst an array of strings.</p>
</blockquote>
<h2 id="分析">分析</h2><p>简单题，但容易想复杂。第一反应是用trie树，可以做，但实现较复杂。其实只要按位置依次比对每一个字符串，直到有不相等的情况出现即可。时间复杂度<code>O(n1 + n2 + ...)</code>，空间复杂度<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(strs[<span class="number">0</span>])):</span><br><span class="line">            stop = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, len(strs)):</span><br><span class="line">                <span class="keyword">if</span> len(strs[j]) &lt;= i <span class="keyword">or</span> strs[<span class="number">0</span>][i] != strs[j][i]:</span><br><span class="line">                    stop = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> stop:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:idx]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/06/longest-common-prefix/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Wildcard Matching]]></title>
      <link>http://garfieldog.github.io/2015/09/02/wildcard-matching/</link>
      <guid>http://garfieldog.github.io/2015/09/02/wildcard-matching/</guid>
      <pubDate>Wed, 02 Sep 2015 04:20:18 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement wildcard pattern matching with support for ‘?’ and ‘*‘.</p>
<p>‘?’ Matches any single character]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement wildcard pattern matching with support for ‘?’ and ‘*‘.</p>
<p>‘?’ Matches any single character.<br>‘*‘ Matches any sequence of characters (including the empty sequence).</p>
<p>The matching should cover the entire input string (not partial).</p>
<p>The function prototype should be:<br>bool isMatch(const char *s, const char *p)</p>
<p>Some examples:<br>isMatch(“aa”,”a”) → false<br>isMatch(“aa”,”aa”) → true<br>isMatch(“aaa”,”aa”) → false<br>isMatch(“aa”, “*“) → true<br>isMatch(“aa”, “a*“) → true<br>isMatch(“ab”, “?*“) → true<br>isMatch(“aab”, “c*a*b”) → false</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/09/01/regular-expression-matching/">Regular Expression Matching</a>很像，但<code>*</code>的解释是不一样的，正则中<code>*</code>是匹配它前面一个字符出现0或多次，通配符中<code>*</code>可以匹配任意字符出现0或多次。</p>
<p>可以套用上一题的动态规划解法，时间空间都是<code>O(mn)</code>（其实空间可以降到<code>O(m)</code>），但这个解法在网站上提交会超时，有一个更有效率的迭代解法可以参考<a href="http://www.cnblogs.com/zuoyuan/p/3781872.html" target="_blank" rel="external">这里</a>。这个解法的关键在于遇到<code>*</code>时进行<code>反贪心</code>( 就是首先考虑一个字符都不匹配的情况)匹配，如果失败则增加匹配字符数进行回溯。时间<code>O(mn)</code>，空间<code>O(1)</code>。</p>
<h2 id="代码">代码</h2><h3 id="动态规划">动态规划</h3><p>由于Leetcode测试用例中有非常长的串，该算法会判超时<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatchChar</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a == b <span class="keyword">or</span> b == <span class="string">'?'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type p: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        m = len(p)</span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># first row, s == ''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[i - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> self.isMatchChar(s[i - <span class="number">1</span>], p[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure></p>
<h3 id="递归">递归</h3><p>超时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatchChar</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a == b <span class="keyword">or</span> b == <span class="string">'?'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatchR</span><span class="params">(self, s, i, p, j)</span>:</span></span><br><span class="line">        m, n = len(p), len(s)</span><br><span class="line">        <span class="keyword">if</span> j == m:</span><br><span class="line">            <span class="keyword">return</span> i == n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j == m:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> <span class="keyword">not</span> self.isMatchR(s, i, p, j):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i &lt; n</span><br><span class="line">        <span class="keyword">elif</span> i == n:</span><br><span class="line">            <span class="keyword">return</span> j == m</span><br><span class="line">        <span class="keyword">elif</span> self.isMatchChar(s[i], p[j]):</span><br><span class="line">            <span class="keyword">return</span> self.isMatchR(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type p: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.isMatchR(s, <span class="number">0</span>, p, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatchChar</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a == b <span class="keyword">or</span> b == <span class="string">'?'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type p: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        m = len(p)</span><br><span class="line">        n = len(s)</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        star = -<span class="number">1</span></span><br><span class="line">        si = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            <span class="keyword">if</span> j &lt; m <span class="keyword">and</span> self.isMatchChar(s[i], p[j]):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &lt; m <span class="keyword">and</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                si = i  <span class="comment"># store matched position for s</span></span><br><span class="line">                star = j  <span class="comment"># store star position</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># p[j] != '*' and s[i] is not mathced to p[j]</span></span><br><span class="line">            <span class="keyword">elif</span> star &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># has star, consume one char in s, and search back</span></span><br><span class="line">                j = star + <span class="number">1</span></span><br><span class="line">                si += <span class="number">1</span></span><br><span class="line">                i = si</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># no star and not match</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; m <span class="keyword">and</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> j == m</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/02/wildcard-matching/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Regular Expression Matching]]></title>
      <link>http://garfieldog.github.io/2015/09/01/regular-expression-matching/</link>
      <guid>http://garfieldog.github.io/2015/09/01/regular-expression-matching/</guid>
      <pubDate>Tue, 01 Sep 2015 10:30:11 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement regular expression matching with support for ‘.’ and ‘*‘.</p>
<p>‘.’ Matches any single charact]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement regular expression matching with support for ‘.’ and ‘*‘.</p>
<p>‘.’ Matches any single character.<br>‘*‘ Matches zero or more of the preceding element.</p>
<p>The matching should cover the entire input string (not partial).</p>
<p>The function prototype should be:<br>bool isMatch(const char *s, const char *p)</p>
<p>Some examples:<br>isMatch(“aa”,”a”) → false<br>isMatch(“aa”,”aa”) → true<br>isMatch(“aaa”,”aa”) → false<br>isMatch(“aa”, “a*“) → true<br>isMatch(“aa”, “.*“) → true<br>isMatch(“ab”, “.*“) → true<br>isMatch(“aab”, “c*a*b”) → true</p>
</blockquote>
<h2 id="分析">分析</h2><p>有一定难度，主要是判断<code>*</code>。可以采取<a href="http://articles.leetcode.com/2011/09/regular-expression-matching.html" target="_blank" rel="external">递归法</a>或<a href="http://www.cnblogs.com/flowerkzj/p/3726667.html" target="_blank" rel="external">动态规划</a>。当然，转换为DFA自动机然后做也是没问题的，但实现难度就要更大一些。</p>
<h3 id="TBD">TBD</h3><p>算法分析参考上面给的两篇文章链接。具体分析有点复杂，先留空，刷完题再补。</p>
<h2 id="代码">代码</h2><h3 id="递归法">递归法</h3><p>Leetcode上提交会超时<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">END = <span class="string">'\001'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatchR</span><span class="params">(self, s, i, p, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p[j] == END:</span><br><span class="line">            <span class="keyword">return</span> s[i] == END</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p[j + <span class="number">1</span>] != <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> (p[j] == s[i] <span class="keyword">or</span> (p[j] == <span class="string">'.'</span> <span class="keyword">and</span> s[i] != END)) \</span><br><span class="line">                <span class="keyword">and</span> self.isMatchR(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># p[j] == '*'</span></span><br><span class="line">        <span class="keyword">while</span>(p[j] == s[i] <span class="keyword">or</span> (p[j] == <span class="string">'.'</span> <span class="keyword">and</span> s[i] != END)):</span><br><span class="line">            <span class="keyword">if</span> self.isMatchR(s, i, p, j + <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.isMatchR(s, i, p, j + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type p: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        s += END</span><br><span class="line">        p += END</span><br><span class="line">        <span class="keyword">return</span> self.isMatchR(s, <span class="number">0</span>, p, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="动态规划">动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatchChar</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a == b <span class="keyword">or</span> b == <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type p: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        m = len(p)</span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># fisrt row, s == ''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> p[i - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">                    dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>]</span><br><span class="line">            <span class="comment"># otherwise leave dp[0][i] = False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># leave dp[i][0] = False for i &gt; 0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                    <span class="comment"># j must &gt; 1</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] <span class="keyword">or</span> dp[i][j - <span class="number">2</span>] <span class="keyword">or</span> \</span><br><span class="line">                        (dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> self.isMatchChar(s[i - <span class="number">1</span>], p[j - <span class="number">2</span>]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] <span class="keyword">and</span> self.isMatchChar(s[i - <span class="number">1</span>], p[j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[n][m]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/01/regular-expression-matching/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
