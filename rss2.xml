<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Wed, 16 Sep 2015 10:57:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Container with Most Water]]></title>
      <link>http://garfieldog.github.io/2015/09/16/container-with-most-water/</link>
      <guid>http://garfieldog.github.io/2015/09/16/container-with-most-water/</guid>
      <pubDate>Wed, 16 Sep 2015 10:36:15 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n verti]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container.</p>
</blockquote>
<h2 id="分析">分析</h2><p><code>O(n^2)</code>的算法很简单，双重循环找到最优解，但显然超时。可以只用一次遍历，使用两指针，分别从头和从尾部开始，计算他们之间的面积，如果头部的木板比尾部的低，则可以直接将头指针后移，因为这已经是以它为第一块木板所能够围成的最大面积。如果比尾部高，则尾指针前移。很像<a href="/2015/08/22/trapping-rain-water/">Trapping Rain Water</a>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high):</span><br><span class="line">            area = min(height[low], height[high]) * (high - low)</span><br><span class="line">            max_area = max(max_area, area)</span><br><span class="line">            <span class="keyword">if</span> height[low] &lt;= height[high]:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/container-with-most-water/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Longest Substring Without Repeating Characters]]></title>
      <link>http://garfieldog.github.io/2015/09/16/longest-substring-without-repeating-characters/</link>
      <guid>http://garfieldog.github.io/2015/09/16/longest-substring-without-repeating-characters/</guid>
      <pubDate>Wed, 16 Sep 2015 09:53:57 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the l]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
</blockquote>
<h2 id="分析">分析</h2><p><code>O(n^2)</code>的算法很容易想，在每个位置上找满足要求的子串。必然会超时。我们借用KMP类似的思想，发现重复字符时步子可以迈得大一点。我们发现在重复字符上一次出现之前的部分都不用在搜索了，因为肯定不会产生比现有子串更长的了。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        last = &#123;&#125;</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            last_idx = last.get(s[i], -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> last_idx &gt;= start:</span><br><span class="line">                max_len = max(i - start, max_len)</span><br><span class="line">                start = last_idx + <span class="number">1</span></span><br><span class="line">            last[s[i]] = i</span><br><span class="line">        <span class="keyword">return</span> max(n - start, max_len)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/longest-substring-without-repeating-characters/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Best Time to Buy and Sell Stock IV]]></title>
      <link>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-4/</link>
      <guid>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-4/</guid>
      <pubDate>Wed, 16 Sep 2015 09:06:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/16/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock</a>的后继问题，这次彻底灵活了，可以买卖k次，同样任何时刻手上最多持有1股。</p>
<p>如果<code>k &gt; n / 2</code> 其实就退化成了不限次数买卖的情况，就是<a href="/2015/09/16/best-time-to-buy-and-sell-stock-2/">系列中的第二题</a>的情况。然后我们构造这样一个二维动态规划状态转移方程，令<code>local[i][j]</code>为在截止第i天最多可j次交易并且最后一次交易在最后一天卖出的最大利润，<code>global[i][j]</code>为在截止第i天时最多可j次交易的最大利润，目标就是<code>global[n - 1][k]</code>。</p>
<pre><code>local[<span class="link_label">i</span>][<span class="link_reference">j</span>] = max(global[<span class="link_label">i - 1</span>][<span class="link_reference">j - 1</span>] + max(diff, 0), local[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>] + diff)
global[<span class="link_label">i</span>][<span class="link_reference">j</span>] = max(local[<span class="link_label">i</span>][<span class="link_reference">j</span>], global[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>])
</code></pre><h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type k: int</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; n / <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.maxProfitNoLimit(prices)</span><br><span class="line">        l = [<span class="number">0</span>] * (k + <span class="number">1</span>)</span><br><span class="line">        g = [<span class="number">0</span>] * (k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            diff = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                l[j] = max(g[j - <span class="number">1</span>] + max(diff, <span class="number">0</span>), l[j] + diff)</span><br><span class="line">                g[j] = max(l[j], g[j])</span><br><span class="line">        <span class="keyword">return</span> g[k]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfitNoLimit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            diff = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            profit += max(<span class="number">0</span>, diff)</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Best Time to Buy and Sell Stock III]]></title>
      <link>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-3/</link>
      <guid>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-3/</guid>
      <pubDate>Wed, 16 Sep 2015 08:17:46 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/16/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock</a>的后继问题，这次可以买卖两次，但任何时刻手上最多只能持有1股。这下就难了不少，可以考虑分治法，遍历数组位置<code>i</code>，分别用<a href="/2015/09/16/best-time-to-buy-and-sell-stock/">这一题</a>中的算法求<code>[0..i]</code>和<code>[i..n-1]</code>的最大利润，再挑选最佳位置<code>i</code>。时间复杂度<code>O(n^2)</code>，这个解法会超时。</p>
<p>我们观察上面这个算法，它要求的<code>f(0, i), 0 &lt;= i &lt; n</code>其实可以在一次遍历中全部求出，只要我们的算法加一个缓存数组就可以了。同理<code>f(i, n)</code>也是一样的，倒着求就行。这样一来，我们只要扫描两遍数组，就能得到想要的部分解了。时间复杂度降到了<code>O(n)</code>，空间<code>O(n)</code>。有点像<a href="/2015/08/22/trapping-rain-water/">Trapping Rain Water</a>的解法。</p>
<h2 id="代码">代码</h2><h3 id="分治法（超时）">分治法（超时）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfitPartial</span><span class="params">(self, prices, start, end)</span>:</span></span><br><span class="line">        n = end - start + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        cur_min = prices[start]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">            profit = max(profit, prices[i] - cur_min)</span><br><span class="line">            cur_min = min(cur_min, prices[i])</span><br><span class="line">        <span class="keyword">return</span> profit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            profit = self.maxProfitPartial(prices, <span class="number">0</span>, i) + self.maxProfitPartial(prices, i, n - <span class="number">1</span>)</span><br><span class="line">            max_profit = max(max_profit, profit)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<h3 id="动态规划">动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfitPartial</span><span class="params">(self, prices, start, end)</span>:</span></span><br><span class="line">        n = end - start + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        cur_min = prices[start]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">            profit = max(profit, prices[i] - cur_min)</span><br><span class="line">            cur_min = min(cur_min, prices[i])</span><br><span class="line">        <span class="keyword">return</span> profit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = [<span class="number">0</span>] * n</span><br><span class="line">        cur_min = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            left[i] = max(left[i - <span class="number">1</span>], prices[i] - cur_min)</span><br><span class="line">            cur_min = min(cur_min, prices[i])</span><br><span class="line"></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        cur_max = prices[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            profit = max(profit, cur_max - prices[i])</span><br><span class="line">            cur_max = max(cur_max, prices[i])</span><br><span class="line">            max_profit = max(max_profit, profit + left[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Best Time to Buy and Sell Stock II]]></title>
      <link>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-2/</link>
      <guid>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-2/</guid>
      <pubDate>Wed, 16 Sep 2015 08:04:56 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/16/best-time-to-buy-and-sell-stock/">上一题</a>的后继问题，这次仍然做时候诸葛亮，而且可以买卖多次，但是有个条件就是手上最多持有1股。非常简单，就是找每一个递增的区间，在区间底部买入，顶部卖出即可，一遍扫描。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            diff = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            profit += max(<span class="number">0</span>, diff)</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Best Time to Buy and Sell Stock]]></title>
      <link>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock/</link>
      <guid>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock/</guid>
      <pubDate>Wed, 16 Sep 2015 07:50:49 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you wer]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要理解题意，给定一只股票一段时间内每天的估价，做一下事后诸葛亮，问如果只做一次交易（买一次买一次，注意不能卖空，所以必须先买后卖），所以就是找到低价，然后高价卖出，要求是低价必须在高价前面。扫描一遍数组即可，维护当前的最大利润和当前最低价。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        cur_min = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            profit = max(profit, prices[i] - cur_min)</span><br><span class="line">            cur_min = min(cur_min, prices[i])</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Jump Game II]]></title>
      <link>http://garfieldog.github.io/2015/09/16/jump-game-2/</link>
      <guid>http://garfieldog.github.io/2015/09/16/jump-game-2/</guid>
      <pubDate>Wed, 16 Sep 2015 07:11:06 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>For example:<br>Given array A = [2,3,1,1,4]</p>
<p>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/16/jump-game/">Jump Game</a>的后继问题，这次要求得出最小跳跃步数，我们用两个变量来分别记录<code>现在到达的位置</code>和<code>下一次最大能到达的未知</code>，遍历数组，如果下标超出<code>现在到达的位置</code>，则说明需要跳一步。比较巧妙，需要仔细推敲。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        reach = <span class="number">0</span></span><br><span class="line">        next_reach = <span class="number">0</span></span><br><span class="line">        step = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> step &gt; <span class="number">0</span>:</span><br><span class="line">                step -= <span class="number">1</span></span><br><span class="line">                step = max(step, nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i &gt; reach:</span><br><span class="line">                reach = next_reach</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            next_reach = max(next_reach, i + nums[i])</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/jump-game-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Jump Game]]></title>
      <link>http://garfieldog.github.io/2015/09/16/jump-game/</link>
      <guid>http://garfieldog.github.io/2015/09/16/jump-game/</guid>
      <pubDate>Wed, 16 Sep 2015 06:30:34 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
</blockquote>
<h2 id="分析">分析</h2><p>DFS固然是可以，但其实可以只保留一条路径（就是每次都选可选范围内下一个最大的步数，反证法可证如果有解，这样肯定能找到一个解），其他路径都被剪枝，这样一来就满足了贪心法的条件。</p>
<h2 id="代码">代码</h2><h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        step = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> step &gt; <span class="number">0</span>:</span><br><span class="line">                step -= <span class="number">1</span></span><br><span class="line">                step = max(step, nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/jump-game/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Sqrt(x)]]></title>
      <link>http://garfieldog.github.io/2015/09/16/sqrt-x/</link>
      <guid>http://garfieldog.github.io/2015/09/16/sqrt-x/</guid>
      <pubDate>Wed, 16 Sep 2015 06:13:57 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
</blockquote>
<h2 id="分析">]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
</blockquote>
<h2 id="分析">分析</h2><p>二分查找。注意结果要向下取整时返回<code>high</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        low = <span class="number">1</span></span><br><span class="line">        high = x / <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            r = mid * mid</span><br><span class="line">            <span class="keyword">if</span> r == x:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> r &lt; x:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> high</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/sqrt-x/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Pow(x, n)]]></title>
      <link>http://garfieldog.github.io/2015/09/16/pow-x-n/</link>
      <guid>http://garfieldog.github.io/2015/09/16/pow-x-n/</guid>
      <pubDate>Wed, 16 Sep 2015 05:47:11 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement pow(x, n).</p>
</blockquote>
<h2 id="分析">分析</h2><p>二分法，递归很简单，迭代有一定技巧。</p>
<h2 id="代码">代码</h2><h]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement pow(x, n).</p>
</blockquote>
<h2 id="分析">分析</h2><p>二分法，递归很简单，迭代有一定技巧。</p>
<h2 id="代码">代码</h2><h3 id="递归">递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: float</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: float</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">        positive = n &gt; <span class="number">0</span></span><br><span class="line">        n = abs(n)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            r = x * self.myPow(x, n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = self.myPow(x, n / <span class="number">2</span>)</span><br><span class="line">            r = r * r</span><br><span class="line">        <span class="keyword">return</span> r <span class="keyword">if</span> positive <span class="keyword">else</span> <span class="number">1</span> / r</span><br></pre></td></tr></table></figure>
<h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: float</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: float</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span> / self.myPow(x, -n)</span><br><span class="line">        left = x</span><br><span class="line">        right = <span class="number">1.0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                right *= left</span><br><span class="line">            left *= left</span><br><span class="line">            n /= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> left * right</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/pow-x-n/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Word Search]]></title>
      <link>http://garfieldog.github.io/2015/09/16/word-search/</link>
      <guid>http://garfieldog.github.io/2015/09/16/word-search/</guid>
      <pubDate>Wed, 16 Sep 2015 03:34:04 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>For example,<br>Given board =</p>
<p>[<br>  [“ABCE”],<br>  [“SFCS”],<br>  [“ADEE”]<br>]<br>word = “ABCCED”, -&gt; returns true,<br>word = “SEE”, -&gt; returns true,<br>word = “ABCB”, -&gt; returns false.</p>
</blockquote>
<h2 id="分析">分析</h2><p>回溯+DFS，一开始的思路是先找到第一个字符，然后在上面开始深搜，结果一直有bug，在一些corner case上会陷入死循环。回到最简单的方式，在所有格子上深搜。</p>
<h2 id="代码">代码</h2><h3 id="DFS_+_回溯">DFS + 回溯</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, word, start, x, y, used)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        m = len(board)</span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> x &gt;= m <span class="keyword">or</span> y &gt;= n <span class="keyword">or</span> board[x][y] != word[start] <span class="keyword">or</span> used[x][y]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        used[x][y] = <span class="keyword">True</span></span><br><span class="line">        candidates = [(x - <span class="number">1</span>, y), (x + <span class="number">1</span>, y), (x, y - <span class="number">1</span>), (x, y + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="keyword">if</span> self.dfs(board, word, start + <span class="number">1</span>, i, j, used):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        used[x][y] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type board: List[List[str]]</span><br><span class="line">        :type word: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        m = len(board)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(word) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        used = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                <span class="keyword">if</span> self.dfs(board, word, <span class="number">0</span>, i, j, used):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/word-search/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Sudoku Solver]]></title>
      <link>http://garfieldog.github.io/2015/09/16/sudoku-solver/</link>
      <guid>http://garfieldog.github.io/2015/09/16/sudoku-solver/</guid>
      <pubDate>Wed, 16 Sep 2015 02:03:58 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>Empty cells are indicated by the character ‘.’.</p>
<p>You may assume that there will be only one unique solution.</p>
<p><img src="/images/sudoku1.png" alt="puzzle"></p>
<p><img src="/images/sudoku2.png" alt="solver"></p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题是有一定难度的，虽然也是回溯法，但和我们之前熟悉的模式不同，不具备使用dfs的条件，因为『待填充』的位置之间不具备联通关系，使用一个三重循环来回溯。时间复杂度<code>O(n^4)</code>，如果使用三个哈希表来保存对应位置<code>行、列、九宫格</code>可用的数字，时间复杂度可降到<code>O(n^3)</code>，空间<code>O(n^2)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveSudoku</span><span class="params">(self, board)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type board: List[List[str]]</span><br><span class="line">        :rtype: void Do not return anything, modify board in-place instead.</span><br><span class="line">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">9</span>):</span><br><span class="line">                    <span class="keyword">if</span> board[x][y] == <span class="string">'.'</span>:</span><br><span class="line">                        z = x / <span class="number">3</span> * <span class="number">3</span> + y / <span class="number">3</span></span><br><span class="line">                        available = row[x] &amp; col[y] &amp; grid[z]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> available:</span><br><span class="line">                            board[x][y] = i</span><br><span class="line">                            row[x].remove(i)</span><br><span class="line">                            col[y].remove(i)</span><br><span class="line">                            grid[z].remove(i)</span><br><span class="line">                            <span class="keyword">if</span> solve():</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                            board[x][y] = <span class="string">'.'</span></span><br><span class="line">                            row[x].add(i)</span><br><span class="line">                            col[y].add(i)</span><br><span class="line">                            grid[z].add(i)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        row = defaultdict(<span class="keyword">lambda</span>: set(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line">        col = defaultdict(<span class="keyword">lambda</span>: set(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line">        grid = defaultdict(<span class="keyword">lambda</span>: set(str(x) <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[x][y] != <span class="string">'.'</span>:</span><br><span class="line">                    z = x / <span class="number">3</span> * <span class="number">3</span> + y / <span class="number">3</span></span><br><span class="line">                    row[x].remove(board[x][y])</span><br><span class="line">                    col[y].remove(board[x][y])</span><br><span class="line">                    grid[z].remove(board[x][y])</span><br><span class="line">        solve()</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/sudoku-solver/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Generate Parentheses]]></title>
      <link>http://garfieldog.github.io/2015/09/16/generate-parentheses/</link>
      <guid>http://garfieldog.github.io/2015/09/16/generate-parentheses/</guid>
      <pubDate>Wed, 16 Sep 2015 01:43:31 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<p>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”</p>
</blockquote>
<h2 id="分析">分析</h2><p>依然是熟悉的回溯法，不过这次我们需要一个额外的栈（其实一个整数变量就可以）来保证括号的匹配性。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, n1, n2, stack, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == n1 <span class="keyword">and</span> n == n2:</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n1 &lt; n:</span><br><span class="line">            path.append(<span class="string">'('</span>)</span><br><span class="line">            self.dfs(n, n1 + <span class="number">1</span>, n2, stack + <span class="number">1</span>, path, rs)</span><br><span class="line">            path.pop()</span><br><span class="line">        <span class="keyword">if</span> n2 &lt; n <span class="keyword">and</span> stack &gt; <span class="number">0</span>:</span><br><span class="line">            path.append(<span class="string">')'</span>)</span><br><span class="line">            self.dfs(n, n1, n2 + <span class="number">1</span>, stack - <span class="number">1</span>, path, rs)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, path, rs)</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">''</span>.join(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/generate-parentheses/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Combination Sum III]]></title>
      <link>http://garfieldog.github.io/2015/09/15/combination-sum-3/</link>
      <guid>http://garfieldog.github.io/2015/09/15/combination-sum-3/</guid>
      <pubDate>Tue, 15 Sep 2015 11:42:08 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Ensure that numbers within the set are sorted in ascending order.</p>
<p>Example 1:</p>
<p>Input: k = 3, n = 7</p>
<p>Output:</p>
<p>[[1,2,4]]</p>
<p>Example 2:</p>
<p>Input: k = 3, n = 9</p>
<p>Output:</p>
<p>[[1,2,6], [1,3,5], [2,3,4]]<br>Credits:<br>Special thanks to @mithmatt for adding this problem and creating all test cases.</p>
</blockquote>
<h2 id="分析">分析</h2><p>和<a href="/2015/09/15/combination-sum/">Combination Sum</a>、<a href="/2015/09/15/combination-sum-2/">Combination Sum II</a>这两道题是一系列的，解法也大同小异。这次多了一个步长。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, k, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(candidates)):</span><br><span class="line">            c = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> candidates[i] <span class="keyword">and</span> (<span class="keyword">not</span> path <span class="keyword">or</span> c &gt;= path[-<span class="number">1</span>]) <span class="keyword">and</span> target - c &gt;= <span class="number">0</span>:</span><br><span class="line">                path.append(c)</span><br><span class="line">                candidates[i] = <span class="number">1</span></span><br><span class="line">                self.dfs(candidates, target - c, k - <span class="number">1</span>, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line">                candidates[i] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type k: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        candidates = [<span class="number">0</span>] * <span class="number">9</span></span><br><span class="line">        self.dfs(candidates, n, k, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/combination-sum-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Combination Sum II]]></title>
      <link>http://garfieldog.github.io/2015/09/15/combination-sum-2/</link>
      <guid>http://garfieldog.github.io/2015/09/15/combination-sum-2/</guid>
      <pubDate>Tue, 15 Sep 2015 11:29:14 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C wh]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>Each number in C may only be used once in the combination.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set 10,1,2,7,6,1,5 and target 8,<br>A solution set is:<br>[1, 7]<br>[1, 2, 5]<br>[2, 6]<br>[1, 1, 6] </p>
</blockquote>
<h2 id="分析">分析</h2><p>这次要求一个元素只能用一次（但同样数值的元素可能出现多次，我们用一个OrderedDict来存储计数），稍微修改<a href="/2015/09/15/combination-sum/">Combination Sum</a>中的答案就可以了。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict, Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> c, v <span class="keyword">in</span> candidates.iteritems():</span><br><span class="line">            <span class="keyword">if</span> v &gt; <span class="number">0</span> <span class="keyword">and</span> (<span class="keyword">not</span> path <span class="keyword">or</span> c &gt;= path[-<span class="number">1</span>]) <span class="keyword">and</span> target - c &gt;= <span class="number">0</span>:</span><br><span class="line">                path.append(c)</span><br><span class="line">                candidates[c] -= <span class="number">1</span></span><br><span class="line">                self.dfs(candidates, target - c, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line">                candidates[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type candidates: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> target &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        c = Counter(candidates)</span><br><span class="line">        candidates = OrderedDict(sorted(c.items()))</span><br><span class="line">        self.dfs(candidates, target, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/combination-sum-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Combination Sum]]></title>
      <link>http://garfieldog.github.io/2015/09/15/combination-sum/</link>
      <guid>http://garfieldog.github.io/2015/09/15/combination-sum/</guid>
      <pubDate>Tue, 15 Sep 2015 11:16:43 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>
<p>The same repeated number may be chosen from C unlimited number of times.</p>
<p>Note:<br>All numbers (including target) will be positive integers.<br>Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).<br>The solution set must not contain duplicate combinations.<br>For example, given candidate set 2,3,6,7 and target 7,<br>A solution set is:<br>[7]<br>[2, 2, 3] </p>
</blockquote>
<h2 id="分析">分析</h2><p>依然是回溯法，不再解释，注意剪枝条件（保证combination是递增的）</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> candidates:</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> path <span class="keyword">or</span> c &gt;= path[-<span class="number">1</span>]) <span class="keyword">and</span> target - c &gt;= <span class="number">0</span>:</span><br><span class="line">                path.append(c)</span><br><span class="line">                self.dfs(candidates, target - c, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type candidates: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> target &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.dfs(candidates, target, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/combination-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Restore Ip Addresses]]></title>
      <link>http://garfieldog.github.io/2015/09/15/restore-ip-addresses/</link>
      <guid>http://garfieldog.github.io/2015/09/15/restore-ip-addresses/</guid>
      <pubDate>Tue, 15 Sep 2015 09:21:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>For example:<br>Given “25525511135”,</p>
<p>return [“255.255.11.135”, “255.255.111.35”]. (Order does not matter)</p>
</blockquote>
<h2 id="分析">分析</h2><p>做了那么多回溯法的题，这道题简直就是套模板。时间<code>O(n^4)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x <span class="keyword">or</span> (x[<span class="number">0</span>] == <span class="string">'0'</span> <span class="keyword">and</span> len(x) &gt; <span class="number">1</span>) <span class="keyword">or</span> int(x) &gt; <span class="number">255</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, start, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">if</span> start == len(s):</span><br><span class="line">                rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start, len(s)):</span><br><span class="line">            part = s[start:i + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.isValid(part):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            path.append(part)</span><br><span class="line">            self.dfs(s, i + <span class="number">1</span>, path, rs)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(s, <span class="number">0</span>, path, rs)</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'.'</span>.join(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/restore-ip-addresses/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-N Queens II]]></title>
      <link>http://garfieldog.github.io/2015/09/15/n-queens-2/</link>
      <guid>http://garfieldog.github.io/2015/09/15/n-queens-2/</guid>
      <pubDate>Tue, 15 Sep 2015 09:07:53 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total num]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for N-Queens problem.</p>
<p>Now, instead outputting board configurations, return the total number of distinct solutions.</p>
</blockquote>
<h2 id="分析">分析</h2><p>跟<a href="/2015/09/15/n-queens/">上一题</a>其实完全一样，不用维护路径，只用一个全局变量计数就可以了。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, depth, diag1, diag2, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == depth:</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = depth</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[y] <span class="keyword">and</span> <span class="keyword">not</span> diag1[x + y] <span class="keyword">and</span> <span class="keyword">not</span> diag2[x - y + n - <span class="number">1</span>]:</span><br><span class="line">                visited[y] = <span class="keyword">True</span></span><br><span class="line">                diag1[x + y] = <span class="keyword">True</span></span><br><span class="line">                diag2[x - y + n - <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">                self.dfs(n, depth + <span class="number">1</span>, diag1, diag2, visited)</span><br><span class="line">                visited[y] = <span class="keyword">False</span></span><br><span class="line">                diag1[x + y] = <span class="keyword">False</span></span><br><span class="line">                diag2[x - y + n - <span class="number">1</span>] = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        diag1 = [<span class="keyword">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">        diag2 = [<span class="keyword">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">        visited = [<span class="keyword">False</span>] * n</span><br><span class="line">        self.dfs(n, <span class="number">0</span>, diag1, diag2, visited)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/n-queens-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-N Queens]]></title>
      <link>http://garfieldog.github.io/2015/09/15/n-queens/</link>
      <guid>http://garfieldog.github.io/2015/09/15/n-queens/</guid>
      <pubDate>Tue, 15 Sep 2015 08:28:17 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p><img src="/images/n-queens.png" alt="n-queens"></p>
<p>Given an integer n, return all distinct solutions ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p><img src="/images/n-queens.png" alt="n-queens"></p>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<p>For example,<br>There exist two distinct solutions to the 4-queens puzzle:</p>
<p>[<br> [“.Q..”,  // Solution 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p>
<p> [“..Q.”,  // Solution 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题非常经典，最基础的做法就是DFS回溯。还有很多优化加速的方法，比如对角线缓存法。</p>
<h2 id="代码">代码</h2><h3 id="回溯">回溯</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, path, y)</span>:</span></span><br><span class="line">        j = len(path)</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(path):</span><br><span class="line">            <span class="keyword">if</span> x == y <span class="keyword">or</span> y - j == x - i <span class="keyword">or</span> y + j == x + i:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == len(path):</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> self.check(path, i):</span><br><span class="line">                path.append(i)</span><br><span class="line">                self.dfs(n, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listToMaze</span><span class="params">(self, lst)</span>:</span></span><br><span class="line">        rs = []</span><br><span class="line">        n = len(lst)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">            rs.append(<span class="string">'.'</span> * x + <span class="string">'Q'</span> + <span class="string">'.'</span> * (n - x - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(n, path, rs)</span><br><span class="line">        <span class="keyword">return</span> [self.listToMaze(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
<h3 id="缓存对角线加速">缓存对角线加速</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, path, rs, diag1, diag2, visited)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == len(path):</span><br><span class="line">            rs.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        x = len(path)</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[y] <span class="keyword">and</span> <span class="keyword">not</span> diag1[x + y] <span class="keyword">and</span> <span class="keyword">not</span> diag2[x - y + n - <span class="number">1</span>]:</span><br><span class="line">                path.append(y)</span><br><span class="line">                visited[y] = <span class="keyword">True</span></span><br><span class="line">                diag1[x + y] = <span class="keyword">True</span></span><br><span class="line">                diag2[x - y + n - <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">                self.dfs(n, path, rs, diag1, diag2, visited)</span><br><span class="line">                visited[y] = <span class="keyword">False</span></span><br><span class="line">                diag1[x + y] = <span class="keyword">False</span></span><br><span class="line">                diag2[x - y + n - <span class="number">1</span>] = <span class="keyword">False</span></span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listToMaze</span><span class="params">(self, lst)</span>:</span></span><br><span class="line">        rs = []</span><br><span class="line">        n = len(lst)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">            rs.append(<span class="string">'.'</span> * x + <span class="string">'Q'</span> + <span class="string">'.'</span> * (n - x - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> rs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        diag1 = [<span class="keyword">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">        diag2 = [<span class="keyword">False</span>] * (<span class="number">2</span> * n - <span class="number">1</span>)</span><br><span class="line">        visited = [<span class="keyword">False</span>] * n</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(n, path, rs, diag1, diag2, visited)</span><br><span class="line">        <span class="keyword">return</span> [self.listToMaze(x) <span class="keyword">for</span> x <span class="keyword">in</span> rs]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/n-queens/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Unique Paths II]]></title>
      <link>http://garfieldog.github.io/2015/09/15/unique-paths-2/</link>
      <guid>http://garfieldog.github.io/2015/09/15/unique-paths-2/</guid>
      <pubDate>Tue, 15 Sep 2015 07:28:07 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many uniq]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Follow up for “Unique Paths”:</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>
<p>For example,<br>There is one obstacle in the middle of a 3x3 grid as illustrated below.</p>
<p>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>The total number of unique paths is 2.</p>
<p>Note: m and n will be at most 100.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这次有障碍了，就不能简单用组合数解了。可以DFS，但是容易超时，可以把<a href="/2015/09/15/unique-paths/">上一题</a>的动态规划改一下，注意有障碍物的格子走法要处理为0。</p>
<h2 id="代码">代码</h2><h3 id="DFS(超时)">DFS(超时)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type obstacleGrid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> x == m - <span class="number">1</span> <span class="keyword">and</span> y == n - <span class="number">1</span>:</span><br><span class="line">                self.count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> x + <span class="number">1</span> &lt; m <span class="keyword">and</span> A[x + <span class="number">1</span>][y] == <span class="number">0</span>:</span><br><span class="line">                dfs(x + <span class="number">1</span>, y)</span><br><span class="line">            <span class="keyword">if</span> y + <span class="number">1</span> &lt; n <span class="keyword">and</span> A[x][y + <span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">                dfs(x, y + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        A = obstacleGrid</span><br><span class="line">        m = len(A)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(A[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br></pre></td></tr></table></figure>
<h3 id="动态规划">动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type obstacleGrid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line"></span><br><span class="line">        A = obstacleGrid</span><br><span class="line">        m = len(A)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(A[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m)]</span><br><span class="line">        dp[m - <span class="number">1</span>][n - <span class="number">1</span>] = <span class="number">1</span> <span class="keyword">if</span> A[m - <span class="number">1</span>][n - <span class="number">1</span>] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i][n - <span class="number">1</span>] == <span class="number">0</span> <span class="keyword">and</span> dp[i + <span class="number">1</span>][n - <span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                dp[i][n - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[m - <span class="number">1</span>][j] == <span class="number">0</span> <span class="keyword">and</span> dp[m - <span class="number">1</span>][j + <span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                dp[m - <span class="number">1</span>][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[i][j] == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j] + dp[i][j + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/15/unique-paths-2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
