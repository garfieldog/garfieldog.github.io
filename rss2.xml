<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Wed, 23 Sep 2015 15:49:22 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Intersection of Two Linked List]]></title>
      <link>http://garfieldog.github.io/2015/09/23/intersection-of-two-linked-list/</link>
      <guid>http://garfieldog.github.io/2015/09/23/intersection-of-two-linked-list/</guid>
      <pubDate>Wed, 23 Sep 2015 15:23:39 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Write a program to find the node at which the intersection of two singly linked lists begins.</p>
<p>For example, the following two linked lists:</p>
<p>A:          a1 → a2<br>                   ↘<br>                     c1 → c2 → c3<br>                   ↗<br>B:     b1 → b2 → b3<br>begin to intersect at node c1.</p>
<p>Notes:</p>
<p>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>
</blockquote>
<h2 id="分析">分析</h2><p>分别计算出两个链表的长度，让较长的的链表头先往前挪相应的步数让两链表剩下的部分等长。然后两个指针同步向前，直到相遇（或者各自走到尾部）。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            node = node.next</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head1, head1: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headA <span class="keyword">or</span> <span class="keyword">not</span> headB:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        n1 = self.getLength(headA)</span><br><span class="line">        n2 = self.getLength(headB)</span><br><span class="line">        pA = headA</span><br><span class="line">        pB = headB</span><br><span class="line">        <span class="keyword">if</span> n1 &gt; n2:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n1 - n2):</span><br><span class="line">                pA = pA.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n2 - n1):</span><br><span class="line">                pB = pB.next</span><br><span class="line">        <span class="keyword">while</span> pA != pB:</span><br><span class="line">            pA = pA.next</span><br><span class="line">            pB = pB.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pA</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/23/intersection-of-two-linked-list/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Max Points on a Line]]></title>
      <link>http://garfieldog.github.io/2015/09/19/max-points-on-a-line/</link>
      <guid>http://garfieldog.github.io/2015/09/19/max-points-on-a-line/</guid>
      <pubDate>Sat, 19 Sep 2015 03:53:09 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
</blockquote>
<h2 id="分析">分析</h2><p>暴力搜索的话时间<code>O(n^3)</code>，会超时。可以考虑用缓存来加速，比如对和某两点<code>(p1, p2)</code>共线的点<code>p3</code>，把<code>(p1, p3)</code>和<code>(p2, p3)</code>作为键缓存起来，下次就不用计算了。这样提交仍然超时。</p>
<p>考虑用斜率缓存，对于每一个点<code>p1</code>，遍历<code>排在它后面的点p2</code>(想一想为什么前面不需要)，缓存两点的斜率并缓存计数。内循环结束时更新当前最大共线数。时间<code>O(n^2)</code>。(其实用浮点存斜率有潜在的精度问题，最好是能用有理数)</p>
<h2 id="代码">代码</h2><h3 id="暴力_+_边缓存（超时且没有考虑重合点问题）">暴力 + 边缓存（超时且没有考虑重合点问题）</h3><figure class="highlight"><figcaption><span>Definition for a point.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):&#10;    def same_line(self, p1, p2, p3):&#10;        if p1.x == p2.x or p2.x == p3.x:&#10;            return p1.x == p2.x == p3.x&#10;        diff = (p3.x - p2.x) * (p2.y - p1.y) - (p3.y - p2.y) * (p2.x - p1.x)&#10;        return diff == 0&#10;&#10;    def maxPoints(self, points):&#10;        &#34;&#34;&#34;&#10;        :type points: List[Point]&#10;        :rtype: int&#10;        &#34;&#34;&#34;&#10;        d = &#123;&#125;&#10;        max_points = 0&#10;        n = len(points)&#10;        if n &#60;= 2:&#10;            return n&#10;        for i in xrange(n - 1):&#10;            for j in xrange(i + 1, n):&#10;                if (points[i], points[j]) not in d:&#10;                    candidates = []&#10;                    for k in xrange(j + 1, n):&#10;                        if (points[i], points[k]) not in d:&#10;                            if self.same_line(points[i], points[j], points[k]):&#10;                                candidates.append(points[k])&#10;                    cur_len = len(candidates) + 2&#10;                    d[(points[i], points[j])] = cur_len&#10;&#10;                    for p in candidates:&#10;                        d[(points[i], p)] = cur_len&#10;                        d[(points[j], p)] = cur_len&#10;                    max_points = max(max_points, cur_len)&#10;        return max_points</span><br></pre></td></tr></table></figure>
<h3 id="斜率缓存">斜率缓存</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">slope</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> p1.x == p2.x:</span><br><span class="line">            <span class="keyword">return</span> float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">return</span> float(p2.y - p1.y) / (p2.x - p1.x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">same</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> p1.x == p2.x <span class="keyword">and</span> p1.y == p2.y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPoints</span><span class="params">(self, points)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type points: List[Point]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        max_points = <span class="number">0</span></span><br><span class="line">        n = len(points)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>):</span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            local_max = <span class="number">1</span></span><br><span class="line">            same_points = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> self.same(points[i], points[j]):</span><br><span class="line">                    same_points += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                slope = self.slope(points[i], points[j])</span><br><span class="line">                d.setdefault(slope, <span class="number">1</span>)</span><br><span class="line">                d[slope] += <span class="number">1</span></span><br><span class="line">                local_max = max(local_max, d[slope])</span><br><span class="line">            max_points = max(max_points, local_max + same_points)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_points</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/19/max-points-on-a-line/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Text Justification]]></title>
      <link>http://garfieldog.github.io/2015/09/19/text-justification/</link>
      <guid>http://garfieldog.github.io/2015/09/19/text-justification/</guid>
      <pubDate>Sat, 19 Sep 2015 03:03:41 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of words and a length L, format the text such that each line has exactly L characters and ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly L characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<p>For example,<br>words: [“This”, “is”, “an”, “example”, “of”, “text”, “justification.”]<br>L: 16.</p>
<p>Return the formatted lines as:<br>[<br>   “This    is    an”,<br>   “example  of text”,<br>   “justification.  “<br>]<br>Note: Each word is guaranteed not to exceed L in length.</p>
<p>Corner Cases:<br>A line other than the last line might contain only one word. What should you do in this case?<br>In this case, that line should be left-justified.</p>
</blockquote>
<h2 id="分析">分析</h2><p>细节实现题，给文章排版，要求每一行左右对齐（最后一行左对齐）。主要是要注意各种特殊情况，尤其是一行只有一个单词的情况。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words, maxWidth)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type words: List[str]</span><br><span class="line">        :type maxWidth: int</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        curLineWidth = <span class="number">0</span></span><br><span class="line">        line = []</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> curLineWidth + len(line) + len(w) &lt;= maxWidth:</span><br><span class="line">                line.append(w)</span><br><span class="line">                curLineWidth += len(w)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                spaces = maxWidth - curLineWidth</span><br><span class="line">                <span class="keyword">if</span> len(line) == <span class="number">1</span>:</span><br><span class="line">                    s = line[<span class="number">0</span>] + <span class="string">' '</span> * spaces</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    a, b = divmod(spaces, len(line) - <span class="number">1</span>)</span><br><span class="line">                    buff = []</span><br><span class="line">                    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(line)):</span><br><span class="line">                        buff.append(line[i])</span><br><span class="line">                        <span class="keyword">if</span> i &lt; b:</span><br><span class="line">                            buff.append(<span class="string">' '</span> * (a + <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">elif</span> i &lt; len(line) - <span class="number">1</span>:</span><br><span class="line">                            buff.append(<span class="string">' '</span> * a)</span><br><span class="line">                    s = <span class="string">''</span>.join(buff)</span><br><span class="line">                rs.append(s)</span><br><span class="line">                line = [w]</span><br><span class="line">                curLineWidth = len(w)</span><br><span class="line">        <span class="keyword">if</span> line:</span><br><span class="line">            s = <span class="string">' '</span>.join(line) + <span class="string">' '</span> * (maxWidth - curLineWidth - len(line) + <span class="number">1</span>)</span><br><span class="line">            rs.append(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/19/text-justification/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Divide Two Integers]]></title>
      <link>http://garfieldog.github.io/2015/09/19/divide-two-integers/</link>
      <guid>http://garfieldog.github.io/2015/09/19/divide-two-integers/</guid>
      <pubDate>Sat, 19 Sep 2015 02:38:05 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, re]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Divide two integers without using multiplication, division and mod operator.</p>
<p>If it is overflow, return MAX_INT.</p>
</blockquote>
<h2 id="分析">分析</h2><p>不用乘法、除法、取模运算来实现除法。可以只用加减法来实现，但是太慢了。可以用位运算来加速。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type dividend: int</span><br><span class="line">        :type divisor: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        MAX_INT = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        p1 = dividend &gt; <span class="number">0</span></span><br><span class="line">        p2 = divisor &gt; <span class="number">0</span></span><br><span class="line">        sign = -<span class="number">1</span> <span class="keyword">if</span> p1 ^ p2 <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        dividend = abs(dividend)</span><br><span class="line">        divisor = abs(divisor)</span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">            d = divisor</span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> d &lt;= dividend:</span><br><span class="line">                dividend -= d</span><br><span class="line">                r += i</span><br><span class="line">                d &lt;&lt;= <span class="number">1</span></span><br><span class="line">                i &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min(sign * r, MAX_INT)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/19/divide-two-integers/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Zigzag Conversion]]></title>
      <link>http://garfieldog.github.io/2015/09/18/zigzag-conversion/</link>
      <guid>http://garfieldog.github.io/2015/09/18/zigzag-conversion/</guid>
      <pubDate>Fri, 18 Sep 2015 11:50:47 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>And then read line by line: “PAHNAPLSIIGYIR”<br>Write the code that will take a string and make this conversion given a number of rows:</p>
<p>string convert(string text, int nRows);<br>convert(“PAYPALISHIRING”, 3) should return “PAHNAPLSIIGYIR”.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题要找规律，太烦了，直接参考<a href="http://blog.unieagle.net/2012/11/08/leetcode%E9%A2%98%E7%9B%AE%EF%BC%9Azigzag-conversion/" target="_blank" rel="external">这里</a>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type numRows: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">or</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        rs = []</span><br><span class="line">        gap = <span class="number">2</span> * numRows - <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(numRows):</span><br><span class="line">            <span class="keyword">for</span> j, index <span class="keyword">in</span> enumerate(xrange(i, n, gap)):</span><br><span class="line">                <span class="comment"># index = gap * j + i</span></span><br><span class="line">                rs.append(s[index])</span><br><span class="line">                <span class="comment"># not first row either last row</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; numRows - <span class="number">1</span>:</span><br><span class="line">                    k = index + gap - <span class="number">2</span> * i</span><br><span class="line">                    <span class="keyword">if</span> k &lt; n:</span><br><span class="line">                        rs.append(s[k])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(rs)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/zigzag-conversion/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Spiral Matrix II]]></title>
      <link>http://garfieldog.github.io/2015/09/18/spiral-matrix-2/</link>
      <guid>http://garfieldog.github.io/2015/09/18/spiral-matrix-2/</guid>
      <pubDate>Fri, 18 Sep 2015 10:04:01 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>Fo]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>
<p>For example,<br>Given n = 3,</p>
<p>You should return the following matrix:<br>[<br> [ 1, 2, 3 ],<br> [ 8, 9, 4 ],<br> [ 7, 6, 5 ]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/18/spiral-matrix/">Spiral Matrix</a>的后续。解法是一样的。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)]</span><br><span class="line">        left = up = <span class="number">0</span></span><br><span class="line">        right = down = n - <span class="number">1</span></span><br><span class="line">        x = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">            <span class="keyword">if</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(left, right + <span class="number">1</span>):</span><br><span class="line">                    rs[up][i] = x</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> down &gt;= up <span class="keyword">and</span> right &gt;= left:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(up, down + <span class="number">1</span>):</span><br><span class="line">                    rs[i][right] = x</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    rs[down][i] = x</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                down -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> down &gt;= up <span class="keyword">and</span> right &gt;= left:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    rs[i][left] = x</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/spiral-matrix-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Spiral Matrix]]></title>
      <link>http://garfieldog.github.io/2015/09/18/spiral-matrix/</link>
      <guid>http://garfieldog.github.io/2015/09/18/spiral-matrix/</guid>
      <pubDate>Fri, 18 Sep 2015 09:33:21 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.<]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<p>For example,<br>Given the following matrix:</p>
<p>[<br> [ 1, 2, 3 ],<br> [ 4, 5, 6 ],<br> [ 7, 8, 9 ]<br>]<br>You should return [1,2,3,6,9,8,7,4,5].</p>
</blockquote>
<h2 id="分析">分析</h2><p>细节实现题，注意边界判断。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        up = <span class="number">0</span></span><br><span class="line">        down = len(matrix) - <span class="number">1</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">while</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">            <span class="keyword">if</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(left, right + <span class="number">1</span>):</span><br><span class="line">                    rs.append(matrix[up][i])</span><br><span class="line">                up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> down &gt;= up <span class="keyword">and</span> right &gt;= left:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(up, down + <span class="number">1</span>):</span><br><span class="line">                    rs.append(matrix[i][right])</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> right &gt;= left <span class="keyword">and</span> down &gt;= up:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(right, left - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    rs.append(matrix[down][i])</span><br><span class="line">                down -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> down &gt;= up <span class="keyword">and</span> right &gt;= left:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(down, up - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                    rs.append(matrix[i][left])</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/spiral-matrix/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Pascal Triangle II]]></title>
      <link>http://garfieldog.github.io/2015/09/18/pascal-triangle-2/</link>
      <guid>http://garfieldog.github.io/2015/09/18/pascal-triangle-2/</guid>
      <pubDate>Fri, 18 Sep 2015 09:18:14 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an index k, return the kth row of the Pascal’s triangle.</p>
<p>For example, given k = 3,<br>Return [1,3,3,1].</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/18/pascal-triangle/">Pascal Triangle</a>的后续。用类似动态规划的降维方式，可以实现空间<code>O(n)</code>的算法。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type rowIndex: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        rs = [<span class="number">0</span>] * (rowIndex + <span class="number">1</span>)</span><br><span class="line">        rs[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, rowIndex + <span class="number">1</span>):</span><br><span class="line">            rs[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                rs[j] += rs[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/pascal-triangle-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Pascal Triangle]]></title>
      <link>http://garfieldog.github.io/2015/09/18/pascal-triangle/</link>
      <guid>http://garfieldog.github.io/2015/09/18/pascal-triangle/</guid>
      <pubDate>Fri, 18 Sep 2015 09:06:31 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given numRows, generate the first numRows of Pascal’s triangle.</p>
<p>For example, given numRows = 5,<br>Return</p>
<p>[<br>     [1],<br>    [1,1],<br>   [1,2,1],<br>  [1,3,3,1],<br> [1,4,6,4,1]<br>]</p>
</blockquote>
<h2 id="分析">分析</h2><p>比较简单，打印杨辉三角。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(self, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type numRows: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = [[<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, numRows):</span><br><span class="line">            row = [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, i):</span><br><span class="line">                row.append(rs[i - <span class="number">1</span>][j - <span class="number">1</span>] + rs[i - <span class="number">1</span>][j])</span><br><span class="line">            row.append(<span class="number">1</span>)</span><br><span class="line">            rs.append(row)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/pascal-triangle/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Substring with Concatenation of All Words]]></title>
      <link>http://garfieldog.github.io/2015/09/18/substring-with-concatenation-of-all-words/</link>
      <guid>http://garfieldog.github.io/2015/09/18/substring-with-concatenation-of-all-words/</guid>
      <pubDate>Fri, 18 Sep 2015 08:29:19 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.</p>
<p>For example, given:<br>s: “barfoothefoobarman”<br>words: [“foo”, “bar”]</p>
<p>You should return the indices: [0,9].<br>(order does not matter).</p>
</blockquote>
<h2 id="分析">分析</h2><p>这是一道细节实现题，方法是在对<code>s</code>每一个下标<code>i</code>，检查从<code>i</code>开始的<code>len(words)</code>个单词是不是刚好是<code>words</code>里的单词。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findSubstring</span><span class="params">(self, s, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type words: List[str]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        ns = len(s)</span><br><span class="line">        nw = len(words[<span class="number">0</span>])</span><br><span class="line">        nws = len(words) * nw</span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">if</span> ns &lt; nws:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        expected = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            expected.setdefault(w, <span class="number">0</span>)</span><br><span class="line">            expected[w] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(ns - nws + <span class="number">1</span>):</span><br><span class="line">            found = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(len(words)):</span><br><span class="line">                word = s[i + j * nw: i + (j + <span class="number">1</span>) * nw]</span><br><span class="line">                <span class="keyword">if</span> expected.get(word, <span class="number">0</span>) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                found.setdefault(word, <span class="number">0</span>)</span><br><span class="line">                found[word] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> found[word] &gt; expected[word]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rs.append(i)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/substring-with-concatenation-of-all-words/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Multiply Strings]]></title>
      <link>http://garfieldog.github.io/2015/09/18/multiply-strings/</link>
      <guid>http://garfieldog.github.io/2015/09/18/multiply-strings/</guid>
      <pubDate>Fri, 18 Sep 2015 07:30:54 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note: ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two numbers represented as strings, return multiplication of the numbers as a string.</p>
<p>Note: The numbers can be arbitrarily large and are non-negative.</p>
</blockquote>
<h2 id="分析">分析</h2><p>大整数乘法，把字符串转换为数组，然后数组相乘。我们这里用9个字符组成一个数字，可以任意选 <code>0 &lt; n &lt; 10</code>的长度。(10位以上的字符串不能用一个32位整数存储)</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">UNIT_LEN = <span class="number">9</span></span><br><span class="line">BASE = <span class="number">1000000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">str2vec</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        v = []</span><br><span class="line">        <span class="keyword">for</span> end <span class="keyword">in</span> xrange(n, <span class="number">0</span>, -UNIT_LEN):</span><br><span class="line">            start = max(end - UNIT_LEN, <span class="number">0</span>)</span><br><span class="line">            v.append(int(s[start: end]))</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">vec2str</span><span class="params">(self, vec)</span>:</span></span><br><span class="line">        fmt = <span class="string">'%%0%dd'</span> % UNIT_LEN</span><br><span class="line">        ss = [str(vec[len(vec) - <span class="number">1</span>])]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(vec) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            ss.append(fmt % vec[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(ss)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply_vec</span><span class="params">(self, v1, v2)</span>:</span></span><br><span class="line">        n1 = len(v1)</span><br><span class="line">        n2 = len(v2)</span><br><span class="line">        v = [<span class="number">0</span>] * (n1 + n2)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n1):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n2):</span><br><span class="line">                v[i + j] += v1[i] * v2[j]</span><br><span class="line">                <span class="keyword">if</span> v[i + j] &gt;= BASE:</span><br><span class="line">                    v[i + j + <span class="number">1</span>] += v[i + j] / BASE</span><br><span class="line">                    v[i + j] %= BASE</span><br><span class="line">        <span class="keyword">while</span> len(v) &gt; <span class="number">1</span> <span class="keyword">and</span> v[-<span class="number">1</span>] == <span class="number">0</span>:</span><br><span class="line">            v.pop()</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type num1: str</span><br><span class="line">        :type num2: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num1 <span class="keyword">or</span> <span class="keyword">not</span> num2:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        vec1 = self.str2vec(num1)</span><br><span class="line">        vec2 = self.str2vec(num2)</span><br><span class="line">        v = self.multiply_vec(vec1, vec2)</span><br><span class="line">        <span class="keyword">return</span> self.vec2str(v)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/multiply-strings/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Minimum Window Substring]]></title>
      <link>http://garfieldog.github.io/2015/09/18/minimum-window-substring/</link>
      <guid>http://garfieldog.github.io/2015/09/18/minimum-window-substring/</guid>
      <pubDate>Fri, 18 Sep 2015 06:03:58 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>For example,<br>S = “ADOBECODEBANC”<br>T = “ABC”<br>Minimum window is “BANC”.</p>
<p>Note:<br>If there is no such window in S that covers all characters in T, return the emtpy string “”.</p>
<p>If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题技巧性很强，题目要求时间<code>O(n)</code>。使用两指针<code>i, j</code>，j先走，找到第一个满足条件的窗口<code>[i, j)</code>，然后让i前进，收缩窗口到尽可能小（同时满足条件），这样就找到了一个候选窗口。然后i向前走一步，破坏了条件，让j重复开始的搜索逻辑。详情参考<a href="http://www.cnblogs.com/TenosDoIt/p/3461301.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        expected = defaultdict(int)</span><br><span class="line">        appeared = defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">            expected[c] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        m = len(t)</span><br><span class="line">        n = len(s)</span><br><span class="line">        min_window = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> m &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> appeared[s[j]] &lt; expected[s[j]]:</span><br><span class="line">                    m -= <span class="number">1</span></span><br><span class="line">                appeared[s[j]] += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># found a window, minimize it</span></span><br><span class="line">                <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> appeared[s[i]] &gt; expected[s[i]]:</span><br><span class="line">                    appeared[s[i]] -= <span class="number">1</span></span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> min_window <span class="keyword">or</span> (j - i) &lt; (min_window[<span class="number">1</span>] - min_window[<span class="number">0</span>]):</span><br><span class="line">                    min_window = (i, j)</span><br><span class="line">                <span class="comment"># i++</span></span><br><span class="line">                appeared[s[i]] -= <span class="number">1</span></span><br><span class="line">                m += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> min_window <span class="keyword">and</span> s[min_window[<span class="number">0</span>]: min_window[<span class="number">1</span>]] <span class="keyword">or</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/minimum-window-substring/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Merge Intervals]]></title>
      <link>http://garfieldog.github.io/2015/09/18/merge-intervals/</link>
      <guid>http://garfieldog.github.io/2015/09/18/merge-intervals/</guid>
      <pubDate>Fri, 18 Sep 2015 05:49:28 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given [1,3],[2,6]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a collection of intervals, merge all overlapping intervals.</p>
<p>For example,<br>Given [1,3],[2,6],[8,10],[15,18],<br>return [1,6],[8,10],[15,18].</p>
</blockquote>
<h2 id="分析">分析</h2><p>和[Insert Interval][1]很像，解法也很类似，先按start排序然后遍历数组前后合并。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type intervals: List[Interval]</span><br><span class="line">        :rtype: List[Interval]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">        rs = []</span><br><span class="line">        last = intervals[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(intervals)):</span><br><span class="line">            v = intervals[i]</span><br><span class="line">            <span class="keyword">if</span> last.end &lt; v.start:</span><br><span class="line">                rs.append(last)</span><br><span class="line">                last = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># overlap</span></span><br><span class="line">                last.end = max(last.end, v.end)</span><br><span class="line">        rs.append(last)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/merge-intervals/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Insert Interval]]></title>
      <link>http://garfieldog.github.io/2015/09/18/insert-interval/</link>
      <guid>http://garfieldog.github.io/2015/09/18/insert-interval/</guid>
      <pubDate>Fri, 18 Sep 2015 03:33:32 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).<]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>
<p>You may assume that the intervals were initially sorted according to their start times.</p>
<p>Example 1:<br>Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>
<p>Example 2:<br>Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>
<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>
</blockquote>
<h2 id="分析">分析</h2><p>看似简单，写对了不容易。思路是这样的，遍历已有区间，和新区间进行比较，有三种情况</p>
<ol>
<li>没有重叠，当前区间整体在新区间前面，则当前区间添加到结果集。</li>
<li>没有重叠，当前区间整体在新区间后面，添加新区间到结果集。后面的区间可以一一添加即可。</li>
<li>有重叠，把当前区间和新区间合并，生成的新区间继续和后面的区间进行上述过程。</li>
</ol>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type intervals: List[Interval]</span><br><span class="line">        :type newInterval: Interval</span><br><span class="line">        :rtype: List[Interval]</span><br><span class="line">        """</span></span><br><span class="line">        rs = []</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> v.end &lt; newInterval.start:</span><br><span class="line">                rs.append(v)</span><br><span class="line">            <span class="keyword">elif</span> v.start &gt; newInterval.end:</span><br><span class="line">                rs.append(newInterval)</span><br><span class="line">                newInterval = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># overlap</span></span><br><span class="line">                newInterval.start = min(v.start, newInterval.start)</span><br><span class="line">                newInterval.end = max(v.end, newInterval.end)</span><br><span class="line">        rs.append(newInterval)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/insert-interval/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Palindrome Number]]></title>
      <link>http://garfieldog.github.io/2015/09/18/palindrome-number/</link>
      <guid>http://garfieldog.github.io/2015/09/18/palindrome-number/</guid>
      <pubDate>Fri, 18 Sep 2015 03:11:03 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>Some hints:<br>Could ne]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Determine whether an integer is a palindrome. Do this without extra space.</p>
<p>Some hints:<br>Could negative integers be palindromes? (ie, -1)</p>
<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>
<p>You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?</p>
<p>There is a more generic way of solving this problem.</p>
</blockquote>
<h2 id="分析">分析</h2><p>用<a href="/2015/09/18/reverse-integer/">Reverse Integer</a>中实现的方法，把整数翻转看结果是否和它自己相等（另外注意负数不可能是回文）。还有一种解法，就是和<a href="/2015/08/31/valid-palindrome/">字符串判别回文</a>差不多，两指针从两边夹逼。</p>
<h2 id="代码">代码</h2><h3 id="翻转整数">翻转整数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        x = abs(x)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            x, mod = divmod(x, <span class="number">10</span>)</span><br><span class="line">            r = r * <span class="number">10</span> + mod</span><br><span class="line">            <span class="comment"># overflow check</span></span><br><span class="line">            <span class="keyword">if</span> r &gt; <span class="number">2147483647</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> sign * r</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.reverse(x) == x</span><br></pre></td></tr></table></figure>
<h3 id="头尾遍历">头尾遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        divisor = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> divisor * <span class="number">10</span> &lt;= x:</span><br><span class="line">            divisor *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            head = x / divisor</span><br><span class="line">            tail = x % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> head != tail:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            x = (x % divisor) / <span class="number">10</span></span><br><span class="line">            divisor /= <span class="number">100</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/palindrome-number/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Reverse Integer]]></title>
      <link>http://garfieldog.github.io/2015/09/18/reverse-integer/</link>
      <guid>http://garfieldog.github.io/2015/09/18/reverse-integer/</guid>
      <pubDate>Fri, 18 Sep 2015 02:51:22 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p>]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Reverse digits of an integer.</p>
<p>Example1: x = 123, return 321<br>Example2: x = -123, return -321</p>
<p>Have you thought about this?<br>Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!</p>
<p>If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.</p>
<p>Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?</p>
<p>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
</blockquote>
<h2 id="分析">分析</h2><p>算法没难度，细节实现题，测试用例里假设整数只有32位，但是Python在64位机器上int是64位的，而且一旦超出会自动转换为long，而long是没有精度限制的，所以说Python里整数不会溢出，这里为了过测试，要强行加上判断。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        x = abs(x)</span><br><span class="line">        r = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            x, mod = divmod(x, <span class="number">10</span>)</span><br><span class="line">            r = r * <span class="number">10</span> + mod</span><br><span class="line">            <span class="comment"># overflow check</span></span><br><span class="line">            <span class="keyword">if</span> r &gt; <span class="number">2147483647</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> sign * r</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/reverse-integer/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Clone Graph]]></title>
      <link>http://garfieldog.github.io/2015/09/18/clone-graph/</link>
      <guid>http://garfieldog.github.io/2015/09/18/clone-graph/</guid>
      <pubDate>Fri, 18 Sep 2015 02:13:32 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</p>
<p>OJ’s undirected graph serialization:<br>Nodes are labeled uniquely.</p>
<p>We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.<br>As an example, consider the serialized graph {0,1,2#1,2#2,2}.</p>
<p>The graph has a total of three nodes, and therefore contains three parts as separated by #.</p>
<p>First node is labeled as 0. Connect node 0 to both nodes 1 and 2.<br>Second node is labeled as 1. Connect node 1 to node 2.<br>Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.<br>Visually, the graph looks like the following:</p>
<pre><code>   <span class="number">1</span>
  / <span class="string">\</span>
 /   <span class="string">\</span>
<span class="number">0</span> --- <span class="number">2</span>
     / <span class="string">\</span>
     <span class="string">\_/</span>
</code></pre></blockquote>
<h2 id="分析">分析</h2><p>深度优先或广度优先遍历图即可，用一个字典维护已经被拷贝的节点。</p>
<h2 id="代码">代码</h2><h3 id="DFS">DFS</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a undirected graph node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndirectedGraphNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.label = x</span><br><span class="line">        self.neighbors = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, copied)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> copied:</span><br><span class="line">            <span class="keyword">return</span> copied[node]</span><br><span class="line">        new_node = UndirectedGraphNode(node.label)</span><br><span class="line">        copied[node] = new_node</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> node.neighbors:</span><br><span class="line">            new_node.neighbors.append(self.dfs(n, copied))</span><br><span class="line">        <span class="keyword">return</span> new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type node: UndirectedGraphNode</span><br><span class="line">        :rtype: UndirectedGraphNode</span><br><span class="line">        """</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(node, d)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/18/clone-graph/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Word Break II]]></title>
      <link>http://garfieldog.github.io/2015/09/17/word-break-2/</link>
      <guid>http://garfieldog.github.io/2015/09/17/word-break-2/</guid>
      <pubDate>Thu, 17 Sep 2015 11:29:06 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.</p>
<p>Return all such possible sentences.</p>
<p>For example, given<br>s = “catsanddog”,<br>dict = [“cat”, “cats”, “and”, “sand”, “dog”].</p>
<p>A solution is [“cats and dog”, “cat sand dog”].</p>
</blockquote>
<h2 id="分析">分析</h2><p>在<a href="/2015/09/17/word-break/">Word Break</a>的基础上，要求返回所有可能的分词结果。我们用一个二维数组<code>A[i][j]</code>来表示<code>s[j:i]</code>是不是一个单词（注意下标是反的）。然后通过对<code>A</code>进行DFS我们可以还原所有的合法组合。理解了之后要写对还是不容易。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, A, idx, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">            rs.append(<span class="string">' '</span>.join(path[::-<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(idx):</span><br><span class="line">            <span class="keyword">if</span> A[idx][i]:</span><br><span class="line">                <span class="comment"># s[i: idx] is a word</span></span><br><span class="line">                path.append(s[i: idx])</span><br><span class="line">                self.dfs(s, A, i, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="keyword">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        A = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j: i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="keyword">True</span></span><br><span class="line">                    A[i][j] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dp[n]:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(s, A, n, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/word-break-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Word Break]]></title>
      <link>http://garfieldog.github.io/2015/09/17/word-break/</link>
      <guid>http://garfieldog.github.io/2015/09/17/word-break/</guid>
      <pubDate>Thu, 17 Sep 2015 11:16:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated s]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>
<p>Return true because “leetcode” can be segmented as “leet code”.</p>
</blockquote>
<h2 id="分析">分析</h2><p>一维动态规划，令<code>dp[i]</code>表示前i个字符构成的字符串是否可以被分词，则<code>dp[i] = any(dp[j] &amp;&amp; s[j:i] in wordDict), 0 &lt;= j &lt; i</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="keyword">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j: i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/word-break/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Distinct Subsequences]]></title>
      <link>http://garfieldog.github.io/2015/09/17/distinct-subsequences/</link>
      <guid>http://garfieldog.github.io/2015/09/17/distinct-subsequences/</guid>
      <pubDate>Thu, 17 Sep 2015 09:39:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequenc]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>Here is an example:<br>S = “rabbbit”, T = “rabbit”</p>
<p>Return 3.</p>
</blockquote>
<h2 id="分析">分析</h2><p>令<code>dp[i][j]</code>表示t的前j个字符在s的前i个字符组成的字符串中的subsequences个数，如果<code>s[i] == t[j]</code>，则可以选择用t[j]或者不用t[j]，<code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]</code>，若<code>s[i] != t[j]</code>，则显然<code>dp[i][j] = dp[i - 1][j]</code>。可以把dp数组降到一维。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        m = len(s)</span><br><span class="line">        n = len(t)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == t[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/distinct-subsequences/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
