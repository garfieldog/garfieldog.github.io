<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Mew]]></title>
    <link>http://garfieldog.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[只有猪肉卷是永恒的]]></description>
    <pubDate>Thu, 17 Sep 2015 11:59:08 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[Leetcode解题-Word Break II]]></title>
      <link>http://garfieldog.github.io/2015/09/17/word-break-2/</link>
      <guid>http://garfieldog.github.io/2015/09/17/word-break-2/</guid>
      <pubDate>Thu, 17 Sep 2015 11:29:06 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.</p>
<p>Return all such possible sentences.</p>
<p>For example, given<br>s = “catsanddog”,<br>dict = [“cat”, “cats”, “and”, “sand”, “dog”].</p>
<p>A solution is [“cats and dog”, “cat sand dog”].</p>
</blockquote>
<h2 id="分析">分析</h2><p>在<a href="/2015/09/17/word-break/">Word Break</a>的基础上，要求返回所有可能的分词结果。我们用一个二维数组<code>A[i][j]</code>来表示<code>s[j:i]</code>是不是一个单词（注意下标是反的）。然后通过对<code>A</code>进行DFS我们可以还原所有的合法组合。理解了之后要写对还是不容易。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, A, idx, path, rs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> idx == <span class="number">0</span>:</span><br><span class="line">            rs.append(<span class="string">' '</span>.join(path[::-<span class="number">1</span>]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(idx):</span><br><span class="line">            <span class="keyword">if</span> A[idx][i]:</span><br><span class="line">                <span class="comment"># s[i: idx] is a word</span></span><br><span class="line">                path.append(s[i: idx])</span><br><span class="line">                self.dfs(s, A, i, path, rs)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="keyword">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        A = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j: i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="keyword">True</span></span><br><span class="line">                    A[i][j] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> dp[n]:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        rs = []</span><br><span class="line">        path = []</span><br><span class="line">        self.dfs(s, A, n, path, rs)</span><br><span class="line">        <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/word-break-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Word Break]]></title>
      <link>http://garfieldog.github.io/2015/09/17/word-break/</link>
      <guid>http://garfieldog.github.io/2015/09/17/word-break/</guid>
      <pubDate>Thu, 17 Sep 2015 11:16:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated s]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>For example, given<br>s = “leetcode”,<br>dict = [“leet”, “code”].</p>
<p>Return true because “leetcode” can be segmented as “leet code”.</p>
</blockquote>
<h2 id="分析">分析</h2><p>一维动态规划，令<code>dp[i]</code>表示前i个字符构成的字符串是否可以被分词，则<code>dp[i] = any(dp[j] &amp;&amp; s[j:i] in wordDict), 0 &lt;= j &lt; i</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="keyword">False</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i):</span><br><span class="line">                <span class="keyword">if</span> dp[j] <span class="keyword">and</span> s[j: i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    dp[i] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/word-break/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Distinct Subsequences]]></title>
      <link>http://garfieldog.github.io/2015/09/17/distinct-subsequences/</link>
      <guid>http://garfieldog.github.io/2015/09/17/distinct-subsequences/</guid>
      <pubDate>Thu, 17 Sep 2015 09:39:25 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequenc]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string S and a string T, count the number of distinct subsequences of T in S.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>Here is an example:<br>S = “rabbbit”, T = “rabbit”</p>
<p>Return 3.</p>
</blockquote>
<h2 id="分析">分析</h2><p>令<code>dp[i][j]</code>表示t的前j个字符在s的前i个字符组成的字符串中的subsequences个数，如果<code>s[i] == t[j]</code>，则可以选择用t[j]或者不用t[j]，<code>dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]</code>，若<code>s[i] != t[j]</code>，则显然<code>dp[i][j] = dp[i - 1][j]</code>。可以把dp数组降到一维。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        m = len(s)</span><br><span class="line">        n = len(t)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == t[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/distinct-subsequences/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Decode Ways]]></title>
      <link>http://garfieldog.github.io/2015/09/17/decode-ways/</link>
      <guid>http://garfieldog.github.io/2015/09/17/decode-ways/</guid>
      <pubDate>Thu, 17 Sep 2015 08:32:33 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>Given an encoded message containing digits, determine the total number of ways to decode it.</p>
<p>For example,<br>Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12).</p>
<p>The number of ways decoding “12” is 2.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题乍一看让人想起了<a href="/2015/09/15/restore-ip-addresses/">Restore IP Addresses</a>，这道题用DFS肯定能做，但效率不高。简单观察一下就会发现动态规划的最优子结构。用<code>dp[i]</code>表示前i个字符解码方法数，则如果当前字符和前一个字符可以构成合法的两位数，则<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，否则<code>dp[i] = dp[i - 1]</code>。 注意这道题的测试用例里有很多非法的<code>0</code>，处理这些非法值是比较麻烦的一点。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">9</span> &lt; int(s[i - <span class="number">2</span>: i]) &lt;= <span class="number">26</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i - <span class="number">1</span>] != <span class="string">'0'</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/decode-ways/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Edit Distance]]></title>
      <link>http://garfieldog.github.io/2015/09/17/edit-distance/</link>
      <guid>http://garfieldog.github.io/2015/09/17/edit-distance/</guid>
      <pubDate>Thu, 17 Sep 2015 08:13:19 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (ea]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.)</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>a) Insert a character<br>b) Delete a character<br>c) Replace a character</p>
</blockquote>
<h2 id="分析">分析</h2><p><code>编辑距离</code>是一个很重要的文本相似度度量标准，比较经典，通常的解法都是二维动态规划。<code>dp[i][j]</code>代表word1中前i个字符和word2前j个字符的编辑距离，则有</p>
<pre><code>dp[<span class="link_label">i</span>][<span class="link_reference">j</span>] = dp[<span class="link_label">i - 1</span>][<span class="link_reference">j - 1</span>] (if word1[i] == word2[j])
dp[<span class="link_label">i</span>][<span class="link_reference">j</span>] = min(dp[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>], dp[<span class="link_label">i</span>][<span class="link_reference">j - 1</span>], dp[<span class="link_label">i - 1</span>][<span class="link_reference">j - 1</span>]) + 1 (otherwise)
</code></pre><h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type word1: str</span><br><span class="line">        :type word2: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n1 = len(word1)</span><br><span class="line">        n2 = len(word2)</span><br><span class="line">        <span class="keyword">if</span> word1 == word2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (n2 + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n1 + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/edit-distance/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Minimum Path Sum]]></title>
      <link>http://garfieldog.github.io/2015/09/17/minimum-path-sum/</link>
      <guid>http://garfieldog.github.io/2015/09/17/minimum-path-sum/</guid>
      <pubDate>Thu, 17 Sep 2015 07:55:30 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which mini]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
</blockquote>
<h2 id="分析">分析</h2><p>终于来了道简单点的找点自信，普通二维动态规划，<code>dp[i][j]</code>代表以<code>(i, j)</code>为终点的路径的最小长度，则有<code>dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</code>，很容易转化为一维空间。时间<code>O(mn)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type grid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + grid[<span class="number">0</span>][i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                dp[j] = min(dp[j], dp[j - <span class="number">1</span>]) + grid[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/minimum-path-sum/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Scramble String]]></title>
      <link>http://garfieldog.github.io/2015/09/17/scramble-string/</link>
      <guid>http://garfieldog.github.io/2015/09/17/scramble-string/</guid>
      <pubDate>Thu, 17 Sep 2015 06:51:45 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings re]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.</p>
<p>Below is one possible representation of s1 = “great”:</p>
<pre><code>great
</code></pre><p>   /    \<br>  gr    eat<br> / \    /  \<br>g   r  e   at<br>           / \<br>          a   t<br>To scramble the string, we may choose any non-leaf node and swap its two children.</p>
<p>For example, if we choose the node “gr” and swap its two children, it produces a scrambled string “rgeat”.</p>
<pre><code>rgeat
</code></pre><p>   /    \<br>  rg    eat<br> / \    /  \<br>r   g  e   at<br>           / \<br>          a   t<br>We say that “rgeat” is a scrambled string of “great”.</p>
<p>Similarly, if we continue to swap the children of nodes “eat” and “at”, it produces a scrambled string “rgtae”.</p>
<pre><code>rgtae
</code></pre><p>   /    \<br>  rg    tae<br> / \    /  \<br>r   g  ta  e<br>       / \<br>      t   a<br>We say that “rgtae” is a scrambled string of “great”.</p>
<p>Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题我已经弃疗了，三维动态规划，正确解摆在面前也费劲。参考<a href="http://www.acmerblog.com/leetcode-solution-scramble-string-6224.html" target="_blank" rel="external">这里</a>。</p>
<p>有一个递归的解写起来比较容易，但是会超时。</p>
<h2 id="代码">代码</h2><h3 id="动态规划">动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) != len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(s1)</span><br><span class="line">        dp = [[[<span class="keyword">False</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n)] <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                dp[<span class="number">1</span>][i][j] = s1[i] == s2[j]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - z + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n - z + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">1</span>, z):</span><br><span class="line">                        <span class="keyword">if</span> (dp[k][i][j] <span class="keyword">and</span> dp[z - k][i + k][j + k]) <span class="keyword">or</span> \</span><br><span class="line">                                (dp[k][i][j + z - k] <span class="keyword">and</span> dp[z - k][i + k][j]):</span><br><span class="line">                            dp[z][i][j] = <span class="keyword">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h3 id="递归（超时）">递归（超时）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isScramble</span><span class="params">(self, s1, s2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s1) != len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(s1)</span><br><span class="line">        <span class="keyword">if</span> s1 == s2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[:i]) <span class="keyword">and</span> \</span><br><span class="line">                    self.isScramble(s1[i:], s2[i:]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> self.isScramble(s1[:i], s2[-i:]) <span class="keyword">and</span> \</span><br><span class="line">                    self.isScramble(s1[i:], s2[:-i]):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/scramble-string/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Interleaving String]]></title>
      <link>http://garfieldog.github.io/2015/09/17/interleaving-string/</link>
      <guid>http://garfieldog.github.io/2015/09/17/interleaving-string/</guid>
      <pubDate>Thu, 17 Sep 2015 05:56:59 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Give]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>For example,<br>Given:<br>s1 = “aabcc”,<br>s2 = “dbbca”,</p>
<p>When s3 = “aadbbcbcac”, return true.<br>When s3 = “aadbbbaccc”, return false.</p>
</blockquote>
<h2 id="分析">分析</h2><p>二维动态规划的思路，令<code>dp[i][j]</code>表示<code>s3的前i + j个字符是否可以由s1的前i个和s2的前j个字符交织组成</code>，显然有<code>dp[0][0] = True</code>，而<code>dp[0][j]</code>和<code>dp[i][0]</code>可以很容易预先填充，然后对于<code>dp[i][j]</code>，有递推公式</p>
<pre><code>dp[<span class="link_label">i</span>][<span class="link_reference">j</span>] = (dp[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>] and s1[i - 1] == s3[i + j - 1]) or \
<span class="code">            (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])</span>
</code></pre><h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1, s2, s3)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :type s3: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        n1 = len(s1)</span><br><span class="line">        n2 = len(s2)</span><br><span class="line">        <span class="keyword">if</span> len(s3) != n1 + n2:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (n2 + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n1 + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dp[i][<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dp[<span class="number">0</span>][j]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n1 + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">1</span>, n2 + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">if</span> dp[i][j - <span class="number">1</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2]</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/interleaving-string/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Maximal Rectangle]]></title>
      <link>http://garfieldog.github.io/2015/09/17/maximal-rectangle/</link>
      <guid>http://garfieldog.github.io/2015/09/17/maximal-rectangle/</guid>
      <pubDate>Thu, 17 Sep 2015 02:58:14 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and retu]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing all ones and return its area.</p>
</blockquote>
<h2 id="分析">分析</h2><p>这道题难度颇大，主题人出来我保证不打死你，双向动态规划可解，分析懒得写了，直接看<a href="http://liangjiabin.com/blog/2015/04/leetcode-maximal-rectangle.html" target="_blank" rel="external">这篇文章</a>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[str]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        H = [<span class="number">0</span>] * n</span><br><span class="line">        L = [<span class="number">0</span>] * n</span><br><span class="line">        R = [n] * n</span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(m):</span><br><span class="line">            left = <span class="number">0</span></span><br><span class="line">            right = n</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    H[j] += <span class="number">1</span></span><br><span class="line">                    L[j] = max(L[j], left)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = j + <span class="number">1</span></span><br><span class="line">                    H[j] = <span class="number">0</span></span><br><span class="line">                    L[j] = <span class="number">0</span></span><br><span class="line">                    R[j] = n</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">'1'</span>:</span><br><span class="line">                    R[j] = min(R[j], right)</span><br><span class="line">                    max_area = max(max_area, H[j] * (R[j] - L[j]))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = j</span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/maximal-rectangle/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Maximum Subarray]]></title>
      <link>http://garfieldog.github.io/2015/09/17/maximum-subarray/</link>
      <guid>http://garfieldog.github.io/2015/09/17/maximum-subarray/</guid>
      <pubDate>Thu, 17 Sep 2015 02:21:10 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.<]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>
<p>For example, given the array [−2,1,−3,4,−1,2,1,−5,4],<br>the contiguous subarray [4,−1,2,1] has the largest sum = 6.</p>
<p>More practice:<br>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
</blockquote>
<h2 id="分析">分析</h2><p>经典的教科书题，最大连续子序列。最简单的解是双重循环遍历数组下标，选择区间<code>[i..j]</code>比较加和，时间<code>O(n^3)</code>，必然超时。我们来寻找最优子结构，另<code>dp[i]</code>为<code>以nums[i]为结尾的子数组最大加和</code>，则<code>dp[i] = max(dp[i - 1], 0) + nums[i]</code>。一维动态规划，时间<code>O(n)</code>，空间<code>O(n)</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            dp[i] = max(<span class="number">0</span>, dp[i - <span class="number">1</span>]) + nums[i]</span><br><span class="line">        <span class="keyword">return</span> max(dp)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/maximum-subarray/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Triangle]]></title>
      <link>http://garfieldog.github.io/2015/09/17/triangle/</link>
      <guid>http://garfieldog.github.io/2015/09/17/triangle/</guid>
      <pubDate>Thu, 17 Sep 2015 01:51:16 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent number]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>
<p>For example, given the following triangle<br>[<br>     [2],<br>    [3,4],<br>   [6,5,7],<br>  [4,1,8,3]<br>]<br>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>
<p>Note:<br>Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p>
</blockquote>
<h2 id="分析">分析</h2><p>一道典型的动态规划题，我们用<code>dp[i][j]</code>表示<code>以root为头、triangle[i][j]为结束节点的最短路径长度</code>，则<code>dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i][j]</code>。这个二维递推式可以用一个一维数组来完成，只要每一行都倒着填充就可以了。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type triangle: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        dp = [float(<span class="string">'inf'</span>)] * (n + <span class="number">1</span>)</span><br><span class="line">        min_path = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        dp[<span class="number">1</span>] = min_path</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                dp[j] = min(dp[j], dp[j - <span class="number">1</span>]) + triangle[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> min(dp)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/17/triangle/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Container with Most Water]]></title>
      <link>http://garfieldog.github.io/2015/09/16/container-with-most-water/</link>
      <guid>http://garfieldog.github.io/2015/09/16/container-with-most-water/</guid>
      <pubDate>Wed, 16 Sep 2015 10:36:15 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n verti]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given n non-negative integers a1, a2, …, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container.</p>
</blockquote>
<h2 id="分析">分析</h2><p><code>O(n^2)</code>的算法很简单，双重循环找到最优解，但显然超时。可以只用一次遍历，使用两指针，分别从头和从尾部开始，计算他们之间的面积，如果头部的木板比尾部的低，则可以直接将头指针后移，因为这已经是以它为第一块木板所能够围成的最大面积。如果比尾部高，则尾指针前移。很像<a href="/2015/08/22/trapping-rain-water/">Trapping Rain Water</a>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type height: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        low = <span class="number">0</span></span><br><span class="line">        high = len(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high):</span><br><span class="line">            area = min(height[low], height[high]) * (high - low)</span><br><span class="line">            max_area = max(max_area, area)</span><br><span class="line">            <span class="keyword">if</span> height[low] &lt;= height[high]:</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_area</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/container-with-most-water/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Longest Substring Without Repeating Characters]]></title>
      <link>http://garfieldog.github.io/2015/09/16/longest-substring-without-repeating-characters/</link>
      <guid>http://garfieldog.github.io/2015/09/16/longest-substring-without-repeating-characters/</guid>
      <pubDate>Wed, 16 Sep 2015 09:53:57 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the l]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
</blockquote>
<h2 id="分析">分析</h2><p><code>O(n^2)</code>的算法很容易想，在每个位置上找满足要求的子串。必然会超时。我们借用KMP类似的思想，发现重复字符时步子可以迈得大一点。我们发现在重复字符上一次出现之前的部分都不用在搜索了，因为肯定不会产生比现有子串更长的了。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        last = &#123;&#125;</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            last_idx = last.get(s[i], -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> last_idx &gt;= start:</span><br><span class="line">                max_len = max(i - start, max_len)</span><br><span class="line">                start = last_idx + <span class="number">1</span></span><br><span class="line">            last[s[i]] = i</span><br><span class="line">        <span class="keyword">return</span> max(n - start, max_len)</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/longest-substring-without-repeating-characters/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Best Time to Buy and Sell Stock IV]]></title>
      <link>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-4/</link>
      <guid>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-4/</guid>
      <pubDate>Wed, 16 Sep 2015 09:06:38 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/16/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock</a>的后继问题，这次彻底灵活了，可以买卖k次，同样任何时刻手上最多持有1股。</p>
<p>如果<code>k &gt; n / 2</code> 其实就退化成了不限次数买卖的情况，就是<a href="/2015/09/16/best-time-to-buy-and-sell-stock-2/">系列中的第二题</a>的情况。然后我们构造这样一个二维动态规划状态转移方程，令<code>local[i][j]</code>为在截止第i天最多可j次交易并且最后一次交易在最后一天卖出的最大利润，<code>global[i][j]</code>为在截止第i天时最多可j次交易的最大利润，目标就是<code>global[n - 1][k]</code>。</p>
<pre><code>local[<span class="link_label">i</span>][<span class="link_reference">j</span>] = max(global[<span class="link_label">i - 1</span>][<span class="link_reference">j - 1</span>] + max(diff, 0), local[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>] + diff)
global[<span class="link_label">i</span>][<span class="link_reference">j</span>] = max(local[<span class="link_label">i</span>][<span class="link_reference">j</span>], global[<span class="link_label">i - 1</span>][<span class="link_reference">j</span>])
</code></pre><h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, k, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type k: int</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; n / <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> self.maxProfitNoLimit(prices)</span><br><span class="line">        l = [<span class="number">0</span>] * (k + <span class="number">1</span>)</span><br><span class="line">        g = [<span class="number">0</span>] * (k + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            diff = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                l[j] = max(g[j - <span class="number">1</span>] + max(diff, <span class="number">0</span>), l[j] + diff)</span><br><span class="line">                g[j] = max(l[j], g[j])</span><br><span class="line">        <span class="keyword">return</span> g[k]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfitNoLimit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            diff = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            profit += max(<span class="number">0</span>, diff)</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-4/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Best Time to Buy and Sell Stock III]]></title>
      <link>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-3/</link>
      <guid>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-3/</guid>
      <pubDate>Wed, 16 Sep 2015 08:17:46 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/16/best-time-to-buy-and-sell-stock/">Best Time to Buy and Sell Stock</a>的后继问题，这次可以买卖两次，但任何时刻手上最多只能持有1股。这下就难了不少，可以考虑分治法，遍历数组位置<code>i</code>，分别用<a href="/2015/09/16/best-time-to-buy-and-sell-stock/">这一题</a>中的算法求<code>[0..i]</code>和<code>[i..n-1]</code>的最大利润，再挑选最佳位置<code>i</code>。时间复杂度<code>O(n^2)</code>，这个解法会超时。</p>
<p>我们观察上面这个算法，它要求的<code>f(0, i), 0 &lt;= i &lt; n</code>其实可以在一次遍历中全部求出，只要我们的算法加一个缓存数组就可以了。同理<code>f(i, n)</code>也是一样的，倒着求就行。这样一来，我们只要扫描两遍数组，就能得到想要的部分解了。时间复杂度降到了<code>O(n)</code>，空间<code>O(n)</code>。有点像<a href="/2015/08/22/trapping-rain-water/">Trapping Rain Water</a>的解法。</p>
<h2 id="代码">代码</h2><h3 id="分治法（超时）">分治法（超时）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfitPartial</span><span class="params">(self, prices, start, end)</span>:</span></span><br><span class="line">        n = end - start + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        cur_min = prices[start]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">            profit = max(profit, prices[i] - cur_min)</span><br><span class="line">            cur_min = min(cur_min, prices[i])</span><br><span class="line">        <span class="keyword">return</span> profit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            profit = self.maxProfitPartial(prices, <span class="number">0</span>, i) + self.maxProfitPartial(prices, i, n - <span class="number">1</span>)</span><br><span class="line">            max_profit = max(max_profit, profit)</span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
<h3 id="动态规划">动态规划</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfitPartial</span><span class="params">(self, prices, start, end)</span>:</span></span><br><span class="line">        n = end - start + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        cur_min = prices[start]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(start + <span class="number">1</span>, end + <span class="number">1</span>):</span><br><span class="line">            profit = max(profit, prices[i] - cur_min)</span><br><span class="line">            cur_min = min(cur_min, prices[i])</span><br><span class="line">        <span class="keyword">return</span> profit</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = [<span class="number">0</span>] * n</span><br><span class="line">        cur_min = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            left[i] = max(left[i - <span class="number">1</span>], prices[i] - cur_min)</span><br><span class="line">            cur_min = min(cur_min, prices[i])</span><br><span class="line"></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        max_profit = <span class="number">0</span></span><br><span class="line">        cur_max = prices[n - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            profit = max(profit, cur_max - prices[i])</span><br><span class="line">            cur_max = max(cur_max, prices[i])</span><br><span class="line">            max_profit = max(max_profit, profit + left[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-3/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Best Time to Buy and Sell Stock II]]></title>
      <link>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-2/</link>
      <guid>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-2/</guid>
      <pubDate>Wed, 16 Sep 2015 08:04:56 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an ]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/16/best-time-to-buy-and-sell-stock/">上一题</a>的后继问题，这次仍然做时候诸葛亮，而且可以买卖多次，但是有个条件就是手上最多持有1股。非常简单，就是找每一个递增的区间，在区间底部买入，顶部卖出即可，一遍扫描。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            diff = prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">            profit += max(<span class="number">0</span>, diff)</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Best Time to Buy and Sell Stock]]></title>
      <link>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock/</link>
      <guid>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock/</guid>
      <pubDate>Wed, 16 Sep 2015 07:50:49 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you wer]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
</blockquote>
<h2 id="分析">分析</h2><p>要理解题意，给定一只股票一段时间内每天的估价，做一下事后诸葛亮，问如果只做一次交易（买一次买一次，注意不能卖空，所以必须先买后卖），所以就是找到低价，然后高价卖出，要求是低价必须在高价前面。扫描一遍数组即可，维护当前的最大利润和当前最低价。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type prices: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        profit = <span class="number">0</span></span><br><span class="line">        cur_min = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            profit = max(profit, prices[i] - cur_min)</span><br><span class="line">            cur_min = min(cur_min, prices[i])</span><br><span class="line">        <span class="keyword">return</span> profit</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/best-time-to-buy-and-sell-stock/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Jump Game II]]></title>
      <link>http://garfieldog.github.io/2015/09/16/jump-game-2/</link>
      <guid>http://garfieldog.github.io/2015/09/16/jump-game-2/</guid>
      <pubDate>Wed, 16 Sep 2015 07:11:06 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>For example:<br>Given array A = [2,3,1,1,4]</p>
<p>The minimum number of jumps to reach the last index is 2. (Jump 1 step from index 0 to 1, then 3 steps to the last index.)</p>
</blockquote>
<h2 id="分析">分析</h2><p><a href="/2015/09/16/jump-game/">Jump Game</a>的后继问题，这次要求得出最小跳跃步数，我们用两个变量来分别记录<code>现在到达的位置</code>和<code>下一次最大能到达的未知</code>，遍历数组，如果下标超出<code>现在到达的位置</code>，则说明需要跳一步。比较巧妙，需要仔细推敲。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        reach = <span class="number">0</span></span><br><span class="line">        next_reach = <span class="number">0</span></span><br><span class="line">        step = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">if</span> step &gt; <span class="number">0</span>:</span><br><span class="line">                step -= <span class="number">1</span></span><br><span class="line">                step = max(step, nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i &gt; reach:</span><br><span class="line">                reach = next_reach</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            next_reach = max(next_reach, i + nums[i])</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/jump-game-2/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Jump Game]]></title>
      <link>http://garfieldog.github.io/2015/09/16/jump-game/</link>
      <guid>http://garfieldog.github.io/2015/09/16/jump-game/</guid>
      <pubDate>Wed, 16 Sep 2015 06:30:34 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>For example:<br>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
</blockquote>
<h2 id="分析">分析</h2><p>DFS固然是可以，但其实可以只保留一条路径（就是每次都选可选范围内下一个最大的步数，反证法可证如果有解，这样肯定能找到一个解），其他路径都被剪枝，这样一来就满足了贪心法的条件。</p>
<h2 id="代码">代码</h2><h3 id="迭代">迭代</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        step = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> step &gt; <span class="number">0</span>:</span><br><span class="line">                step -= <span class="number">1</span></span><br><span class="line">                step = max(step, nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/jump-game/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Leetcode解题-Sqrt(x)]]></title>
      <link>http://garfieldog.github.io/2015/09/16/sqrt-x/</link>
      <guid>http://garfieldog.github.io/2015/09/16/sqrt-x/</guid>
      <pubDate>Wed, 16 Sep 2015 06:13:57 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
</blockquote>
<h2 id="分析">]]>
      </description>
      <content:encoded><![CDATA[<h2 id="描述">描述</h2><blockquote>
<p>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x.</p>
</blockquote>
<h2 id="分析">分析</h2><p>二分查找。注意结果要向下取整时返回<code>high</code>。</p>
<h2 id="代码">代码</h2><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        low = <span class="number">1</span></span><br><span class="line">        high = x / <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span></span><br><span class="line">            r = mid * mid</span><br><span class="line">            <span class="keyword">if</span> r == x:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> r &lt; x:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> high</span><br></pre></td></tr></table></figure>
]]></content:encoded>
      <comments>http://garfieldog.github.io/2015/09/16/sqrt-x/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
